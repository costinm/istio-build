// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: collector.proto

#ifndef PROTOBUF_collector_2eproto__INCLUDED
#define PROTOBUF_collector_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
namespace lightstep {
namespace collector {
class Auth;
class AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class InternalMetrics;
class InternalMetricsDefaultTypeInternal;
extern InternalMetricsDefaultTypeInternal _InternalMetrics_default_instance_;
class KeyValue;
class KeyValueDefaultTypeInternal;
extern KeyValueDefaultTypeInternal _KeyValue_default_instance_;
class Log;
class LogDefaultTypeInternal;
extern LogDefaultTypeInternal _Log_default_instance_;
class MetricsSample;
class MetricsSampleDefaultTypeInternal;
extern MetricsSampleDefaultTypeInternal _MetricsSample_default_instance_;
class Reference;
class ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class ReportRequest;
class ReportRequestDefaultTypeInternal;
extern ReportRequestDefaultTypeInternal _ReportRequest_default_instance_;
class ReportResponse;
class ReportResponseDefaultTypeInternal;
extern ReportResponseDefaultTypeInternal _ReportResponse_default_instance_;
class Reporter;
class ReporterDefaultTypeInternal;
extern ReporterDefaultTypeInternal _Reporter_default_instance_;
class Span;
class SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class SpanContext;
class SpanContextDefaultTypeInternal;
extern SpanContextDefaultTypeInternal _SpanContext_default_instance_;
class SpanContext_BaggageEntry;
class SpanContext_BaggageEntryDefaultTypeInternal;
extern SpanContext_BaggageEntryDefaultTypeInternal _SpanContext_BaggageEntry_default_instance_;
}  // namespace collector
}  // namespace lightstep

namespace lightstep {
namespace collector {

namespace protobuf_collector_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_collector_2eproto

enum Reference_Relationship {
  Reference_Relationship_CHILD_OF = 0,
  Reference_Relationship_FOLLOWS_FROM = 1,
  Reference_Relationship_Reference_Relationship_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Reference_Relationship_Reference_Relationship_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Reference_Relationship_IsValid(int value);
const Reference_Relationship Reference_Relationship_Relationship_MIN = Reference_Relationship_CHILD_OF;
const Reference_Relationship Reference_Relationship_Relationship_MAX = Reference_Relationship_FOLLOWS_FROM;
const int Reference_Relationship_Relationship_ARRAYSIZE = Reference_Relationship_Relationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reference_Relationship_descriptor();
inline const ::std::string& Reference_Relationship_Name(Reference_Relationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reference_Relationship_descriptor(), value);
}
inline bool Reference_Relationship_Parse(
    const ::std::string& name, Reference_Relationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reference_Relationship>(
    Reference_Relationship_descriptor(), name, value);
}
// ===================================================================


// -------------------------------------------------------------------

class SpanContext : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.SpanContext) */ {
 public:
  SpanContext();
  virtual ~SpanContext();

  SpanContext(const SpanContext& from);

  inline SpanContext& operator=(const SpanContext& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpanContext(SpanContext&& from) noexcept
    : SpanContext() {
    *this = ::std::move(from);
  }

  inline SpanContext& operator=(SpanContext&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SpanContext& default_instance();

  static inline const SpanContext* internal_default_instance() {
    return reinterpret_cast<const SpanContext*>(
               &_SpanContext_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SpanContext* other);
  friend void swap(SpanContext& a, SpanContext& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpanContext* New() const PROTOBUF_FINAL { return New(NULL); }

  SpanContext* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SpanContext& from);
  void MergeFrom(const SpanContext& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SpanContext* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> baggage = 3;
  int baggage_size() const;
  void clear_baggage();
  static const int kBaggageFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      baggage() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_baggage();

  // uint64 trace_id = 1;
  void clear_trace_id();
  static const int kTraceIdFieldNumber = 1;
  ::google::protobuf::uint64 trace_id() const;
  void set_trace_id(::google::protobuf::uint64 value);

  // uint64 span_id = 2;
  void clear_span_id();
  static const int kSpanIdFieldNumber = 2;
  ::google::protobuf::uint64 span_id() const;
  void set_span_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.SpanContext)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  public:
  class SpanContext_BaggageEntry : public ::google::protobuf::internal::MapEntry<SpanContext_BaggageEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > {
  public:
    typedef ::google::protobuf::internal::MapEntry<SpanContext_BaggageEntry, 
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > SuperType;
    SpanContext_BaggageEntry();
    SpanContext_BaggageEntry(::google::protobuf::Arena* arena);
    void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
    void MergeFrom(const SpanContext_BaggageEntry& other);
    static const Message* internal_default_instance() { return reinterpret_cast<const Message*>(&_SpanContext_BaggageEntry_default_instance_); }
    ::google::protobuf::Metadata GetMetadata() const;
  };
  private:
  ::google::protobuf::internal::MapField<
      SpanContext_BaggageEntry,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > baggage_;
  private:
  ::google::protobuf::uint64 trace_id_;
  ::google::protobuf::uint64 span_id_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.KeyValue) */ {
 public:
  KeyValue();
  virtual ~KeyValue();

  KeyValue(const KeyValue& from);

  inline KeyValue& operator=(const KeyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValue(KeyValue&& from) noexcept
    : KeyValue() {
    *this = ::std::move(from);
  }

  inline KeyValue& operator=(KeyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValue& default_instance();

  enum ValueCase {
    kStringValue = 2,
    kIntValue = 3,
    kDoubleValue = 4,
    kBoolValue = 5,
    kJsonValue = 6,
    VALUE_NOT_SET = 0,
  };

  static inline const KeyValue* internal_default_instance() {
    return reinterpret_cast<const KeyValue*>(
               &_KeyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(KeyValue* other);
  friend void swap(KeyValue& a, KeyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  KeyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeyValue& from);
  void MergeFrom(const KeyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string string_value = 2;
  private:
  bool has_string_value() const;
  public:
  void clear_string_value();
  static const int kStringValueFieldNumber = 2;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // int64 int_value = 3;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 3;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // double double_value = 4;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  double double_value() const;
  void set_double_value(double value);

  // bool bool_value = 5;
  private:
  bool has_bool_value() const;
  public:
  void clear_bool_value();
  static const int kBoolValueFieldNumber = 5;
  bool bool_value() const;
  void set_bool_value(bool value);

  // string json_value = 6;
  private:
  bool has_json_value() const;
  public:
  void clear_json_value();
  static const int kJsonValueFieldNumber = 6;
  const ::std::string& json_value() const;
  void set_json_value(const ::std::string& value);
  #if LANG_CXX11
  void set_json_value(::std::string&& value);
  #endif
  void set_json_value(const char* value);
  void set_json_value(const char* value, size_t size);
  ::std::string* mutable_json_value();
  ::std::string* release_json_value();
  void set_allocated_json_value(::std::string* json_value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:lightstep.collector.KeyValue)
 private:
  void set_has_string_value();
  void set_has_int_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_json_value();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    ::google::protobuf::int64 int_value_;
    double double_value_;
    bool bool_value_;
    ::google::protobuf::internal::ArenaStringPtr json_value_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Log : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Log) */ {
 public:
  Log();
  virtual ~Log();

  Log(const Log& from);

  inline Log& operator=(const Log& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Log(Log&& from) noexcept
    : Log() {
    *this = ::std::move(from);
  }

  inline Log& operator=(Log&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Log& default_instance();

  static inline const Log* internal_default_instance() {
    return reinterpret_cast<const Log*>(
               &_Log_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Log* other);
  friend void swap(Log& a, Log& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Log* New() const PROTOBUF_FINAL { return New(NULL); }

  Log* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Log& from);
  void MergeFrom(const Log& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Log* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.KeyValue keyvalues = 2;
  int keyvalues_size() const;
  void clear_keyvalues();
  static const int kKeyvaluesFieldNumber = 2;
  const ::lightstep::collector::KeyValue& keyvalues(int index) const;
  ::lightstep::collector::KeyValue* mutable_keyvalues(int index);
  ::lightstep::collector::KeyValue* add_keyvalues();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_keyvalues();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      keyvalues() const;

  // .google.protobuf.Timestamp timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Log)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > keyvalues_;
  ::google::protobuf::Timestamp* timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Reference) */ {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(Reference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reference& default_instance();

  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Reference* other);
  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reference* New() const PROTOBUF_FINAL { return New(NULL); }

  Reference* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Reference* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Reference_Relationship Relationship;
  static const Relationship CHILD_OF =
    Reference_Relationship_CHILD_OF;
  static const Relationship FOLLOWS_FROM =
    Reference_Relationship_FOLLOWS_FROM;
  static inline bool Relationship_IsValid(int value) {
    return Reference_Relationship_IsValid(value);
  }
  static const Relationship Relationship_MIN =
    Reference_Relationship_Relationship_MIN;
  static const Relationship Relationship_MAX =
    Reference_Relationship_Relationship_MAX;
  static const int Relationship_ARRAYSIZE =
    Reference_Relationship_Relationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Relationship_descriptor() {
    return Reference_Relationship_descriptor();
  }
  static inline const ::std::string& Relationship_Name(Relationship value) {
    return Reference_Relationship_Name(value);
  }
  static inline bool Relationship_Parse(const ::std::string& name,
      Relationship* value) {
    return Reference_Relationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .lightstep.collector.SpanContext span_context = 2;
  bool has_span_context() const;
  void clear_span_context();
  static const int kSpanContextFieldNumber = 2;
  const ::lightstep::collector::SpanContext& span_context() const;
  ::lightstep::collector::SpanContext* mutable_span_context();
  ::lightstep::collector::SpanContext* release_span_context();
  void set_allocated_span_context(::lightstep::collector::SpanContext* span_context);

  // .lightstep.collector.Reference.Relationship relationship = 1;
  void clear_relationship();
  static const int kRelationshipFieldNumber = 1;
  ::lightstep::collector::Reference_Relationship relationship() const;
  void set_relationship(::lightstep::collector::Reference_Relationship value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Reference)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::lightstep::collector::SpanContext* span_context_;
  int relationship_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Span : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Span) */ {
 public:
  Span();
  virtual ~Span();

  Span(const Span& from);

  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Span(Span&& from) noexcept
    : Span() {
    *this = ::std::move(from);
  }

  inline Span& operator=(Span&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Span& default_instance();

  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
               &_Span_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Span* other);
  friend void swap(Span& a, Span& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Span* New() const PROTOBUF_FINAL { return New(NULL); }

  Span* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Span& from);
  void MergeFrom(const Span& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Span* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.Reference references = 3;
  int references_size() const;
  void clear_references();
  static const int kReferencesFieldNumber = 3;
  const ::lightstep::collector::Reference& references(int index) const;
  ::lightstep::collector::Reference* mutable_references(int index);
  ::lightstep::collector::Reference* add_references();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >*
      mutable_references();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >&
      references() const;

  // repeated .lightstep.collector.KeyValue tags = 6;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 6;
  const ::lightstep::collector::KeyValue& tags(int index) const;
  ::lightstep::collector::KeyValue* mutable_tags(int index);
  ::lightstep::collector::KeyValue* add_tags();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      tags() const;

  // repeated .lightstep.collector.Log logs = 7;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 7;
  const ::lightstep::collector::Log& logs(int index) const;
  ::lightstep::collector::Log* mutable_logs(int index);
  ::lightstep::collector::Log* add_logs();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
      mutable_logs();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
      logs() const;

  // string operation_name = 2;
  void clear_operation_name();
  static const int kOperationNameFieldNumber = 2;
  const ::std::string& operation_name() const;
  void set_operation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_operation_name(::std::string&& value);
  #endif
  void set_operation_name(const char* value);
  void set_operation_name(const char* value, size_t size);
  ::std::string* mutable_operation_name();
  ::std::string* release_operation_name();
  void set_allocated_operation_name(::std::string* operation_name);

  // .lightstep.collector.SpanContext span_context = 1;
  bool has_span_context() const;
  void clear_span_context();
  static const int kSpanContextFieldNumber = 1;
  const ::lightstep::collector::SpanContext& span_context() const;
  ::lightstep::collector::SpanContext* mutable_span_context();
  ::lightstep::collector::SpanContext* release_span_context();
  void set_allocated_span_context(::lightstep::collector::SpanContext* span_context);

  // .google.protobuf.Timestamp start_timestamp = 4;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 4;
  const ::google::protobuf::Timestamp& start_timestamp() const;
  ::google::protobuf::Timestamp* mutable_start_timestamp();
  ::google::protobuf::Timestamp* release_start_timestamp();
  void set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp);

  // uint64 duration_micros = 5;
  void clear_duration_micros();
  static const int kDurationMicrosFieldNumber = 5;
  ::google::protobuf::uint64 duration_micros() const;
  void set_duration_micros(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Span)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference > references_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > tags_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log > logs_;
  ::google::protobuf::internal::ArenaStringPtr operation_name_;
  ::lightstep::collector::SpanContext* span_context_;
  ::google::protobuf::Timestamp* start_timestamp_;
  ::google::protobuf::uint64 duration_micros_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Reporter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Reporter) */ {
 public:
  Reporter();
  virtual ~Reporter();

  Reporter(const Reporter& from);

  inline Reporter& operator=(const Reporter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reporter(Reporter&& from) noexcept
    : Reporter() {
    *this = ::std::move(from);
  }

  inline Reporter& operator=(Reporter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reporter& default_instance();

  static inline const Reporter* internal_default_instance() {
    return reinterpret_cast<const Reporter*>(
               &_Reporter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Reporter* other);
  friend void swap(Reporter& a, Reporter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reporter* New() const PROTOBUF_FINAL { return New(NULL); }

  Reporter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Reporter& from);
  void MergeFrom(const Reporter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Reporter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.KeyValue tags = 4;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 4;
  const ::lightstep::collector::KeyValue& tags(int index) const;
  ::lightstep::collector::KeyValue* mutable_tags(int index);
  ::lightstep::collector::KeyValue* add_tags();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
      tags() const;

  // uint64 reporter_id = 1;
  void clear_reporter_id();
  static const int kReporterIdFieldNumber = 1;
  ::google::protobuf::uint64 reporter_id() const;
  void set_reporter_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Reporter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue > tags_;
  ::google::protobuf::uint64 reporter_id_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetricsSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.MetricsSample) */ {
 public:
  MetricsSample();
  virtual ~MetricsSample();

  MetricsSample(const MetricsSample& from);

  inline MetricsSample& operator=(const MetricsSample& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetricsSample(MetricsSample&& from) noexcept
    : MetricsSample() {
    *this = ::std::move(from);
  }

  inline MetricsSample& operator=(MetricsSample&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricsSample& default_instance();

  enum ValueCase {
    kIntValue = 2,
    kDoubleValue = 3,
    VALUE_NOT_SET = 0,
  };

  static inline const MetricsSample* internal_default_instance() {
    return reinterpret_cast<const MetricsSample*>(
               &_MetricsSample_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MetricsSample* other);
  friend void swap(MetricsSample& a, MetricsSample& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetricsSample* New() const PROTOBUF_FINAL { return New(NULL); }

  MetricsSample* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MetricsSample& from);
  void MergeFrom(const MetricsSample& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MetricsSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 int_value = 2;
  private:
  bool has_int_value() const;
  public:
  void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  ::google::protobuf::int64 int_value() const;
  void set_int_value(::google::protobuf::int64 value);

  // double double_value = 3;
  private:
  bool has_double_value() const;
  public:
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 3;
  double double_value() const;
  void set_double_value(double value);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:lightstep.collector.MetricsSample)
 private:
  void set_has_int_value();
  void set_has_double_value();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::int64 int_value_;
    double double_value_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InternalMetrics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.InternalMetrics) */ {
 public:
  InternalMetrics();
  virtual ~InternalMetrics();

  InternalMetrics(const InternalMetrics& from);

  inline InternalMetrics& operator=(const InternalMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InternalMetrics(InternalMetrics&& from) noexcept
    : InternalMetrics() {
    *this = ::std::move(from);
  }

  inline InternalMetrics& operator=(InternalMetrics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalMetrics& default_instance();

  static inline const InternalMetrics* internal_default_instance() {
    return reinterpret_cast<const InternalMetrics*>(
               &_InternalMetrics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(InternalMetrics* other);
  friend void swap(InternalMetrics& a, InternalMetrics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InternalMetrics* New() const PROTOBUF_FINAL { return New(NULL); }

  InternalMetrics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InternalMetrics& from);
  void MergeFrom(const InternalMetrics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InternalMetrics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.Log logs = 3;
  int logs_size() const;
  void clear_logs();
  static const int kLogsFieldNumber = 3;
  const ::lightstep::collector::Log& logs(int index) const;
  ::lightstep::collector::Log* mutable_logs(int index);
  ::lightstep::collector::Log* add_logs();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
      mutable_logs();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
      logs() const;

  // repeated .lightstep.collector.MetricsSample counts = 4;
  int counts_size() const;
  void clear_counts();
  static const int kCountsFieldNumber = 4;
  const ::lightstep::collector::MetricsSample& counts(int index) const;
  ::lightstep::collector::MetricsSample* mutable_counts(int index);
  ::lightstep::collector::MetricsSample* add_counts();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
      mutable_counts();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
      counts() const;

  // repeated .lightstep.collector.MetricsSample gauges = 5;
  int gauges_size() const;
  void clear_gauges();
  static const int kGaugesFieldNumber = 5;
  const ::lightstep::collector::MetricsSample& gauges(int index) const;
  ::lightstep::collector::MetricsSample* mutable_gauges(int index);
  ::lightstep::collector::MetricsSample* add_gauges();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
      mutable_gauges();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
      gauges() const;

  // .google.protobuf.Timestamp start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  const ::google::protobuf::Timestamp& start_timestamp() const;
  ::google::protobuf::Timestamp* mutable_start_timestamp();
  ::google::protobuf::Timestamp* release_start_timestamp();
  void set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp);

  // uint64 duration_micros = 2;
  void clear_duration_micros();
  static const int kDurationMicrosFieldNumber = 2;
  ::google::protobuf::uint64 duration_micros() const;
  void set_duration_micros(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.InternalMetrics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log > logs_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample > counts_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample > gauges_;
  ::google::protobuf::Timestamp* start_timestamp_;
  ::google::protobuf::uint64 duration_micros_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(Auth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Auth* other);
  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Auth* New() const PROTOBUF_FINAL { return New(NULL); }

  Auth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Auth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string access_token = 1;
  void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  const ::std::string& access_token() const;
  void set_access_token(const ::std::string& value);
  #if LANG_CXX11
  void set_access_token(::std::string&& value);
  #endif
  void set_access_token(const char* value);
  void set_access_token(const char* value, size_t size);
  ::std::string* mutable_access_token();
  ::std::string* release_access_token();
  void set_allocated_access_token(::std::string* access_token);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Auth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr access_token_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.ReportRequest) */ {
 public:
  ReportRequest();
  virtual ~ReportRequest();

  ReportRequest(const ReportRequest& from);

  inline ReportRequest& operator=(const ReportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportRequest(ReportRequest&& from) noexcept
    : ReportRequest() {
    *this = ::std::move(from);
  }

  inline ReportRequest& operator=(ReportRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportRequest& default_instance();

  static inline const ReportRequest* internal_default_instance() {
    return reinterpret_cast<const ReportRequest*>(
               &_ReportRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ReportRequest* other);
  friend void swap(ReportRequest& a, ReportRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportRequest& from);
  void MergeFrom(const ReportRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.Span spans = 3;
  int spans_size() const;
  void clear_spans();
  static const int kSpansFieldNumber = 3;
  const ::lightstep::collector::Span& spans(int index) const;
  ::lightstep::collector::Span* mutable_spans(int index);
  ::lightstep::collector::Span* add_spans();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >*
      mutable_spans();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >&
      spans() const;

  // .lightstep.collector.Reporter reporter = 1;
  bool has_reporter() const;
  void clear_reporter();
  static const int kReporterFieldNumber = 1;
  const ::lightstep::collector::Reporter& reporter() const;
  ::lightstep::collector::Reporter* mutable_reporter();
  ::lightstep::collector::Reporter* release_reporter();
  void set_allocated_reporter(::lightstep::collector::Reporter* reporter);

  // .lightstep.collector.Auth auth = 2;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 2;
  const ::lightstep::collector::Auth& auth() const;
  ::lightstep::collector::Auth* mutable_auth();
  ::lightstep::collector::Auth* release_auth();
  void set_allocated_auth(::lightstep::collector::Auth* auth);

  // .lightstep.collector.InternalMetrics internal_metrics = 6;
  bool has_internal_metrics() const;
  void clear_internal_metrics();
  static const int kInternalMetricsFieldNumber = 6;
  const ::lightstep::collector::InternalMetrics& internal_metrics() const;
  ::lightstep::collector::InternalMetrics* mutable_internal_metrics();
  ::lightstep::collector::InternalMetrics* release_internal_metrics();
  void set_allocated_internal_metrics(::lightstep::collector::InternalMetrics* internal_metrics);

  // uint32 timestamp_offset_micros = 5;
  void clear_timestamp_offset_micros();
  static const int kTimestampOffsetMicrosFieldNumber = 5;
  ::google::protobuf::uint32 timestamp_offset_micros() const;
  void set_timestamp_offset_micros(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.ReportRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span > spans_;
  ::lightstep::collector::Reporter* reporter_;
  ::lightstep::collector::Auth* auth_;
  ::lightstep::collector::InternalMetrics* internal_metrics_;
  ::google::protobuf::uint32 timestamp_offset_micros_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool disable = 1;
  void clear_disable();
  static const int kDisableFieldNumber = 1;
  bool disable() const;
  void set_disable(bool value);

  // @@protoc_insertion_point(class_scope:lightstep.collector.Command)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool disable_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lightstep.collector.ReportResponse) */ {
 public:
  ReportResponse();
  virtual ~ReportResponse();

  ReportResponse(const ReportResponse& from);

  inline ReportResponse& operator=(const ReportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportResponse(ReportResponse&& from) noexcept
    : ReportResponse() {
    *this = ::std::move(from);
  }

  inline ReportResponse& operator=(ReportResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportResponse& default_instance();

  static inline const ReportResponse* internal_default_instance() {
    return reinterpret_cast<const ReportResponse*>(
               &_ReportResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ReportResponse* other);
  friend void swap(ReportResponse& a, ReportResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  ReportResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReportResponse& from);
  void MergeFrom(const ReportResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReportResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lightstep.collector.Command commands = 1;
  int commands_size() const;
  void clear_commands();
  static const int kCommandsFieldNumber = 1;
  const ::lightstep::collector::Command& commands(int index) const;
  ::lightstep::collector::Command* mutable_commands(int index);
  ::lightstep::collector::Command* add_commands();
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >*
      mutable_commands();
  const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >&
      commands() const;

  // repeated string errors = 4;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 4;
  const ::std::string& errors(int index) const;
  ::std::string* mutable_errors(int index);
  void set_errors(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_errors(int index, ::std::string&& value);
  #endif
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, size_t size);
  ::std::string* add_errors();
  void add_errors(const ::std::string& value);
  #if LANG_CXX11
  void add_errors(::std::string&& value);
  #endif
  void add_errors(const char* value);
  void add_errors(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& errors() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_errors();

  // .google.protobuf.Timestamp receive_timestamp = 2;
  bool has_receive_timestamp() const;
  void clear_receive_timestamp();
  static const int kReceiveTimestampFieldNumber = 2;
  const ::google::protobuf::Timestamp& receive_timestamp() const;
  ::google::protobuf::Timestamp* mutable_receive_timestamp();
  ::google::protobuf::Timestamp* release_receive_timestamp();
  void set_allocated_receive_timestamp(::google::protobuf::Timestamp* receive_timestamp);

  // .google.protobuf.Timestamp transmit_timestamp = 3;
  bool has_transmit_timestamp() const;
  void clear_transmit_timestamp();
  static const int kTransmitTimestampFieldNumber = 3;
  const ::google::protobuf::Timestamp& transmit_timestamp() const;
  ::google::protobuf::Timestamp* mutable_transmit_timestamp();
  ::google::protobuf::Timestamp* release_transmit_timestamp();
  void set_allocated_transmit_timestamp(::google::protobuf::Timestamp* transmit_timestamp);

  // @@protoc_insertion_point(class_scope:lightstep.collector.ReportResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command > commands_;
  ::google::protobuf::RepeatedPtrField< ::std::string> errors_;
  ::google::protobuf::Timestamp* receive_timestamp_;
  ::google::protobuf::Timestamp* transmit_timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_collector_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SpanContext

// uint64 trace_id = 1;
inline void SpanContext::clear_trace_id() {
  trace_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SpanContext::trace_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.SpanContext.trace_id)
  return trace_id_;
}
inline void SpanContext::set_trace_id(::google::protobuf::uint64 value) {
  
  trace_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.SpanContext.trace_id)
}

// uint64 span_id = 2;
inline void SpanContext::clear_span_id() {
  span_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SpanContext::span_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.SpanContext.span_id)
  return span_id_;
}
inline void SpanContext::set_span_id(::google::protobuf::uint64 value) {
  
  span_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.SpanContext.span_id)
}

// map<string, string> baggage = 3;
inline int SpanContext::baggage_size() const {
  return baggage_.size();
}
inline void SpanContext::clear_baggage() {
  baggage_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
SpanContext::baggage() const {
  // @@protoc_insertion_point(field_map:lightstep.collector.SpanContext.baggage)
  return baggage_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
SpanContext::mutable_baggage() {
  // @@protoc_insertion_point(field_mutable_map:lightstep.collector.SpanContext.baggage)
  return baggage_.MutableMap();
}

// -------------------------------------------------------------------

// KeyValue

// string key = 1;
inline void KeyValue::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValue::key() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.key)
  return key_.GetNoArena();
}
inline void KeyValue::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.key)
}
#if LANG_CXX11
inline void KeyValue::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.KeyValue.key)
}
#endif
inline void KeyValue::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.key)
}
inline void KeyValue::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.key)
}
inline ::std::string* KeyValue::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_key() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValue::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.key)
}

// string string_value = 2;
inline bool KeyValue::has_string_value() const {
  return value_case() == kStringValue;
}
inline void KeyValue::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void KeyValue::clear_string_value() {
  if (has_string_value()) {
    value_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& KeyValue::string_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.string_value)
  if (has_string_value()) {
    return value_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void KeyValue::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.string_value)
}
#if LANG_CXX11
inline void KeyValue::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.string_value)
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.KeyValue.string_value)
}
#endif
inline void KeyValue::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.string_value)
}
inline void KeyValue::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.string_value)
}
inline ::std::string* KeyValue::mutable_string_value() {
  if (!has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.string_value)
  return value_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_string_value() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.string_value)
  if (has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void KeyValue::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    value_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (string_value != NULL) {
    set_has_string_value();
    value_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.string_value)
}

// int64 int_value = 3;
inline bool KeyValue::has_int_value() const {
  return value_case() == kIntValue;
}
inline void KeyValue::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void KeyValue::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 KeyValue::int_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void KeyValue::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.int_value)
}

// double double_value = 4;
inline bool KeyValue::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void KeyValue::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void KeyValue::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double KeyValue::double_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void KeyValue::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.double_value)
}

// bool bool_value = 5;
inline bool KeyValue::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void KeyValue::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void KeyValue::clear_bool_value() {
  if (has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool KeyValue::bool_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.bool_value)
  if (has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void KeyValue::set_bool_value(bool value) {
  if (!has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.bool_value)
}

// string json_value = 6;
inline bool KeyValue::has_json_value() const {
  return value_case() == kJsonValue;
}
inline void KeyValue::set_has_json_value() {
  _oneof_case_[0] = kJsonValue;
}
inline void KeyValue::clear_json_value() {
  if (has_json_value()) {
    value_.json_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& KeyValue::json_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.KeyValue.json_value)
  if (has_json_value()) {
    return value_.json_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void KeyValue::set_json_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.json_value)
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.json_value)
}
#if LANG_CXX11
inline void KeyValue::set_json_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.KeyValue.json_value)
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.KeyValue.json_value)
}
#endif
inline void KeyValue::set_json_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.KeyValue.json_value)
}
inline void KeyValue::set_json_value(const char* value, size_t size) {
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.json_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.KeyValue.json_value)
}
inline ::std::string* KeyValue::mutable_json_value() {
  if (!has_json_value()) {
    clear_value();
    set_has_json_value();
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.KeyValue.json_value)
  return value_.json_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValue::release_json_value() {
  // @@protoc_insertion_point(field_release:lightstep.collector.KeyValue.json_value)
  if (has_json_value()) {
    clear_has_value();
    return value_.json_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void KeyValue::set_allocated_json_value(::std::string* json_value) {
  if (!has_json_value()) {
    value_.json_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_value();
  if (json_value != NULL) {
    set_has_json_value();
    value_.json_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        json_value);
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.KeyValue.json_value)
}

inline bool KeyValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void KeyValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline KeyValue::ValueCase KeyValue::value_case() const {
  return KeyValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Log

// .google.protobuf.Timestamp timestamp = 1;
inline bool Log::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void Log::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Log::timestamp() const {
  const ::google::protobuf::Timestamp* p = timestamp_;
  // @@protoc_insertion_point(field_get:lightstep.collector.Log.timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Log::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Log.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Log::release_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Log.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Log::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Log.timestamp)
}

// repeated .lightstep.collector.KeyValue keyvalues = 2;
inline int Log::keyvalues_size() const {
  return keyvalues_.size();
}
inline void Log::clear_keyvalues() {
  keyvalues_.Clear();
}
inline const ::lightstep::collector::KeyValue& Log::keyvalues(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Log.keyvalues)
  return keyvalues_.Get(index);
}
inline ::lightstep::collector::KeyValue* Log::mutable_keyvalues(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Log.keyvalues)
  return keyvalues_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Log::add_keyvalues() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Log.keyvalues)
  return keyvalues_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Log::mutable_keyvalues() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Log.keyvalues)
  return &keyvalues_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Log::keyvalues() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Log.keyvalues)
  return keyvalues_;
}

// -------------------------------------------------------------------

// Reference

// .lightstep.collector.Reference.Relationship relationship = 1;
inline void Reference::clear_relationship() {
  relationship_ = 0;
}
inline ::lightstep::collector::Reference_Relationship Reference::relationship() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Reference.relationship)
  return static_cast< ::lightstep::collector::Reference_Relationship >(relationship_);
}
inline void Reference::set_relationship(::lightstep::collector::Reference_Relationship value) {
  
  relationship_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Reference.relationship)
}

// .lightstep.collector.SpanContext span_context = 2;
inline bool Reference::has_span_context() const {
  return this != internal_default_instance() && span_context_ != NULL;
}
inline void Reference::clear_span_context() {
  if (GetArenaNoVirtual() == NULL && span_context_ != NULL) delete span_context_;
  span_context_ = NULL;
}
inline const ::lightstep::collector::SpanContext& Reference::span_context() const {
  const ::lightstep::collector::SpanContext* p = span_context_;
  // @@protoc_insertion_point(field_get:lightstep.collector.Reference.span_context)
  return p != NULL ? *p : *reinterpret_cast<const ::lightstep::collector::SpanContext*>(
      &::lightstep::collector::_SpanContext_default_instance_);
}
inline ::lightstep::collector::SpanContext* Reference::mutable_span_context() {
  
  if (span_context_ == NULL) {
    span_context_ = new ::lightstep::collector::SpanContext;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Reference.span_context)
  return span_context_;
}
inline ::lightstep::collector::SpanContext* Reference::release_span_context() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Reference.span_context)
  
  ::lightstep::collector::SpanContext* temp = span_context_;
  span_context_ = NULL;
  return temp;
}
inline void Reference::set_allocated_span_context(::lightstep::collector::SpanContext* span_context) {
  delete span_context_;
  span_context_ = span_context;
  if (span_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Reference.span_context)
}

// -------------------------------------------------------------------

// Span

// .lightstep.collector.SpanContext span_context = 1;
inline bool Span::has_span_context() const {
  return this != internal_default_instance() && span_context_ != NULL;
}
inline void Span::clear_span_context() {
  if (GetArenaNoVirtual() == NULL && span_context_ != NULL) delete span_context_;
  span_context_ = NULL;
}
inline const ::lightstep::collector::SpanContext& Span::span_context() const {
  const ::lightstep::collector::SpanContext* p = span_context_;
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.span_context)
  return p != NULL ? *p : *reinterpret_cast<const ::lightstep::collector::SpanContext*>(
      &::lightstep::collector::_SpanContext_default_instance_);
}
inline ::lightstep::collector::SpanContext* Span::mutable_span_context() {
  
  if (span_context_ == NULL) {
    span_context_ = new ::lightstep::collector::SpanContext;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.span_context)
  return span_context_;
}
inline ::lightstep::collector::SpanContext* Span::release_span_context() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.span_context)
  
  ::lightstep::collector::SpanContext* temp = span_context_;
  span_context_ = NULL;
  return temp;
}
inline void Span::set_allocated_span_context(::lightstep::collector::SpanContext* span_context) {
  delete span_context_;
  span_context_ = span_context;
  if (span_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.span_context)
}

// string operation_name = 2;
inline void Span::clear_operation_name() {
  operation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Span::operation_name() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.operation_name)
  return operation_name_.GetNoArena();
}
inline void Span::set_operation_name(const ::std::string& value) {
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.Span.operation_name)
}
#if LANG_CXX11
inline void Span::set_operation_name(::std::string&& value) {
  
  operation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.Span.operation_name)
}
#endif
inline void Span::set_operation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.Span.operation_name)
}
inline void Span::set_operation_name(const char* value, size_t size) {
  
  operation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.Span.operation_name)
}
inline ::std::string* Span::mutable_operation_name() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.operation_name)
  return operation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Span::release_operation_name() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.operation_name)
  
  return operation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Span::set_allocated_operation_name(::std::string* operation_name) {
  if (operation_name != NULL) {
    
  } else {
    
  }
  operation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation_name);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.operation_name)
}

// repeated .lightstep.collector.Reference references = 3;
inline int Span::references_size() const {
  return references_.size();
}
inline void Span::clear_references() {
  references_.Clear();
}
inline const ::lightstep::collector::Reference& Span::references(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.references)
  return references_.Get(index);
}
inline ::lightstep::collector::Reference* Span::mutable_references(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.references)
  return references_.Mutable(index);
}
inline ::lightstep::collector::Reference* Span::add_references() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.references)
  return references_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >*
Span::mutable_references() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.references)
  return &references_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Reference >&
Span::references() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.references)
  return references_;
}

// .google.protobuf.Timestamp start_timestamp = 4;
inline bool Span::has_start_timestamp() const {
  return this != internal_default_instance() && start_timestamp_ != NULL;
}
inline void Span::clear_start_timestamp() {
  if (GetArenaNoVirtual() == NULL && start_timestamp_ != NULL) delete start_timestamp_;
  start_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Span::start_timestamp() const {
  const ::google::protobuf::Timestamp* p = start_timestamp_;
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.start_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* Span::mutable_start_timestamp() {
  
  if (start_timestamp_ == NULL) {
    start_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.start_timestamp)
  return start_timestamp_;
}
inline ::google::protobuf::Timestamp* Span::release_start_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Span.start_timestamp)
  
  ::google::protobuf::Timestamp* temp = start_timestamp_;
  start_timestamp_ = NULL;
  return temp;
}
inline void Span::set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp) {
  delete start_timestamp_;
  if (start_timestamp != NULL && start_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_start_timestamp = new ::google::protobuf::Timestamp;
    new_start_timestamp->CopyFrom(*start_timestamp);
    start_timestamp = new_start_timestamp;
  }
  start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Span.start_timestamp)
}

// uint64 duration_micros = 5;
inline void Span::clear_duration_micros() {
  duration_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Span::duration_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.duration_micros)
  return duration_micros_;
}
inline void Span::set_duration_micros(::google::protobuf::uint64 value) {
  
  duration_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Span.duration_micros)
}

// repeated .lightstep.collector.KeyValue tags = 6;
inline int Span::tags_size() const {
  return tags_.size();
}
inline void Span::clear_tags() {
  tags_.Clear();
}
inline const ::lightstep::collector::KeyValue& Span::tags(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.tags)
  return tags_.Get(index);
}
inline ::lightstep::collector::KeyValue* Span::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.tags)
  return tags_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Span::add_tags() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Span::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Span::tags() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.tags)
  return tags_;
}

// repeated .lightstep.collector.Log logs = 7;
inline int Span::logs_size() const {
  return logs_.size();
}
inline void Span::clear_logs() {
  logs_.Clear();
}
inline const ::lightstep::collector::Log& Span::logs(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Span.logs)
  return logs_.Get(index);
}
inline ::lightstep::collector::Log* Span::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Span.logs)
  return logs_.Mutable(index);
}
inline ::lightstep::collector::Log* Span::add_logs() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Span.logs)
  return logs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
Span::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Span.logs)
  return &logs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
Span::logs() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Span.logs)
  return logs_;
}

// -------------------------------------------------------------------

// Reporter

// uint64 reporter_id = 1;
inline void Reporter::clear_reporter_id() {
  reporter_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Reporter::reporter_id() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Reporter.reporter_id)
  return reporter_id_;
}
inline void Reporter::set_reporter_id(::google::protobuf::uint64 value) {
  
  reporter_id_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Reporter.reporter_id)
}

// repeated .lightstep.collector.KeyValue tags = 4;
inline int Reporter::tags_size() const {
  return tags_.size();
}
inline void Reporter::clear_tags() {
  tags_.Clear();
}
inline const ::lightstep::collector::KeyValue& Reporter::tags(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Reporter.tags)
  return tags_.Get(index);
}
inline ::lightstep::collector::KeyValue* Reporter::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Reporter.tags)
  return tags_.Mutable(index);
}
inline ::lightstep::collector::KeyValue* Reporter::add_tags() {
  // @@protoc_insertion_point(field_add:lightstep.collector.Reporter.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >*
Reporter::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.Reporter.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::KeyValue >&
Reporter::tags() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.Reporter.tags)
  return tags_;
}

// -------------------------------------------------------------------

// MetricsSample

// string name = 1;
inline void MetricsSample::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MetricsSample::name() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.name)
  return name_.GetNoArena();
}
inline void MetricsSample::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.name)
}
#if LANG_CXX11
inline void MetricsSample::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.MetricsSample.name)
}
#endif
inline void MetricsSample::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.MetricsSample.name)
}
inline void MetricsSample::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.MetricsSample.name)
}
inline ::std::string* MetricsSample::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.MetricsSample.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetricsSample::release_name() {
  // @@protoc_insertion_point(field_release:lightstep.collector.MetricsSample.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetricsSample::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.MetricsSample.name)
}

// int64 int_value = 2;
inline bool MetricsSample::has_int_value() const {
  return value_case() == kIntValue;
}
inline void MetricsSample::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void MetricsSample::clear_int_value() {
  if (has_int_value()) {
    value_.int_value_ = GOOGLE_LONGLONG(0);
    clear_has_value();
  }
}
inline ::google::protobuf::int64 MetricsSample::int_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.int_value)
  if (has_int_value()) {
    return value_.int_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void MetricsSample::set_int_value(::google::protobuf::int64 value) {
  if (!has_int_value()) {
    clear_value();
    set_has_int_value();
  }
  value_.int_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.int_value)
}

// double double_value = 3;
inline bool MetricsSample::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void MetricsSample::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void MetricsSample::clear_double_value() {
  if (has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double MetricsSample::double_value() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.MetricsSample.double_value)
  if (has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void MetricsSample::set_double_value(double value) {
  if (!has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.MetricsSample.double_value)
}

inline bool MetricsSample::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void MetricsSample::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline MetricsSample::ValueCase MetricsSample::value_case() const {
  return MetricsSample::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InternalMetrics

// .google.protobuf.Timestamp start_timestamp = 1;
inline bool InternalMetrics::has_start_timestamp() const {
  return this != internal_default_instance() && start_timestamp_ != NULL;
}
inline void InternalMetrics::clear_start_timestamp() {
  if (GetArenaNoVirtual() == NULL && start_timestamp_ != NULL) delete start_timestamp_;
  start_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& InternalMetrics::start_timestamp() const {
  const ::google::protobuf::Timestamp* p = start_timestamp_;
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.start_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* InternalMetrics::mutable_start_timestamp() {
  
  if (start_timestamp_ == NULL) {
    start_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.start_timestamp)
  return start_timestamp_;
}
inline ::google::protobuf::Timestamp* InternalMetrics::release_start_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.InternalMetrics.start_timestamp)
  
  ::google::protobuf::Timestamp* temp = start_timestamp_;
  start_timestamp_ = NULL;
  return temp;
}
inline void InternalMetrics::set_allocated_start_timestamp(::google::protobuf::Timestamp* start_timestamp) {
  delete start_timestamp_;
  if (start_timestamp != NULL && start_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_start_timestamp = new ::google::protobuf::Timestamp;
    new_start_timestamp->CopyFrom(*start_timestamp);
    start_timestamp = new_start_timestamp;
  }
  start_timestamp_ = start_timestamp;
  if (start_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.InternalMetrics.start_timestamp)
}

// uint64 duration_micros = 2;
inline void InternalMetrics::clear_duration_micros() {
  duration_micros_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 InternalMetrics::duration_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.duration_micros)
  return duration_micros_;
}
inline void InternalMetrics::set_duration_micros(::google::protobuf::uint64 value) {
  
  duration_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.InternalMetrics.duration_micros)
}

// repeated .lightstep.collector.Log logs = 3;
inline int InternalMetrics::logs_size() const {
  return logs_.size();
}
inline void InternalMetrics::clear_logs() {
  logs_.Clear();
}
inline const ::lightstep::collector::Log& InternalMetrics::logs(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.logs)
  return logs_.Get(index);
}
inline ::lightstep::collector::Log* InternalMetrics::mutable_logs(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.logs)
  return logs_.Mutable(index);
}
inline ::lightstep::collector::Log* InternalMetrics::add_logs() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.logs)
  return logs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >*
InternalMetrics::mutable_logs() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.logs)
  return &logs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Log >&
InternalMetrics::logs() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.logs)
  return logs_;
}

// repeated .lightstep.collector.MetricsSample counts = 4;
inline int InternalMetrics::counts_size() const {
  return counts_.size();
}
inline void InternalMetrics::clear_counts() {
  counts_.Clear();
}
inline const ::lightstep::collector::MetricsSample& InternalMetrics::counts(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.counts)
  return counts_.Get(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::mutable_counts(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.counts)
  return counts_.Mutable(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::add_counts() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.counts)
  return counts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
InternalMetrics::mutable_counts() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.counts)
  return &counts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
InternalMetrics::counts() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.counts)
  return counts_;
}

// repeated .lightstep.collector.MetricsSample gauges = 5;
inline int InternalMetrics::gauges_size() const {
  return gauges_.size();
}
inline void InternalMetrics::clear_gauges() {
  gauges_.Clear();
}
inline const ::lightstep::collector::MetricsSample& InternalMetrics::gauges(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Get(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::mutable_gauges(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Mutable(index);
}
inline ::lightstep::collector::MetricsSample* InternalMetrics::add_gauges() {
  // @@protoc_insertion_point(field_add:lightstep.collector.InternalMetrics.gauges)
  return gauges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >*
InternalMetrics::mutable_gauges() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.InternalMetrics.gauges)
  return &gauges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::MetricsSample >&
InternalMetrics::gauges() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.InternalMetrics.gauges)
  return gauges_;
}

// -------------------------------------------------------------------

// Auth

// string access_token = 1;
inline void Auth::clear_access_token() {
  access_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::access_token() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Auth.access_token)
  return access_token_.GetNoArena();
}
inline void Auth::set_access_token(const ::std::string& value) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:lightstep.collector.Auth.access_token)
}
#if LANG_CXX11
inline void Auth::set_access_token(::std::string&& value) {
  
  access_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:lightstep.collector.Auth.access_token)
}
#endif
inline void Auth::set_access_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:lightstep.collector.Auth.access_token)
}
inline void Auth::set_access_token(const char* value, size_t size) {
  
  access_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.Auth.access_token)
}
inline ::std::string* Auth::mutable_access_token() {
  
  // @@protoc_insertion_point(field_mutable:lightstep.collector.Auth.access_token)
  return access_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_access_token() {
  // @@protoc_insertion_point(field_release:lightstep.collector.Auth.access_token)
  
  return access_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_access_token(::std::string* access_token) {
  if (access_token != NULL) {
    
  } else {
    
  }
  access_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_token);
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.Auth.access_token)
}

// -------------------------------------------------------------------

// ReportRequest

// .lightstep.collector.Reporter reporter = 1;
inline bool ReportRequest::has_reporter() const {
  return this != internal_default_instance() && reporter_ != NULL;
}
inline void ReportRequest::clear_reporter() {
  if (GetArenaNoVirtual() == NULL && reporter_ != NULL) delete reporter_;
  reporter_ = NULL;
}
inline const ::lightstep::collector::Reporter& ReportRequest::reporter() const {
  const ::lightstep::collector::Reporter* p = reporter_;
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.reporter)
  return p != NULL ? *p : *reinterpret_cast<const ::lightstep::collector::Reporter*>(
      &::lightstep::collector::_Reporter_default_instance_);
}
inline ::lightstep::collector::Reporter* ReportRequest::mutable_reporter() {
  
  if (reporter_ == NULL) {
    reporter_ = new ::lightstep::collector::Reporter;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.reporter)
  return reporter_;
}
inline ::lightstep::collector::Reporter* ReportRequest::release_reporter() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.reporter)
  
  ::lightstep::collector::Reporter* temp = reporter_;
  reporter_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_reporter(::lightstep::collector::Reporter* reporter) {
  delete reporter_;
  reporter_ = reporter;
  if (reporter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.reporter)
}

// .lightstep.collector.Auth auth = 2;
inline bool ReportRequest::has_auth() const {
  return this != internal_default_instance() && auth_ != NULL;
}
inline void ReportRequest::clear_auth() {
  if (GetArenaNoVirtual() == NULL && auth_ != NULL) delete auth_;
  auth_ = NULL;
}
inline const ::lightstep::collector::Auth& ReportRequest::auth() const {
  const ::lightstep::collector::Auth* p = auth_;
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.auth)
  return p != NULL ? *p : *reinterpret_cast<const ::lightstep::collector::Auth*>(
      &::lightstep::collector::_Auth_default_instance_);
}
inline ::lightstep::collector::Auth* ReportRequest::mutable_auth() {
  
  if (auth_ == NULL) {
    auth_ = new ::lightstep::collector::Auth;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.auth)
  return auth_;
}
inline ::lightstep::collector::Auth* ReportRequest::release_auth() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.auth)
  
  ::lightstep::collector::Auth* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_auth(::lightstep::collector::Auth* auth) {
  delete auth_;
  auth_ = auth;
  if (auth) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.auth)
}

// repeated .lightstep.collector.Span spans = 3;
inline int ReportRequest::spans_size() const {
  return spans_.size();
}
inline void ReportRequest::clear_spans() {
  spans_.Clear();
}
inline const ::lightstep::collector::Span& ReportRequest::spans(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.spans)
  return spans_.Get(index);
}
inline ::lightstep::collector::Span* ReportRequest::mutable_spans(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.spans)
  return spans_.Mutable(index);
}
inline ::lightstep::collector::Span* ReportRequest::add_spans() {
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportRequest.spans)
  return spans_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >*
ReportRequest::mutable_spans() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportRequest.spans)
  return &spans_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Span >&
ReportRequest::spans() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportRequest.spans)
  return spans_;
}

// uint32 timestamp_offset_micros = 5;
inline void ReportRequest::clear_timestamp_offset_micros() {
  timestamp_offset_micros_ = 0u;
}
inline ::google::protobuf::uint32 ReportRequest::timestamp_offset_micros() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.timestamp_offset_micros)
  return timestamp_offset_micros_;
}
inline void ReportRequest::set_timestamp_offset_micros(::google::protobuf::uint32 value) {
  
  timestamp_offset_micros_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.ReportRequest.timestamp_offset_micros)
}

// .lightstep.collector.InternalMetrics internal_metrics = 6;
inline bool ReportRequest::has_internal_metrics() const {
  return this != internal_default_instance() && internal_metrics_ != NULL;
}
inline void ReportRequest::clear_internal_metrics() {
  if (GetArenaNoVirtual() == NULL && internal_metrics_ != NULL) delete internal_metrics_;
  internal_metrics_ = NULL;
}
inline const ::lightstep::collector::InternalMetrics& ReportRequest::internal_metrics() const {
  const ::lightstep::collector::InternalMetrics* p = internal_metrics_;
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportRequest.internal_metrics)
  return p != NULL ? *p : *reinterpret_cast<const ::lightstep::collector::InternalMetrics*>(
      &::lightstep::collector::_InternalMetrics_default_instance_);
}
inline ::lightstep::collector::InternalMetrics* ReportRequest::mutable_internal_metrics() {
  
  if (internal_metrics_ == NULL) {
    internal_metrics_ = new ::lightstep::collector::InternalMetrics;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportRequest.internal_metrics)
  return internal_metrics_;
}
inline ::lightstep::collector::InternalMetrics* ReportRequest::release_internal_metrics() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportRequest.internal_metrics)
  
  ::lightstep::collector::InternalMetrics* temp = internal_metrics_;
  internal_metrics_ = NULL;
  return temp;
}
inline void ReportRequest::set_allocated_internal_metrics(::lightstep::collector::InternalMetrics* internal_metrics) {
  delete internal_metrics_;
  internal_metrics_ = internal_metrics;
  if (internal_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportRequest.internal_metrics)
}

// -------------------------------------------------------------------

// Command

// bool disable = 1;
inline void Command::clear_disable() {
  disable_ = false;
}
inline bool Command::disable() const {
  // @@protoc_insertion_point(field_get:lightstep.collector.Command.disable)
  return disable_;
}
inline void Command::set_disable(bool value) {
  
  disable_ = value;
  // @@protoc_insertion_point(field_set:lightstep.collector.Command.disable)
}

// -------------------------------------------------------------------

// ReportResponse

// repeated .lightstep.collector.Command commands = 1;
inline int ReportResponse::commands_size() const {
  return commands_.size();
}
inline void ReportResponse::clear_commands() {
  commands_.Clear();
}
inline const ::lightstep::collector::Command& ReportResponse::commands(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.commands)
  return commands_.Get(index);
}
inline ::lightstep::collector::Command* ReportResponse::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.commands)
  return commands_.Mutable(index);
}
inline ::lightstep::collector::Command* ReportResponse::add_commands() {
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportResponse.commands)
  return commands_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >*
ReportResponse::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportResponse.commands)
  return &commands_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lightstep::collector::Command >&
ReportResponse::commands() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportResponse.commands)
  return commands_;
}

// .google.protobuf.Timestamp receive_timestamp = 2;
inline bool ReportResponse::has_receive_timestamp() const {
  return this != internal_default_instance() && receive_timestamp_ != NULL;
}
inline void ReportResponse::clear_receive_timestamp() {
  if (GetArenaNoVirtual() == NULL && receive_timestamp_ != NULL) delete receive_timestamp_;
  receive_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& ReportResponse::receive_timestamp() const {
  const ::google::protobuf::Timestamp* p = receive_timestamp_;
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.receive_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ReportResponse::mutable_receive_timestamp() {
  
  if (receive_timestamp_ == NULL) {
    receive_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.receive_timestamp)
  return receive_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::release_receive_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportResponse.receive_timestamp)
  
  ::google::protobuf::Timestamp* temp = receive_timestamp_;
  receive_timestamp_ = NULL;
  return temp;
}
inline void ReportResponse::set_allocated_receive_timestamp(::google::protobuf::Timestamp* receive_timestamp) {
  delete receive_timestamp_;
  if (receive_timestamp != NULL && receive_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_receive_timestamp = new ::google::protobuf::Timestamp;
    new_receive_timestamp->CopyFrom(*receive_timestamp);
    receive_timestamp = new_receive_timestamp;
  }
  receive_timestamp_ = receive_timestamp;
  if (receive_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportResponse.receive_timestamp)
}

// .google.protobuf.Timestamp transmit_timestamp = 3;
inline bool ReportResponse::has_transmit_timestamp() const {
  return this != internal_default_instance() && transmit_timestamp_ != NULL;
}
inline void ReportResponse::clear_transmit_timestamp() {
  if (GetArenaNoVirtual() == NULL && transmit_timestamp_ != NULL) delete transmit_timestamp_;
  transmit_timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& ReportResponse::transmit_timestamp() const {
  const ::google::protobuf::Timestamp* p = transmit_timestamp_;
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.transmit_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Timestamp*>(
      &::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* ReportResponse::mutable_transmit_timestamp() {
  
  if (transmit_timestamp_ == NULL) {
    transmit_timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.transmit_timestamp)
  return transmit_timestamp_;
}
inline ::google::protobuf::Timestamp* ReportResponse::release_transmit_timestamp() {
  // @@protoc_insertion_point(field_release:lightstep.collector.ReportResponse.transmit_timestamp)
  
  ::google::protobuf::Timestamp* temp = transmit_timestamp_;
  transmit_timestamp_ = NULL;
  return temp;
}
inline void ReportResponse::set_allocated_transmit_timestamp(::google::protobuf::Timestamp* transmit_timestamp) {
  delete transmit_timestamp_;
  if (transmit_timestamp != NULL && transmit_timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_transmit_timestamp = new ::google::protobuf::Timestamp;
    new_transmit_timestamp->CopyFrom(*transmit_timestamp);
    transmit_timestamp = new_transmit_timestamp;
  }
  transmit_timestamp_ = transmit_timestamp;
  if (transmit_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:lightstep.collector.ReportResponse.transmit_timestamp)
}

// repeated string errors = 4;
inline int ReportResponse::errors_size() const {
  return errors_.size();
}
inline void ReportResponse::clear_errors() {
  errors_.Clear();
}
inline const ::std::string& ReportResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:lightstep.collector.ReportResponse.errors)
  return errors_.Get(index);
}
inline ::std::string* ReportResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:lightstep.collector.ReportResponse.errors)
  return errors_.Mutable(index);
}
inline void ReportResponse::set_errors(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.ReportResponse.errors)
  errors_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ReportResponse::set_errors(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:lightstep.collector.ReportResponse.errors)
  errors_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ReportResponse::set_errors(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:lightstep.collector.ReportResponse.errors)
}
inline void ReportResponse::set_errors(int index, const char* value, size_t size) {
  errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:lightstep.collector.ReportResponse.errors)
}
inline ::std::string* ReportResponse::add_errors() {
  // @@protoc_insertion_point(field_add_mutable:lightstep.collector.ReportResponse.errors)
  return errors_.Add();
}
inline void ReportResponse::add_errors(const ::std::string& value) {
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportResponse.errors)
}
#if LANG_CXX11
inline void ReportResponse::add_errors(::std::string&& value) {
  errors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:lightstep.collector.ReportResponse.errors)
}
#endif
inline void ReportResponse::add_errors(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:lightstep.collector.ReportResponse.errors)
}
inline void ReportResponse::add_errors(const char* value, size_t size) {
  errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:lightstep.collector.ReportResponse.errors)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ReportResponse::errors() const {
  // @@protoc_insertion_point(field_list:lightstep.collector.ReportResponse.errors)
  return errors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ReportResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:lightstep.collector.ReportResponse.errors)
  return &errors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace collector
}  // namespace lightstep

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lightstep::collector::Reference_Relationship> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lightstep::collector::Reference_Relationship>() {
  return ::lightstep::collector::Reference_Relationship_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_collector_2eproto__INCLUDED
