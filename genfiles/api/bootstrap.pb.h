// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/bootstrap.proto

#ifndef PROTOBUF_api_2fbootstrap_2eproto__INCLUDED
#define PROTOBUF_api_2fbootstrap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "api/address.pb.h"
#include "api/base.pb.h"
#include "api/discovery.pb.h"
#include "api/cds.pb.h"
#include "api/lds.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
namespace envoy {
namespace api {
namespace v2 {
class Admin;
class AdminDefaultTypeInternal;
extern AdminDefaultTypeInternal _Admin_default_instance_;
class Bootstrap;
class BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Bootstrap_DynamicResources;
class Bootstrap_DynamicResourcesDefaultTypeInternal;
extern Bootstrap_DynamicResourcesDefaultTypeInternal _Bootstrap_DynamicResources_default_instance_;
class Bootstrap_DynamicResources_DeprecatedV1;
class Bootstrap_DynamicResources_DeprecatedV1DefaultTypeInternal;
extern Bootstrap_DynamicResources_DeprecatedV1DefaultTypeInternal _Bootstrap_DynamicResources_DeprecatedV1_default_instance_;
class Bootstrap_StaticResources;
class Bootstrap_StaticResourcesDefaultTypeInternal;
extern Bootstrap_StaticResourcesDefaultTypeInternal _Bootstrap_StaticResources_default_instance_;
class ClusterManager;
class ClusterManagerDefaultTypeInternal;
extern ClusterManagerDefaultTypeInternal _ClusterManager_default_instance_;
class ClusterManager_OutlierDetection;
class ClusterManager_OutlierDetectionDefaultTypeInternal;
extern ClusterManager_OutlierDetectionDefaultTypeInternal _ClusterManager_OutlierDetection_default_instance_;
class LightstepConfig;
class LightstepConfigDefaultTypeInternal;
extern LightstepConfigDefaultTypeInternal _LightstepConfig_default_instance_;
class RateLimitServiceConfig;
class RateLimitServiceConfigDefaultTypeInternal;
extern RateLimitServiceConfigDefaultTypeInternal _RateLimitServiceConfig_default_instance_;
class Runtime;
class RuntimeDefaultTypeInternal;
extern RuntimeDefaultTypeInternal _Runtime_default_instance_;
class StatsSink;
class StatsSinkDefaultTypeInternal;
extern StatsSinkDefaultTypeInternal _StatsSink_default_instance_;
class StatsdSink;
class StatsdSinkDefaultTypeInternal;
extern StatsdSinkDefaultTypeInternal _StatsdSink_default_instance_;
class Tracing;
class TracingDefaultTypeInternal;
extern TracingDefaultTypeInternal _Tracing_default_instance_;
class Tracing_Http;
class Tracing_HttpDefaultTypeInternal;
extern Tracing_HttpDefaultTypeInternal _Tracing_Http_default_instance_;
class Watchdog;
class WatchdogDefaultTypeInternal;
extern WatchdogDefaultTypeInternal _Watchdog_default_instance_;
class ZipkinConfig;
class ZipkinConfigDefaultTypeInternal;
extern ZipkinConfigDefaultTypeInternal _ZipkinConfig_default_instance_;
}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace envoy {
namespace api {
namespace v2 {

namespace protobuf_api_2fbootstrap_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_api_2fbootstrap_2eproto

// ===================================================================

class LightstepConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.LightstepConfig) */ {
 public:
  LightstepConfig();
  virtual ~LightstepConfig();

  LightstepConfig(const LightstepConfig& from);

  inline LightstepConfig& operator=(const LightstepConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LightstepConfig(LightstepConfig&& from) noexcept
    : LightstepConfig() {
    *this = ::std::move(from);
  }

  inline LightstepConfig& operator=(LightstepConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LightstepConfig& default_instance();

  static inline const LightstepConfig* internal_default_instance() {
    return reinterpret_cast<const LightstepConfig*>(
               &_LightstepConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(LightstepConfig* other);
  friend void swap(LightstepConfig& a, LightstepConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LightstepConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  LightstepConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LightstepConfig& from);
  void MergeFrom(const LightstepConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LightstepConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collector_cluster = 1;
  void clear_collector_cluster();
  static const int kCollectorClusterFieldNumber = 1;
  const ::std::string& collector_cluster() const;
  void set_collector_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_collector_cluster(::std::string&& value);
  #endif
  void set_collector_cluster(const char* value);
  void set_collector_cluster(const char* value, size_t size);
  ::std::string* mutable_collector_cluster();
  ::std::string* release_collector_cluster();
  void set_allocated_collector_cluster(::std::string* collector_cluster);

  // string access_token_file = 2;
  void clear_access_token_file();
  static const int kAccessTokenFileFieldNumber = 2;
  const ::std::string& access_token_file() const;
  void set_access_token_file(const ::std::string& value);
  #if LANG_CXX11
  void set_access_token_file(::std::string&& value);
  #endif
  void set_access_token_file(const char* value);
  void set_access_token_file(const char* value, size_t size);
  ::std::string* mutable_access_token_file();
  ::std::string* release_access_token_file();
  void set_allocated_access_token_file(::std::string* access_token_file);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.LightstepConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collector_cluster_;
  ::google::protobuf::internal::ArenaStringPtr access_token_file_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ZipkinConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.ZipkinConfig) */ {
 public:
  ZipkinConfig();
  virtual ~ZipkinConfig();

  ZipkinConfig(const ZipkinConfig& from);

  inline ZipkinConfig& operator=(const ZipkinConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ZipkinConfig(ZipkinConfig&& from) noexcept
    : ZipkinConfig() {
    *this = ::std::move(from);
  }

  inline ZipkinConfig& operator=(ZipkinConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ZipkinConfig& default_instance();

  static inline const ZipkinConfig* internal_default_instance() {
    return reinterpret_cast<const ZipkinConfig*>(
               &_ZipkinConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ZipkinConfig* other);
  friend void swap(ZipkinConfig& a, ZipkinConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ZipkinConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  ZipkinConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ZipkinConfig& from);
  void MergeFrom(const ZipkinConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ZipkinConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string collector_cluster = 1;
  void clear_collector_cluster();
  static const int kCollectorClusterFieldNumber = 1;
  const ::std::string& collector_cluster() const;
  void set_collector_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_collector_cluster(::std::string&& value);
  #endif
  void set_collector_cluster(const char* value);
  void set_collector_cluster(const char* value, size_t size);
  ::std::string* mutable_collector_cluster();
  ::std::string* release_collector_cluster();
  void set_allocated_collector_cluster(::std::string* collector_cluster);

  // string collector_endpoint = 2;
  void clear_collector_endpoint();
  static const int kCollectorEndpointFieldNumber = 2;
  const ::std::string& collector_endpoint() const;
  void set_collector_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_collector_endpoint(::std::string&& value);
  #endif
  void set_collector_endpoint(const char* value);
  void set_collector_endpoint(const char* value, size_t size);
  ::std::string* mutable_collector_endpoint();
  ::std::string* release_collector_endpoint();
  void set_allocated_collector_endpoint(::std::string* collector_endpoint);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.ZipkinConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr collector_cluster_;
  ::google::protobuf::internal::ArenaStringPtr collector_endpoint_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tracing_Http : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Tracing.Http) */ {
 public:
  Tracing_Http();
  virtual ~Tracing_Http();

  Tracing_Http(const Tracing_Http& from);

  inline Tracing_Http& operator=(const Tracing_Http& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tracing_Http(Tracing_Http&& from) noexcept
    : Tracing_Http() {
    *this = ::std::move(from);
  }

  inline Tracing_Http& operator=(Tracing_Http&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tracing_Http& default_instance();

  static inline const Tracing_Http* internal_default_instance() {
    return reinterpret_cast<const Tracing_Http*>(
               &_Tracing_Http_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Tracing_Http* other);
  friend void swap(Tracing_Http& a, Tracing_Http& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tracing_Http* New() const PROTOBUF_FINAL { return New(NULL); }

  Tracing_Http* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tracing_Http& from);
  void MergeFrom(const Tracing_Http& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tracing_Http* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.Struct config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::google::protobuf::Struct& config() const;
  ::google::protobuf::Struct* mutable_config();
  ::google::protobuf::Struct* release_config();
  void set_allocated_config(::google::protobuf::Struct* config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Tracing.Http)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::Struct* config_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Tracing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Tracing) */ {
 public:
  Tracing();
  virtual ~Tracing();

  Tracing(const Tracing& from);

  inline Tracing& operator=(const Tracing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tracing(Tracing&& from) noexcept
    : Tracing() {
    *this = ::std::move(from);
  }

  inline Tracing& operator=(Tracing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tracing& default_instance();

  static inline const Tracing* internal_default_instance() {
    return reinterpret_cast<const Tracing*>(
               &_Tracing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Tracing* other);
  friend void swap(Tracing& a, Tracing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tracing* New() const PROTOBUF_FINAL { return New(NULL); }

  Tracing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tracing& from);
  void MergeFrom(const Tracing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tracing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Tracing_Http Http;

  // accessors -------------------------------------------------------

  // .envoy.api.v2.Tracing.Http http = 1;
  bool has_http() const;
  void clear_http();
  static const int kHttpFieldNumber = 1;
  const ::envoy::api::v2::Tracing_Http& http() const;
  ::envoy::api::v2::Tracing_Http* mutable_http();
  ::envoy::api::v2::Tracing_Http* release_http();
  void set_allocated_http(::envoy::api::v2::Tracing_Http* http);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Tracing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::Tracing_Http* http_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Admin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Admin) */ {
 public:
  Admin();
  virtual ~Admin();

  Admin(const Admin& from);

  inline Admin& operator=(const Admin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Admin(Admin&& from) noexcept
    : Admin() {
    *this = ::std::move(from);
  }

  inline Admin& operator=(Admin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Admin& default_instance();

  static inline const Admin* internal_default_instance() {
    return reinterpret_cast<const Admin*>(
               &_Admin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Admin* other);
  friend void swap(Admin& a, Admin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Admin* New() const PROTOBUF_FINAL { return New(NULL); }

  Admin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Admin& from);
  void MergeFrom(const Admin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Admin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string access_log_path = 1;
  void clear_access_log_path();
  static const int kAccessLogPathFieldNumber = 1;
  const ::std::string& access_log_path() const;
  void set_access_log_path(const ::std::string& value);
  #if LANG_CXX11
  void set_access_log_path(::std::string&& value);
  #endif
  void set_access_log_path(const char* value);
  void set_access_log_path(const char* value, size_t size);
  ::std::string* mutable_access_log_path();
  ::std::string* release_access_log_path();
  void set_allocated_access_log_path(::std::string* access_log_path);

  // string profile_path = 2;
  void clear_profile_path();
  static const int kProfilePathFieldNumber = 2;
  const ::std::string& profile_path() const;
  void set_profile_path(const ::std::string& value);
  #if LANG_CXX11
  void set_profile_path(::std::string&& value);
  #endif
  void set_profile_path(const char* value);
  void set_profile_path(const char* value, size_t size);
  ::std::string* mutable_profile_path();
  ::std::string* release_profile_path();
  void set_allocated_profile_path(::std::string* profile_path);

  // .envoy.api.v2.Address address = 3;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  const ::envoy::api::v2::Address& address() const;
  ::envoy::api::v2::Address* mutable_address();
  ::envoy::api::v2::Address* release_address();
  void set_allocated_address(::envoy::api::v2::Address* address);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Admin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr access_log_path_;
  ::google::protobuf::internal::ArenaStringPtr profile_path_;
  ::envoy::api::v2::Address* address_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterManager_OutlierDetection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.ClusterManager.OutlierDetection) */ {
 public:
  ClusterManager_OutlierDetection();
  virtual ~ClusterManager_OutlierDetection();

  ClusterManager_OutlierDetection(const ClusterManager_OutlierDetection& from);

  inline ClusterManager_OutlierDetection& operator=(const ClusterManager_OutlierDetection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterManager_OutlierDetection(ClusterManager_OutlierDetection&& from) noexcept
    : ClusterManager_OutlierDetection() {
    *this = ::std::move(from);
  }

  inline ClusterManager_OutlierDetection& operator=(ClusterManager_OutlierDetection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterManager_OutlierDetection& default_instance();

  static inline const ClusterManager_OutlierDetection* internal_default_instance() {
    return reinterpret_cast<const ClusterManager_OutlierDetection*>(
               &_ClusterManager_OutlierDetection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ClusterManager_OutlierDetection* other);
  friend void swap(ClusterManager_OutlierDetection& a, ClusterManager_OutlierDetection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterManager_OutlierDetection* New() const PROTOBUF_FINAL { return New(NULL); }

  ClusterManager_OutlierDetection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClusterManager_OutlierDetection& from);
  void MergeFrom(const ClusterManager_OutlierDetection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClusterManager_OutlierDetection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string event_log_path = 1;
  void clear_event_log_path();
  static const int kEventLogPathFieldNumber = 1;
  const ::std::string& event_log_path() const;
  void set_event_log_path(const ::std::string& value);
  #if LANG_CXX11
  void set_event_log_path(::std::string&& value);
  #endif
  void set_event_log_path(const char* value);
  void set_event_log_path(const char* value, size_t size);
  ::std::string* mutable_event_log_path();
  ::std::string* release_event_log_path();
  void set_allocated_event_log_path(::std::string* event_log_path);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.ClusterManager.OutlierDetection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr event_log_path_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClusterManager : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.ClusterManager) */ {
 public:
  ClusterManager();
  virtual ~ClusterManager();

  ClusterManager(const ClusterManager& from);

  inline ClusterManager& operator=(const ClusterManager& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClusterManager(ClusterManager&& from) noexcept
    : ClusterManager() {
    *this = ::std::move(from);
  }

  inline ClusterManager& operator=(ClusterManager&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClusterManager& default_instance();

  static inline const ClusterManager* internal_default_instance() {
    return reinterpret_cast<const ClusterManager*>(
               &_ClusterManager_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ClusterManager* other);
  friend void swap(ClusterManager& a, ClusterManager& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClusterManager* New() const PROTOBUF_FINAL { return New(NULL); }

  ClusterManager* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClusterManager& from);
  void MergeFrom(const ClusterManager& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClusterManager* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ClusterManager_OutlierDetection OutlierDetection;

  // accessors -------------------------------------------------------

  // string local_cluster_name = 1;
  void clear_local_cluster_name();
  static const int kLocalClusterNameFieldNumber = 1;
  const ::std::string& local_cluster_name() const;
  void set_local_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_local_cluster_name(::std::string&& value);
  #endif
  void set_local_cluster_name(const char* value);
  void set_local_cluster_name(const char* value, size_t size);
  ::std::string* mutable_local_cluster_name();
  ::std::string* release_local_cluster_name();
  void set_allocated_local_cluster_name(::std::string* local_cluster_name);

  // .envoy.api.v2.ClusterManager.OutlierDetection outlier_detection = 2;
  bool has_outlier_detection() const;
  void clear_outlier_detection();
  static const int kOutlierDetectionFieldNumber = 2;
  const ::envoy::api::v2::ClusterManager_OutlierDetection& outlier_detection() const;
  ::envoy::api::v2::ClusterManager_OutlierDetection* mutable_outlier_detection();
  ::envoy::api::v2::ClusterManager_OutlierDetection* release_outlier_detection();
  void set_allocated_outlier_detection(::envoy::api::v2::ClusterManager_OutlierDetection* outlier_detection);

  // .envoy.api.v2.BindConfig upstream_bind_config = 3;
  bool has_upstream_bind_config() const;
  void clear_upstream_bind_config();
  static const int kUpstreamBindConfigFieldNumber = 3;
  const ::envoy::api::v2::BindConfig& upstream_bind_config() const;
  ::envoy::api::v2::BindConfig* mutable_upstream_bind_config();
  ::envoy::api::v2::BindConfig* release_upstream_bind_config();
  void set_allocated_upstream_bind_config(::envoy::api::v2::BindConfig* upstream_bind_config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.ClusterManager)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr local_cluster_name_;
  ::envoy::api::v2::ClusterManager_OutlierDetection* outlier_detection_;
  ::envoy::api::v2::BindConfig* upstream_bind_config_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatsdSink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.StatsdSink) */ {
 public:
  StatsdSink();
  virtual ~StatsdSink();

  StatsdSink(const StatsdSink& from);

  inline StatsdSink& operator=(const StatsdSink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatsdSink(StatsdSink&& from) noexcept
    : StatsdSink() {
    *this = ::std::move(from);
  }

  inline StatsdSink& operator=(StatsdSink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatsdSink& default_instance();

  enum StatsdSpecifierCase {
    kAddress = 1,
    kTcpClusterName = 2,
    STATSD_SPECIFIER_NOT_SET = 0,
  };

  static inline const StatsdSink* internal_default_instance() {
    return reinterpret_cast<const StatsdSink*>(
               &_StatsdSink_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(StatsdSink* other);
  friend void swap(StatsdSink& a, StatsdSink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatsdSink* New() const PROTOBUF_FINAL { return New(NULL); }

  StatsdSink* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatsdSink& from);
  void MergeFrom(const StatsdSink& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatsdSink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.Address address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::envoy::api::v2::Address& address() const;
  ::envoy::api::v2::Address* mutable_address();
  ::envoy::api::v2::Address* release_address();
  void set_allocated_address(::envoy::api::v2::Address* address);

  // string tcp_cluster_name = 2;
  private:
  bool has_tcp_cluster_name() const;
  public:
  void clear_tcp_cluster_name();
  static const int kTcpClusterNameFieldNumber = 2;
  const ::std::string& tcp_cluster_name() const;
  void set_tcp_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tcp_cluster_name(::std::string&& value);
  #endif
  void set_tcp_cluster_name(const char* value);
  void set_tcp_cluster_name(const char* value, size_t size);
  ::std::string* mutable_tcp_cluster_name();
  ::std::string* release_tcp_cluster_name();
  void set_allocated_tcp_cluster_name(::std::string* tcp_cluster_name);

  StatsdSpecifierCase statsd_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.StatsdSink)
 private:
  void set_has_address();
  void set_has_tcp_cluster_name();

  inline bool has_statsd_specifier() const;
  void clear_statsd_specifier();
  inline void clear_has_statsd_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union StatsdSpecifierUnion {
    StatsdSpecifierUnion() {}
    ::envoy::api::v2::Address* address_;
    ::google::protobuf::internal::ArenaStringPtr tcp_cluster_name_;
  } statsd_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatsSink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.StatsSink) */ {
 public:
  StatsSink();
  virtual ~StatsSink();

  StatsSink(const StatsSink& from);

  inline StatsSink& operator=(const StatsSink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatsSink(StatsSink&& from) noexcept
    : StatsSink() {
    *this = ::std::move(from);
  }

  inline StatsSink& operator=(StatsSink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatsSink& default_instance();

  static inline const StatsSink* internal_default_instance() {
    return reinterpret_cast<const StatsSink*>(
               &_StatsSink_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StatsSink* other);
  friend void swap(StatsSink& a, StatsSink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatsSink* New() const PROTOBUF_FINAL { return New(NULL); }

  StatsSink* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatsSink& from);
  void MergeFrom(const StatsSink& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatsSink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.Struct config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::google::protobuf::Struct& config() const;
  ::google::protobuf::Struct* mutable_config();
  ::google::protobuf::Struct* release_config();
  void set_allocated_config(::google::protobuf::Struct* config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.StatsSink)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::Struct* config_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Watchdog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Watchdog) */ {
 public:
  Watchdog();
  virtual ~Watchdog();

  Watchdog(const Watchdog& from);

  inline Watchdog& operator=(const Watchdog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Watchdog(Watchdog&& from) noexcept
    : Watchdog() {
    *this = ::std::move(from);
  }

  inline Watchdog& operator=(Watchdog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Watchdog& default_instance();

  static inline const Watchdog* internal_default_instance() {
    return reinterpret_cast<const Watchdog*>(
               &_Watchdog_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Watchdog* other);
  friend void swap(Watchdog& a, Watchdog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Watchdog* New() const PROTOBUF_FINAL { return New(NULL); }

  Watchdog* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Watchdog& from);
  void MergeFrom(const Watchdog& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Watchdog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Duration miss_timeout = 1;
  bool has_miss_timeout() const;
  void clear_miss_timeout();
  static const int kMissTimeoutFieldNumber = 1;
  const ::google::protobuf::Duration& miss_timeout() const;
  ::google::protobuf::Duration* mutable_miss_timeout();
  ::google::protobuf::Duration* release_miss_timeout();
  void set_allocated_miss_timeout(::google::protobuf::Duration* miss_timeout);

  // .google.protobuf.Duration megamiss_timeout = 2;
  bool has_megamiss_timeout() const;
  void clear_megamiss_timeout();
  static const int kMegamissTimeoutFieldNumber = 2;
  const ::google::protobuf::Duration& megamiss_timeout() const;
  ::google::protobuf::Duration* mutable_megamiss_timeout();
  ::google::protobuf::Duration* release_megamiss_timeout();
  void set_allocated_megamiss_timeout(::google::protobuf::Duration* megamiss_timeout);

  // .google.protobuf.Duration kill_timeout = 3;
  bool has_kill_timeout() const;
  void clear_kill_timeout();
  static const int kKillTimeoutFieldNumber = 3;
  const ::google::protobuf::Duration& kill_timeout() const;
  ::google::protobuf::Duration* mutable_kill_timeout();
  ::google::protobuf::Duration* release_kill_timeout();
  void set_allocated_kill_timeout(::google::protobuf::Duration* kill_timeout);

  // .google.protobuf.Duration multikill_timeout = 4;
  bool has_multikill_timeout() const;
  void clear_multikill_timeout();
  static const int kMultikillTimeoutFieldNumber = 4;
  const ::google::protobuf::Duration& multikill_timeout() const;
  ::google::protobuf::Duration* mutable_multikill_timeout();
  ::google::protobuf::Duration* release_multikill_timeout();
  void set_allocated_multikill_timeout(::google::protobuf::Duration* multikill_timeout);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Watchdog)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::Duration* miss_timeout_;
  ::google::protobuf::Duration* megamiss_timeout_;
  ::google::protobuf::Duration* kill_timeout_;
  ::google::protobuf::Duration* multikill_timeout_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Runtime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Runtime) */ {
 public:
  Runtime();
  virtual ~Runtime();

  Runtime(const Runtime& from);

  inline Runtime& operator=(const Runtime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Runtime(Runtime&& from) noexcept
    : Runtime() {
    *this = ::std::move(from);
  }

  inline Runtime& operator=(Runtime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Runtime& default_instance();

  static inline const Runtime* internal_default_instance() {
    return reinterpret_cast<const Runtime*>(
               &_Runtime_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Runtime* other);
  friend void swap(Runtime& a, Runtime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Runtime* New() const PROTOBUF_FINAL { return New(NULL); }

  Runtime* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Runtime& from);
  void MergeFrom(const Runtime& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Runtime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string symlink_root = 1;
  void clear_symlink_root();
  static const int kSymlinkRootFieldNumber = 1;
  const ::std::string& symlink_root() const;
  void set_symlink_root(const ::std::string& value);
  #if LANG_CXX11
  void set_symlink_root(::std::string&& value);
  #endif
  void set_symlink_root(const char* value);
  void set_symlink_root(const char* value, size_t size);
  ::std::string* mutable_symlink_root();
  ::std::string* release_symlink_root();
  void set_allocated_symlink_root(::std::string* symlink_root);

  // string subdirectory = 2;
  void clear_subdirectory();
  static const int kSubdirectoryFieldNumber = 2;
  const ::std::string& subdirectory() const;
  void set_subdirectory(const ::std::string& value);
  #if LANG_CXX11
  void set_subdirectory(::std::string&& value);
  #endif
  void set_subdirectory(const char* value);
  void set_subdirectory(const char* value, size_t size);
  ::std::string* mutable_subdirectory();
  ::std::string* release_subdirectory();
  void set_allocated_subdirectory(::std::string* subdirectory);

  // string override_subdirectory = 3;
  void clear_override_subdirectory();
  static const int kOverrideSubdirectoryFieldNumber = 3;
  const ::std::string& override_subdirectory() const;
  void set_override_subdirectory(const ::std::string& value);
  #if LANG_CXX11
  void set_override_subdirectory(::std::string&& value);
  #endif
  void set_override_subdirectory(const char* value);
  void set_override_subdirectory(const char* value, size_t size);
  ::std::string* mutable_override_subdirectory();
  ::std::string* release_override_subdirectory();
  void set_allocated_override_subdirectory(::std::string* override_subdirectory);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Runtime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr symlink_root_;
  ::google::protobuf::internal::ArenaStringPtr subdirectory_;
  ::google::protobuf::internal::ArenaStringPtr override_subdirectory_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimitServiceConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimitServiceConfig) */ {
 public:
  RateLimitServiceConfig();
  virtual ~RateLimitServiceConfig();

  RateLimitServiceConfig(const RateLimitServiceConfig& from);

  inline RateLimitServiceConfig& operator=(const RateLimitServiceConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitServiceConfig(RateLimitServiceConfig&& from) noexcept
    : RateLimitServiceConfig() {
    *this = ::std::move(from);
  }

  inline RateLimitServiceConfig& operator=(RateLimitServiceConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitServiceConfig& default_instance();

  static inline const RateLimitServiceConfig* internal_default_instance() {
    return reinterpret_cast<const RateLimitServiceConfig*>(
               &_RateLimitServiceConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RateLimitServiceConfig* other);
  friend void swap(RateLimitServiceConfig& a, RateLimitServiceConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitServiceConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitServiceConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitServiceConfig& from);
  void MergeFrom(const RateLimitServiceConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitServiceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster_name = 1;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 1;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimitServiceConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bootstrap_StaticResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Bootstrap.StaticResources) */ {
 public:
  Bootstrap_StaticResources();
  virtual ~Bootstrap_StaticResources();

  Bootstrap_StaticResources(const Bootstrap_StaticResources& from);

  inline Bootstrap_StaticResources& operator=(const Bootstrap_StaticResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bootstrap_StaticResources(Bootstrap_StaticResources&& from) noexcept
    : Bootstrap_StaticResources() {
    *this = ::std::move(from);
  }

  inline Bootstrap_StaticResources& operator=(Bootstrap_StaticResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bootstrap_StaticResources& default_instance();

  static inline const Bootstrap_StaticResources* internal_default_instance() {
    return reinterpret_cast<const Bootstrap_StaticResources*>(
               &_Bootstrap_StaticResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Bootstrap_StaticResources* other);
  friend void swap(Bootstrap_StaticResources& a, Bootstrap_StaticResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bootstrap_StaticResources* New() const PROTOBUF_FINAL { return New(NULL); }

  Bootstrap_StaticResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bootstrap_StaticResources& from);
  void MergeFrom(const Bootstrap_StaticResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bootstrap_StaticResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.Listener listeners = 1;
  int listeners_size() const;
  void clear_listeners();
  static const int kListenersFieldNumber = 1;
  const ::envoy::api::v2::Listener& listeners(int index) const;
  ::envoy::api::v2::Listener* mutable_listeners(int index);
  ::envoy::api::v2::Listener* add_listeners();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Listener >*
      mutable_listeners();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Listener >&
      listeners() const;

  // repeated .envoy.api.v2.Cluster clusters = 2;
  int clusters_size() const;
  void clear_clusters();
  static const int kClustersFieldNumber = 2;
  const ::envoy::api::v2::Cluster& clusters(int index) const;
  ::envoy::api::v2::Cluster* mutable_clusters(int index);
  ::envoy::api::v2::Cluster* add_clusters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Cluster >*
      mutable_clusters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Cluster >&
      clusters() const;

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Bootstrap.StaticResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Listener > listeners_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Cluster > clusters_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bootstrap_DynamicResources_DeprecatedV1 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1) */ {
 public:
  Bootstrap_DynamicResources_DeprecatedV1();
  virtual ~Bootstrap_DynamicResources_DeprecatedV1();

  Bootstrap_DynamicResources_DeprecatedV1(const Bootstrap_DynamicResources_DeprecatedV1& from);

  inline Bootstrap_DynamicResources_DeprecatedV1& operator=(const Bootstrap_DynamicResources_DeprecatedV1& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bootstrap_DynamicResources_DeprecatedV1(Bootstrap_DynamicResources_DeprecatedV1&& from) noexcept
    : Bootstrap_DynamicResources_DeprecatedV1() {
    *this = ::std::move(from);
  }

  inline Bootstrap_DynamicResources_DeprecatedV1& operator=(Bootstrap_DynamicResources_DeprecatedV1&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bootstrap_DynamicResources_DeprecatedV1& default_instance();

  static inline const Bootstrap_DynamicResources_DeprecatedV1* internal_default_instance() {
    return reinterpret_cast<const Bootstrap_DynamicResources_DeprecatedV1*>(
               &_Bootstrap_DynamicResources_DeprecatedV1_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Bootstrap_DynamicResources_DeprecatedV1* other);
  friend void swap(Bootstrap_DynamicResources_DeprecatedV1& a, Bootstrap_DynamicResources_DeprecatedV1& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bootstrap_DynamicResources_DeprecatedV1* New() const PROTOBUF_FINAL { return New(NULL); }

  Bootstrap_DynamicResources_DeprecatedV1* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bootstrap_DynamicResources_DeprecatedV1& from);
  void MergeFrom(const Bootstrap_DynamicResources_DeprecatedV1& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bootstrap_DynamicResources_DeprecatedV1* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.ConfigSource sds_config = 1;
  bool has_sds_config() const;
  void clear_sds_config();
  static const int kSdsConfigFieldNumber = 1;
  const ::envoy::api::v2::ConfigSource& sds_config() const;
  ::envoy::api::v2::ConfigSource* mutable_sds_config();
  ::envoy::api::v2::ConfigSource* release_sds_config();
  void set_allocated_sds_config(::envoy::api::v2::ConfigSource* sds_config);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::ConfigSource* sds_config_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bootstrap_DynamicResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Bootstrap.DynamicResources) */ {
 public:
  Bootstrap_DynamicResources();
  virtual ~Bootstrap_DynamicResources();

  Bootstrap_DynamicResources(const Bootstrap_DynamicResources& from);

  inline Bootstrap_DynamicResources& operator=(const Bootstrap_DynamicResources& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bootstrap_DynamicResources(Bootstrap_DynamicResources&& from) noexcept
    : Bootstrap_DynamicResources() {
    *this = ::std::move(from);
  }

  inline Bootstrap_DynamicResources& operator=(Bootstrap_DynamicResources&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bootstrap_DynamicResources& default_instance();

  static inline const Bootstrap_DynamicResources* internal_default_instance() {
    return reinterpret_cast<const Bootstrap_DynamicResources*>(
               &_Bootstrap_DynamicResources_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Bootstrap_DynamicResources* other);
  friend void swap(Bootstrap_DynamicResources& a, Bootstrap_DynamicResources& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bootstrap_DynamicResources* New() const PROTOBUF_FINAL { return New(NULL); }

  Bootstrap_DynamicResources* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bootstrap_DynamicResources& from);
  void MergeFrom(const Bootstrap_DynamicResources& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bootstrap_DynamicResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Bootstrap_DynamicResources_DeprecatedV1 DeprecatedV1;

  // accessors -------------------------------------------------------

  // .envoy.api.v2.ConfigSource lds_config = 1;
  bool has_lds_config() const;
  void clear_lds_config();
  static const int kLdsConfigFieldNumber = 1;
  const ::envoy::api::v2::ConfigSource& lds_config() const;
  ::envoy::api::v2::ConfigSource* mutable_lds_config();
  ::envoy::api::v2::ConfigSource* release_lds_config();
  void set_allocated_lds_config(::envoy::api::v2::ConfigSource* lds_config);

  // .envoy.api.v2.ConfigSource cds_config = 2;
  bool has_cds_config() const;
  void clear_cds_config();
  static const int kCdsConfigFieldNumber = 2;
  const ::envoy::api::v2::ConfigSource& cds_config() const;
  ::envoy::api::v2::ConfigSource* mutable_cds_config();
  ::envoy::api::v2::ConfigSource* release_cds_config();
  void set_allocated_cds_config(::envoy::api::v2::ConfigSource* cds_config);

  // .envoy.api.v2.ApiConfigSource ads_config = 3;
  bool has_ads_config() const;
  void clear_ads_config();
  static const int kAdsConfigFieldNumber = 3;
  const ::envoy::api::v2::ApiConfigSource& ads_config() const;
  ::envoy::api::v2::ApiConfigSource* mutable_ads_config();
  ::envoy::api::v2::ApiConfigSource* release_ads_config();
  void set_allocated_ads_config(::envoy::api::v2::ApiConfigSource* ads_config);

  // .envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1 deprecated_v1 = 4;
  bool has_deprecated_v1() const;
  void clear_deprecated_v1();
  static const int kDeprecatedV1FieldNumber = 4;
  const ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1& deprecated_v1() const;
  ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* mutable_deprecated_v1();
  ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* release_deprecated_v1();
  void set_allocated_deprecated_v1(::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* deprecated_v1);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Bootstrap.DynamicResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::ConfigSource* lds_config_;
  ::envoy::api::v2::ConfigSource* cds_config_;
  ::envoy::api::v2::ApiConfigSource* ads_config_;
  ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* deprecated_v1_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Bootstrap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Bootstrap) */ {
 public:
  Bootstrap();
  virtual ~Bootstrap();

  Bootstrap(const Bootstrap& from);

  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bootstrap(Bootstrap&& from) noexcept
    : Bootstrap() {
    *this = ::std::move(from);
  }

  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Bootstrap& default_instance();

  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
               &_Bootstrap_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Bootstrap* other);
  friend void swap(Bootstrap& a, Bootstrap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bootstrap* New() const PROTOBUF_FINAL { return New(NULL); }

  Bootstrap* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bootstrap& from);
  void MergeFrom(const Bootstrap& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bootstrap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Bootstrap_StaticResources StaticResources;
  typedef Bootstrap_DynamicResources DynamicResources;

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.StatsSink stats_sinks = 6;
  int stats_sinks_size() const;
  void clear_stats_sinks();
  static const int kStatsSinksFieldNumber = 6;
  const ::envoy::api::v2::StatsSink& stats_sinks(int index) const;
  ::envoy::api::v2::StatsSink* mutable_stats_sinks(int index);
  ::envoy::api::v2::StatsSink* add_stats_sinks();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::StatsSink >*
      mutable_stats_sinks();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::StatsSink >&
      stats_sinks() const;

  // string flags_path = 5;
  void clear_flags_path();
  static const int kFlagsPathFieldNumber = 5;
  const ::std::string& flags_path() const;
  void set_flags_path(const ::std::string& value);
  #if LANG_CXX11
  void set_flags_path(::std::string&& value);
  #endif
  void set_flags_path(const char* value);
  void set_flags_path(const char* value, size_t size);
  ::std::string* mutable_flags_path();
  ::std::string* release_flags_path();
  void set_allocated_flags_path(::std::string* flags_path);

  // .envoy.api.v2.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::envoy::api::v2::Node& node() const;
  ::envoy::api::v2::Node* mutable_node();
  ::envoy::api::v2::Node* release_node();
  void set_allocated_node(::envoy::api::v2::Node* node);

  // .envoy.api.v2.Bootstrap.StaticResources static_resources = 2;
  bool has_static_resources() const;
  void clear_static_resources();
  static const int kStaticResourcesFieldNumber = 2;
  const ::envoy::api::v2::Bootstrap_StaticResources& static_resources() const;
  ::envoy::api::v2::Bootstrap_StaticResources* mutable_static_resources();
  ::envoy::api::v2::Bootstrap_StaticResources* release_static_resources();
  void set_allocated_static_resources(::envoy::api::v2::Bootstrap_StaticResources* static_resources);

  // .envoy.api.v2.Bootstrap.DynamicResources dynamic_resources = 3;
  bool has_dynamic_resources() const;
  void clear_dynamic_resources();
  static const int kDynamicResourcesFieldNumber = 3;
  const ::envoy::api::v2::Bootstrap_DynamicResources& dynamic_resources() const;
  ::envoy::api::v2::Bootstrap_DynamicResources* mutable_dynamic_resources();
  ::envoy::api::v2::Bootstrap_DynamicResources* release_dynamic_resources();
  void set_allocated_dynamic_resources(::envoy::api::v2::Bootstrap_DynamicResources* dynamic_resources);

  // .envoy.api.v2.ClusterManager cluster_manager = 4;
  bool has_cluster_manager() const;
  void clear_cluster_manager();
  static const int kClusterManagerFieldNumber = 4;
  const ::envoy::api::v2::ClusterManager& cluster_manager() const;
  ::envoy::api::v2::ClusterManager* mutable_cluster_manager();
  ::envoy::api::v2::ClusterManager* release_cluster_manager();
  void set_allocated_cluster_manager(::envoy::api::v2::ClusterManager* cluster_manager);

  // .google.protobuf.Duration stats_flush_interval = 7;
  bool has_stats_flush_interval() const;
  void clear_stats_flush_interval();
  static const int kStatsFlushIntervalFieldNumber = 7;
  const ::google::protobuf::Duration& stats_flush_interval() const;
  ::google::protobuf::Duration* mutable_stats_flush_interval();
  ::google::protobuf::Duration* release_stats_flush_interval();
  void set_allocated_stats_flush_interval(::google::protobuf::Duration* stats_flush_interval);

  // .envoy.api.v2.Watchdog watchdog = 8;
  bool has_watchdog() const;
  void clear_watchdog();
  static const int kWatchdogFieldNumber = 8;
  const ::envoy::api::v2::Watchdog& watchdog() const;
  ::envoy::api::v2::Watchdog* mutable_watchdog();
  ::envoy::api::v2::Watchdog* release_watchdog();
  void set_allocated_watchdog(::envoy::api::v2::Watchdog* watchdog);

  // .envoy.api.v2.Tracing tracing = 9;
  bool has_tracing() const;
  void clear_tracing();
  static const int kTracingFieldNumber = 9;
  const ::envoy::api::v2::Tracing& tracing() const;
  ::envoy::api::v2::Tracing* mutable_tracing();
  ::envoy::api::v2::Tracing* release_tracing();
  void set_allocated_tracing(::envoy::api::v2::Tracing* tracing);

  // .envoy.api.v2.RateLimitServiceConfig rate_limit_service = 10;
  bool has_rate_limit_service() const;
  void clear_rate_limit_service();
  static const int kRateLimitServiceFieldNumber = 10;
  const ::envoy::api::v2::RateLimitServiceConfig& rate_limit_service() const;
  ::envoy::api::v2::RateLimitServiceConfig* mutable_rate_limit_service();
  ::envoy::api::v2::RateLimitServiceConfig* release_rate_limit_service();
  void set_allocated_rate_limit_service(::envoy::api::v2::RateLimitServiceConfig* rate_limit_service);

  // .envoy.api.v2.Runtime runtime = 11;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 11;
  const ::envoy::api::v2::Runtime& runtime() const;
  ::envoy::api::v2::Runtime* mutable_runtime();
  ::envoy::api::v2::Runtime* release_runtime();
  void set_allocated_runtime(::envoy::api::v2::Runtime* runtime);

  // .envoy.api.v2.Admin admin = 12;
  bool has_admin() const;
  void clear_admin();
  static const int kAdminFieldNumber = 12;
  const ::envoy::api::v2::Admin& admin() const;
  ::envoy::api::v2::Admin* mutable_admin();
  ::envoy::api::v2::Admin* release_admin();
  void set_allocated_admin(::envoy::api::v2::Admin* admin);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Bootstrap)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::StatsSink > stats_sinks_;
  ::google::protobuf::internal::ArenaStringPtr flags_path_;
  ::envoy::api::v2::Node* node_;
  ::envoy::api::v2::Bootstrap_StaticResources* static_resources_;
  ::envoy::api::v2::Bootstrap_DynamicResources* dynamic_resources_;
  ::envoy::api::v2::ClusterManager* cluster_manager_;
  ::google::protobuf::Duration* stats_flush_interval_;
  ::envoy::api::v2::Watchdog* watchdog_;
  ::envoy::api::v2::Tracing* tracing_;
  ::envoy::api::v2::RateLimitServiceConfig* rate_limit_service_;
  ::envoy::api::v2::Runtime* runtime_;
  ::envoy::api::v2::Admin* admin_;
  mutable int _cached_size_;
  friend struct protobuf_api_2fbootstrap_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LightstepConfig

// string collector_cluster = 1;
inline void LightstepConfig::clear_collector_cluster() {
  collector_cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LightstepConfig::collector_cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.LightstepConfig.collector_cluster)
  return collector_cluster_.GetNoArena();
}
inline void LightstepConfig::set_collector_cluster(const ::std::string& value) {
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.LightstepConfig.collector_cluster)
}
#if LANG_CXX11
inline void LightstepConfig::set_collector_cluster(::std::string&& value) {
  
  collector_cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.LightstepConfig.collector_cluster)
}
#endif
inline void LightstepConfig::set_collector_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.LightstepConfig.collector_cluster)
}
inline void LightstepConfig::set_collector_cluster(const char* value, size_t size) {
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.LightstepConfig.collector_cluster)
}
inline ::std::string* LightstepConfig::mutable_collector_cluster() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.LightstepConfig.collector_cluster)
  return collector_cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LightstepConfig::release_collector_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.LightstepConfig.collector_cluster)
  
  return collector_cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LightstepConfig::set_allocated_collector_cluster(::std::string* collector_cluster) {
  if (collector_cluster != NULL) {
    
  } else {
    
  }
  collector_cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collector_cluster);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.LightstepConfig.collector_cluster)
}

// string access_token_file = 2;
inline void LightstepConfig::clear_access_token_file() {
  access_token_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LightstepConfig::access_token_file() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.LightstepConfig.access_token_file)
  return access_token_file_.GetNoArena();
}
inline void LightstepConfig::set_access_token_file(const ::std::string& value) {
  
  access_token_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.LightstepConfig.access_token_file)
}
#if LANG_CXX11
inline void LightstepConfig::set_access_token_file(::std::string&& value) {
  
  access_token_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.LightstepConfig.access_token_file)
}
#endif
inline void LightstepConfig::set_access_token_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  access_token_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.LightstepConfig.access_token_file)
}
inline void LightstepConfig::set_access_token_file(const char* value, size_t size) {
  
  access_token_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.LightstepConfig.access_token_file)
}
inline ::std::string* LightstepConfig::mutable_access_token_file() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.LightstepConfig.access_token_file)
  return access_token_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LightstepConfig::release_access_token_file() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.LightstepConfig.access_token_file)
  
  return access_token_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LightstepConfig::set_allocated_access_token_file(::std::string* access_token_file) {
  if (access_token_file != NULL) {
    
  } else {
    
  }
  access_token_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_token_file);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.LightstepConfig.access_token_file)
}

// -------------------------------------------------------------------

// ZipkinConfig

// string collector_cluster = 1;
inline void ZipkinConfig::clear_collector_cluster() {
  collector_cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ZipkinConfig::collector_cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ZipkinConfig.collector_cluster)
  return collector_cluster_.GetNoArena();
}
inline void ZipkinConfig::set_collector_cluster(const ::std::string& value) {
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.ZipkinConfig.collector_cluster)
}
#if LANG_CXX11
inline void ZipkinConfig::set_collector_cluster(::std::string&& value) {
  
  collector_cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.ZipkinConfig.collector_cluster)
}
#endif
inline void ZipkinConfig::set_collector_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.ZipkinConfig.collector_cluster)
}
inline void ZipkinConfig::set_collector_cluster(const char* value, size_t size) {
  
  collector_cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.ZipkinConfig.collector_cluster)
}
inline ::std::string* ZipkinConfig::mutable_collector_cluster() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ZipkinConfig.collector_cluster)
  return collector_cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ZipkinConfig::release_collector_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ZipkinConfig.collector_cluster)
  
  return collector_cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ZipkinConfig::set_allocated_collector_cluster(::std::string* collector_cluster) {
  if (collector_cluster != NULL) {
    
  } else {
    
  }
  collector_cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collector_cluster);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ZipkinConfig.collector_cluster)
}

// string collector_endpoint = 2;
inline void ZipkinConfig::clear_collector_endpoint() {
  collector_endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ZipkinConfig::collector_endpoint() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ZipkinConfig.collector_endpoint)
  return collector_endpoint_.GetNoArena();
}
inline void ZipkinConfig::set_collector_endpoint(const ::std::string& value) {
  
  collector_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.ZipkinConfig.collector_endpoint)
}
#if LANG_CXX11
inline void ZipkinConfig::set_collector_endpoint(::std::string&& value) {
  
  collector_endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.ZipkinConfig.collector_endpoint)
}
#endif
inline void ZipkinConfig::set_collector_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  collector_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.ZipkinConfig.collector_endpoint)
}
inline void ZipkinConfig::set_collector_endpoint(const char* value, size_t size) {
  
  collector_endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.ZipkinConfig.collector_endpoint)
}
inline ::std::string* ZipkinConfig::mutable_collector_endpoint() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ZipkinConfig.collector_endpoint)
  return collector_endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ZipkinConfig::release_collector_endpoint() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ZipkinConfig.collector_endpoint)
  
  return collector_endpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ZipkinConfig::set_allocated_collector_endpoint(::std::string* collector_endpoint) {
  if (collector_endpoint != NULL) {
    
  } else {
    
  }
  collector_endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), collector_endpoint);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ZipkinConfig.collector_endpoint)
}

// -------------------------------------------------------------------

// Tracing_Http

// string name = 1;
inline void Tracing_Http::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Tracing_Http::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Tracing.Http.name)
  return name_.GetNoArena();
}
inline void Tracing_Http::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Tracing.Http.name)
}
#if LANG_CXX11
inline void Tracing_Http::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Tracing.Http.name)
}
#endif
inline void Tracing_Http::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Tracing.Http.name)
}
inline void Tracing_Http::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Tracing.Http.name)
}
inline ::std::string* Tracing_Http::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Tracing.Http.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Tracing_Http::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Tracing.Http.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Tracing_Http::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Tracing.Http.name)
}

// .google.protobuf.Struct config = 2;
inline bool Tracing_Http::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void Tracing_Http::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) delete config_;
  config_ = NULL;
}
inline const ::google::protobuf::Struct& Tracing_Http::config() const {
  const ::google::protobuf::Struct* p = config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Tracing.Http.config)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* Tracing_Http::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Tracing.Http.config)
  return config_;
}
inline ::google::protobuf::Struct* Tracing_Http::release_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Tracing.Http.config)
  
  ::google::protobuf::Struct* temp = config_;
  config_ = NULL;
  return temp;
}
inline void Tracing_Http::set_allocated_config(::google::protobuf::Struct* config) {
  delete config_;
  if (config != NULL && config->GetArena() != NULL) {
    ::google::protobuf::Struct* new_config = new ::google::protobuf::Struct;
    new_config->CopyFrom(*config);
    config = new_config;
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Tracing.Http.config)
}

// -------------------------------------------------------------------

// Tracing

// .envoy.api.v2.Tracing.Http http = 1;
inline bool Tracing::has_http() const {
  return this != internal_default_instance() && http_ != NULL;
}
inline void Tracing::clear_http() {
  if (GetArenaNoVirtual() == NULL && http_ != NULL) delete http_;
  http_ = NULL;
}
inline const ::envoy::api::v2::Tracing_Http& Tracing::http() const {
  const ::envoy::api::v2::Tracing_Http* p = http_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Tracing.http)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Tracing_Http*>(
      &::envoy::api::v2::_Tracing_Http_default_instance_);
}
inline ::envoy::api::v2::Tracing_Http* Tracing::mutable_http() {
  
  if (http_ == NULL) {
    http_ = new ::envoy::api::v2::Tracing_Http;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Tracing.http)
  return http_;
}
inline ::envoy::api::v2::Tracing_Http* Tracing::release_http() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Tracing.http)
  
  ::envoy::api::v2::Tracing_Http* temp = http_;
  http_ = NULL;
  return temp;
}
inline void Tracing::set_allocated_http(::envoy::api::v2::Tracing_Http* http) {
  delete http_;
  http_ = http;
  if (http) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Tracing.http)
}

// -------------------------------------------------------------------

// Admin

// string access_log_path = 1;
inline void Admin::clear_access_log_path() {
  access_log_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Admin::access_log_path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Admin.access_log_path)
  return access_log_path_.GetNoArena();
}
inline void Admin::set_access_log_path(const ::std::string& value) {
  
  access_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Admin.access_log_path)
}
#if LANG_CXX11
inline void Admin::set_access_log_path(::std::string&& value) {
  
  access_log_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Admin.access_log_path)
}
#endif
inline void Admin::set_access_log_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  access_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Admin.access_log_path)
}
inline void Admin::set_access_log_path(const char* value, size_t size) {
  
  access_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Admin.access_log_path)
}
inline ::std::string* Admin::mutable_access_log_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Admin.access_log_path)
  return access_log_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Admin::release_access_log_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Admin.access_log_path)
  
  return access_log_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Admin::set_allocated_access_log_path(::std::string* access_log_path) {
  if (access_log_path != NULL) {
    
  } else {
    
  }
  access_log_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), access_log_path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Admin.access_log_path)
}

// string profile_path = 2;
inline void Admin::clear_profile_path() {
  profile_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Admin::profile_path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Admin.profile_path)
  return profile_path_.GetNoArena();
}
inline void Admin::set_profile_path(const ::std::string& value) {
  
  profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Admin.profile_path)
}
#if LANG_CXX11
inline void Admin::set_profile_path(::std::string&& value) {
  
  profile_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Admin.profile_path)
}
#endif
inline void Admin::set_profile_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Admin.profile_path)
}
inline void Admin::set_profile_path(const char* value, size_t size) {
  
  profile_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Admin.profile_path)
}
inline ::std::string* Admin::mutable_profile_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Admin.profile_path)
  return profile_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Admin::release_profile_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Admin.profile_path)
  
  return profile_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Admin::set_allocated_profile_path(::std::string* profile_path) {
  if (profile_path != NULL) {
    
  } else {
    
  }
  profile_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), profile_path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Admin.profile_path)
}

// .envoy.api.v2.Address address = 3;
inline bool Admin::has_address() const {
  return this != internal_default_instance() && address_ != NULL;
}
inline void Admin::clear_address() {
  if (GetArenaNoVirtual() == NULL && address_ != NULL) delete address_;
  address_ = NULL;
}
inline const ::envoy::api::v2::Address& Admin::address() const {
  const ::envoy::api::v2::Address* p = address_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Admin.address)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Address*>(
      &::envoy::api::v2::_Address_default_instance_);
}
inline ::envoy::api::v2::Address* Admin::mutable_address() {
  
  if (address_ == NULL) {
    address_ = new ::envoy::api::v2::Address;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Admin.address)
  return address_;
}
inline ::envoy::api::v2::Address* Admin::release_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Admin.address)
  
  ::envoy::api::v2::Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline void Admin::set_allocated_address(::envoy::api::v2::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Admin.address)
}

// -------------------------------------------------------------------

// ClusterManager_OutlierDetection

// string event_log_path = 1;
inline void ClusterManager_OutlierDetection::clear_event_log_path() {
  event_log_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClusterManager_OutlierDetection::event_log_path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
  return event_log_path_.GetNoArena();
}
inline void ClusterManager_OutlierDetection::set_event_log_path(const ::std::string& value) {
  
  event_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
}
#if LANG_CXX11
inline void ClusterManager_OutlierDetection::set_event_log_path(::std::string&& value) {
  
  event_log_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
}
#endif
inline void ClusterManager_OutlierDetection::set_event_log_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  event_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
}
inline void ClusterManager_OutlierDetection::set_event_log_path(const char* value, size_t size) {
  
  event_log_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
}
inline ::std::string* ClusterManager_OutlierDetection::mutable_event_log_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
  return event_log_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClusterManager_OutlierDetection::release_event_log_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
  
  return event_log_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClusterManager_OutlierDetection::set_allocated_event_log_path(::std::string* event_log_path) {
  if (event_log_path != NULL) {
    
  } else {
    
  }
  event_log_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), event_log_path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ClusterManager.OutlierDetection.event_log_path)
}

// -------------------------------------------------------------------

// ClusterManager

// string local_cluster_name = 1;
inline void ClusterManager::clear_local_cluster_name() {
  local_cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClusterManager::local_cluster_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ClusterManager.local_cluster_name)
  return local_cluster_name_.GetNoArena();
}
inline void ClusterManager::set_local_cluster_name(const ::std::string& value) {
  
  local_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.ClusterManager.local_cluster_name)
}
#if LANG_CXX11
inline void ClusterManager::set_local_cluster_name(::std::string&& value) {
  
  local_cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.ClusterManager.local_cluster_name)
}
#endif
inline void ClusterManager::set_local_cluster_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  local_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.ClusterManager.local_cluster_name)
}
inline void ClusterManager::set_local_cluster_name(const char* value, size_t size) {
  
  local_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.ClusterManager.local_cluster_name)
}
inline ::std::string* ClusterManager::mutable_local_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ClusterManager.local_cluster_name)
  return local_cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClusterManager::release_local_cluster_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ClusterManager.local_cluster_name)
  
  return local_cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClusterManager::set_allocated_local_cluster_name(::std::string* local_cluster_name) {
  if (local_cluster_name != NULL) {
    
  } else {
    
  }
  local_cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), local_cluster_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ClusterManager.local_cluster_name)
}

// .envoy.api.v2.ClusterManager.OutlierDetection outlier_detection = 2;
inline bool ClusterManager::has_outlier_detection() const {
  return this != internal_default_instance() && outlier_detection_ != NULL;
}
inline void ClusterManager::clear_outlier_detection() {
  if (GetArenaNoVirtual() == NULL && outlier_detection_ != NULL) delete outlier_detection_;
  outlier_detection_ = NULL;
}
inline const ::envoy::api::v2::ClusterManager_OutlierDetection& ClusterManager::outlier_detection() const {
  const ::envoy::api::v2::ClusterManager_OutlierDetection* p = outlier_detection_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.ClusterManager.outlier_detection)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ClusterManager_OutlierDetection*>(
      &::envoy::api::v2::_ClusterManager_OutlierDetection_default_instance_);
}
inline ::envoy::api::v2::ClusterManager_OutlierDetection* ClusterManager::mutable_outlier_detection() {
  
  if (outlier_detection_ == NULL) {
    outlier_detection_ = new ::envoy::api::v2::ClusterManager_OutlierDetection;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ClusterManager.outlier_detection)
  return outlier_detection_;
}
inline ::envoy::api::v2::ClusterManager_OutlierDetection* ClusterManager::release_outlier_detection() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ClusterManager.outlier_detection)
  
  ::envoy::api::v2::ClusterManager_OutlierDetection* temp = outlier_detection_;
  outlier_detection_ = NULL;
  return temp;
}
inline void ClusterManager::set_allocated_outlier_detection(::envoy::api::v2::ClusterManager_OutlierDetection* outlier_detection) {
  delete outlier_detection_;
  outlier_detection_ = outlier_detection;
  if (outlier_detection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ClusterManager.outlier_detection)
}

// .envoy.api.v2.BindConfig upstream_bind_config = 3;
inline bool ClusterManager::has_upstream_bind_config() const {
  return this != internal_default_instance() && upstream_bind_config_ != NULL;
}
inline void ClusterManager::clear_upstream_bind_config() {
  if (GetArenaNoVirtual() == NULL && upstream_bind_config_ != NULL) delete upstream_bind_config_;
  upstream_bind_config_ = NULL;
}
inline const ::envoy::api::v2::BindConfig& ClusterManager::upstream_bind_config() const {
  const ::envoy::api::v2::BindConfig* p = upstream_bind_config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.ClusterManager.upstream_bind_config)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::BindConfig*>(
      &::envoy::api::v2::_BindConfig_default_instance_);
}
inline ::envoy::api::v2::BindConfig* ClusterManager::mutable_upstream_bind_config() {
  
  if (upstream_bind_config_ == NULL) {
    upstream_bind_config_ = new ::envoy::api::v2::BindConfig;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ClusterManager.upstream_bind_config)
  return upstream_bind_config_;
}
inline ::envoy::api::v2::BindConfig* ClusterManager::release_upstream_bind_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ClusterManager.upstream_bind_config)
  
  ::envoy::api::v2::BindConfig* temp = upstream_bind_config_;
  upstream_bind_config_ = NULL;
  return temp;
}
inline void ClusterManager::set_allocated_upstream_bind_config(::envoy::api::v2::BindConfig* upstream_bind_config) {
  delete upstream_bind_config_;
  upstream_bind_config_ = upstream_bind_config;
  if (upstream_bind_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ClusterManager.upstream_bind_config)
}

// -------------------------------------------------------------------

// StatsdSink

// .envoy.api.v2.Address address = 1;
inline bool StatsdSink::has_address() const {
  return statsd_specifier_case() == kAddress;
}
inline void StatsdSink::set_has_address() {
  _oneof_case_[0] = kAddress;
}
inline void StatsdSink::clear_address() {
  if (has_address()) {
    delete statsd_specifier_.address_;
    clear_has_statsd_specifier();
  }
}
inline  const ::envoy::api::v2::Address& StatsdSink::address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.StatsdSink.address)
  return has_address()
      ? *statsd_specifier_.address_
      : ::envoy::api::v2::Address::default_instance();
}
inline ::envoy::api::v2::Address* StatsdSink::mutable_address() {
  if (!has_address()) {
    clear_statsd_specifier();
    set_has_address();
    statsd_specifier_.address_ = new ::envoy::api::v2::Address;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.StatsdSink.address)
  return statsd_specifier_.address_;
}
inline ::envoy::api::v2::Address* StatsdSink::release_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.StatsdSink.address)
  if (has_address()) {
    clear_has_statsd_specifier();
    ::envoy::api::v2::Address* temp = statsd_specifier_.address_;
    statsd_specifier_.address_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void StatsdSink::set_allocated_address(::envoy::api::v2::Address* address) {
  clear_statsd_specifier();
  if (address) {
    set_has_address();
    statsd_specifier_.address_ = address;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.StatsdSink.address)
}

// string tcp_cluster_name = 2;
inline bool StatsdSink::has_tcp_cluster_name() const {
  return statsd_specifier_case() == kTcpClusterName;
}
inline void StatsdSink::set_has_tcp_cluster_name() {
  _oneof_case_[0] = kTcpClusterName;
}
inline void StatsdSink::clear_tcp_cluster_name() {
  if (has_tcp_cluster_name()) {
    statsd_specifier_.tcp_cluster_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_statsd_specifier();
  }
}
inline const ::std::string& StatsdSink::tcp_cluster_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.StatsdSink.tcp_cluster_name)
  if (has_tcp_cluster_name()) {
    return statsd_specifier_.tcp_cluster_name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void StatsdSink::set_tcp_cluster_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.StatsdSink.tcp_cluster_name)
  if (!has_tcp_cluster_name()) {
    clear_statsd_specifier();
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  statsd_specifier_.tcp_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.StatsdSink.tcp_cluster_name)
}
#if LANG_CXX11
inline void StatsdSink::set_tcp_cluster_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.StatsdSink.tcp_cluster_name)
  if (!has_tcp_cluster_name()) {
    clear_statsd_specifier();
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  statsd_specifier_.tcp_cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.StatsdSink.tcp_cluster_name)
}
#endif
inline void StatsdSink::set_tcp_cluster_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_tcp_cluster_name()) {
    clear_statsd_specifier();
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  statsd_specifier_.tcp_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.StatsdSink.tcp_cluster_name)
}
inline void StatsdSink::set_tcp_cluster_name(const char* value, size_t size) {
  if (!has_tcp_cluster_name()) {
    clear_statsd_specifier();
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  statsd_specifier_.tcp_cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.StatsdSink.tcp_cluster_name)
}
inline ::std::string* StatsdSink::mutable_tcp_cluster_name() {
  if (!has_tcp_cluster_name()) {
    clear_statsd_specifier();
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.StatsdSink.tcp_cluster_name)
  return statsd_specifier_.tcp_cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatsdSink::release_tcp_cluster_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.StatsdSink.tcp_cluster_name)
  if (has_tcp_cluster_name()) {
    clear_has_statsd_specifier();
    return statsd_specifier_.tcp_cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void StatsdSink::set_allocated_tcp_cluster_name(::std::string* tcp_cluster_name) {
  if (!has_tcp_cluster_name()) {
    statsd_specifier_.tcp_cluster_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_statsd_specifier();
  if (tcp_cluster_name != NULL) {
    set_has_tcp_cluster_name();
    statsd_specifier_.tcp_cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        tcp_cluster_name);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.StatsdSink.tcp_cluster_name)
}

inline bool StatsdSink::has_statsd_specifier() const {
  return statsd_specifier_case() != STATSD_SPECIFIER_NOT_SET;
}
inline void StatsdSink::clear_has_statsd_specifier() {
  _oneof_case_[0] = STATSD_SPECIFIER_NOT_SET;
}
inline StatsdSink::StatsdSpecifierCase StatsdSink::statsd_specifier_case() const {
  return StatsdSink::StatsdSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StatsSink

// string name = 1;
inline void StatsSink::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatsSink::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.StatsSink.name)
  return name_.GetNoArena();
}
inline void StatsSink::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.StatsSink.name)
}
#if LANG_CXX11
inline void StatsSink::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.StatsSink.name)
}
#endif
inline void StatsSink::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.StatsSink.name)
}
inline void StatsSink::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.StatsSink.name)
}
inline ::std::string* StatsSink::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.StatsSink.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatsSink::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.StatsSink.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatsSink::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.StatsSink.name)
}

// .google.protobuf.Struct config = 2;
inline bool StatsSink::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void StatsSink::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) delete config_;
  config_ = NULL;
}
inline const ::google::protobuf::Struct& StatsSink::config() const {
  const ::google::protobuf::Struct* p = config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.StatsSink.config)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Struct*>(
      &::google::protobuf::_Struct_default_instance_);
}
inline ::google::protobuf::Struct* StatsSink::mutable_config() {
  
  if (config_ == NULL) {
    config_ = new ::google::protobuf::Struct;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.StatsSink.config)
  return config_;
}
inline ::google::protobuf::Struct* StatsSink::release_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.StatsSink.config)
  
  ::google::protobuf::Struct* temp = config_;
  config_ = NULL;
  return temp;
}
inline void StatsSink::set_allocated_config(::google::protobuf::Struct* config) {
  delete config_;
  if (config != NULL && config->GetArena() != NULL) {
    ::google::protobuf::Struct* new_config = new ::google::protobuf::Struct;
    new_config->CopyFrom(*config);
    config = new_config;
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.StatsSink.config)
}

// -------------------------------------------------------------------

// Watchdog

// .google.protobuf.Duration miss_timeout = 1;
inline bool Watchdog::has_miss_timeout() const {
  return this != internal_default_instance() && miss_timeout_ != NULL;
}
inline void Watchdog::clear_miss_timeout() {
  if (GetArenaNoVirtual() == NULL && miss_timeout_ != NULL) delete miss_timeout_;
  miss_timeout_ = NULL;
}
inline const ::google::protobuf::Duration& Watchdog::miss_timeout() const {
  const ::google::protobuf::Duration* p = miss_timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Watchdog.miss_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Watchdog::mutable_miss_timeout() {
  
  if (miss_timeout_ == NULL) {
    miss_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Watchdog.miss_timeout)
  return miss_timeout_;
}
inline ::google::protobuf::Duration* Watchdog::release_miss_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Watchdog.miss_timeout)
  
  ::google::protobuf::Duration* temp = miss_timeout_;
  miss_timeout_ = NULL;
  return temp;
}
inline void Watchdog::set_allocated_miss_timeout(::google::protobuf::Duration* miss_timeout) {
  delete miss_timeout_;
  if (miss_timeout != NULL && miss_timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_miss_timeout = new ::google::protobuf::Duration;
    new_miss_timeout->CopyFrom(*miss_timeout);
    miss_timeout = new_miss_timeout;
  }
  miss_timeout_ = miss_timeout;
  if (miss_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Watchdog.miss_timeout)
}

// .google.protobuf.Duration megamiss_timeout = 2;
inline bool Watchdog::has_megamiss_timeout() const {
  return this != internal_default_instance() && megamiss_timeout_ != NULL;
}
inline void Watchdog::clear_megamiss_timeout() {
  if (GetArenaNoVirtual() == NULL && megamiss_timeout_ != NULL) delete megamiss_timeout_;
  megamiss_timeout_ = NULL;
}
inline const ::google::protobuf::Duration& Watchdog::megamiss_timeout() const {
  const ::google::protobuf::Duration* p = megamiss_timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Watchdog.megamiss_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Watchdog::mutable_megamiss_timeout() {
  
  if (megamiss_timeout_ == NULL) {
    megamiss_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Watchdog.megamiss_timeout)
  return megamiss_timeout_;
}
inline ::google::protobuf::Duration* Watchdog::release_megamiss_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Watchdog.megamiss_timeout)
  
  ::google::protobuf::Duration* temp = megamiss_timeout_;
  megamiss_timeout_ = NULL;
  return temp;
}
inline void Watchdog::set_allocated_megamiss_timeout(::google::protobuf::Duration* megamiss_timeout) {
  delete megamiss_timeout_;
  if (megamiss_timeout != NULL && megamiss_timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_megamiss_timeout = new ::google::protobuf::Duration;
    new_megamiss_timeout->CopyFrom(*megamiss_timeout);
    megamiss_timeout = new_megamiss_timeout;
  }
  megamiss_timeout_ = megamiss_timeout;
  if (megamiss_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Watchdog.megamiss_timeout)
}

// .google.protobuf.Duration kill_timeout = 3;
inline bool Watchdog::has_kill_timeout() const {
  return this != internal_default_instance() && kill_timeout_ != NULL;
}
inline void Watchdog::clear_kill_timeout() {
  if (GetArenaNoVirtual() == NULL && kill_timeout_ != NULL) delete kill_timeout_;
  kill_timeout_ = NULL;
}
inline const ::google::protobuf::Duration& Watchdog::kill_timeout() const {
  const ::google::protobuf::Duration* p = kill_timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Watchdog.kill_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Watchdog::mutable_kill_timeout() {
  
  if (kill_timeout_ == NULL) {
    kill_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Watchdog.kill_timeout)
  return kill_timeout_;
}
inline ::google::protobuf::Duration* Watchdog::release_kill_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Watchdog.kill_timeout)
  
  ::google::protobuf::Duration* temp = kill_timeout_;
  kill_timeout_ = NULL;
  return temp;
}
inline void Watchdog::set_allocated_kill_timeout(::google::protobuf::Duration* kill_timeout) {
  delete kill_timeout_;
  if (kill_timeout != NULL && kill_timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_kill_timeout = new ::google::protobuf::Duration;
    new_kill_timeout->CopyFrom(*kill_timeout);
    kill_timeout = new_kill_timeout;
  }
  kill_timeout_ = kill_timeout;
  if (kill_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Watchdog.kill_timeout)
}

// .google.protobuf.Duration multikill_timeout = 4;
inline bool Watchdog::has_multikill_timeout() const {
  return this != internal_default_instance() && multikill_timeout_ != NULL;
}
inline void Watchdog::clear_multikill_timeout() {
  if (GetArenaNoVirtual() == NULL && multikill_timeout_ != NULL) delete multikill_timeout_;
  multikill_timeout_ = NULL;
}
inline const ::google::protobuf::Duration& Watchdog::multikill_timeout() const {
  const ::google::protobuf::Duration* p = multikill_timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Watchdog.multikill_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Watchdog::mutable_multikill_timeout() {
  
  if (multikill_timeout_ == NULL) {
    multikill_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Watchdog.multikill_timeout)
  return multikill_timeout_;
}
inline ::google::protobuf::Duration* Watchdog::release_multikill_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Watchdog.multikill_timeout)
  
  ::google::protobuf::Duration* temp = multikill_timeout_;
  multikill_timeout_ = NULL;
  return temp;
}
inline void Watchdog::set_allocated_multikill_timeout(::google::protobuf::Duration* multikill_timeout) {
  delete multikill_timeout_;
  if (multikill_timeout != NULL && multikill_timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_multikill_timeout = new ::google::protobuf::Duration;
    new_multikill_timeout->CopyFrom(*multikill_timeout);
    multikill_timeout = new_multikill_timeout;
  }
  multikill_timeout_ = multikill_timeout;
  if (multikill_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Watchdog.multikill_timeout)
}

// -------------------------------------------------------------------

// Runtime

// string symlink_root = 1;
inline void Runtime::clear_symlink_root() {
  symlink_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Runtime::symlink_root() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Runtime.symlink_root)
  return symlink_root_.GetNoArena();
}
inline void Runtime::set_symlink_root(const ::std::string& value) {
  
  symlink_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Runtime.symlink_root)
}
#if LANG_CXX11
inline void Runtime::set_symlink_root(::std::string&& value) {
  
  symlink_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Runtime.symlink_root)
}
#endif
inline void Runtime::set_symlink_root(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symlink_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Runtime.symlink_root)
}
inline void Runtime::set_symlink_root(const char* value, size_t size) {
  
  symlink_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Runtime.symlink_root)
}
inline ::std::string* Runtime::mutable_symlink_root() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Runtime.symlink_root)
  return symlink_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Runtime::release_symlink_root() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Runtime.symlink_root)
  
  return symlink_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Runtime::set_allocated_symlink_root(::std::string* symlink_root) {
  if (symlink_root != NULL) {
    
  } else {
    
  }
  symlink_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symlink_root);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Runtime.symlink_root)
}

// string subdirectory = 2;
inline void Runtime::clear_subdirectory() {
  subdirectory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Runtime::subdirectory() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Runtime.subdirectory)
  return subdirectory_.GetNoArena();
}
inline void Runtime::set_subdirectory(const ::std::string& value) {
  
  subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Runtime.subdirectory)
}
#if LANG_CXX11
inline void Runtime::set_subdirectory(::std::string&& value) {
  
  subdirectory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Runtime.subdirectory)
}
#endif
inline void Runtime::set_subdirectory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Runtime.subdirectory)
}
inline void Runtime::set_subdirectory(const char* value, size_t size) {
  
  subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Runtime.subdirectory)
}
inline ::std::string* Runtime::mutable_subdirectory() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Runtime.subdirectory)
  return subdirectory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Runtime::release_subdirectory() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Runtime.subdirectory)
  
  return subdirectory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Runtime::set_allocated_subdirectory(::std::string* subdirectory) {
  if (subdirectory != NULL) {
    
  } else {
    
  }
  subdirectory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), subdirectory);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Runtime.subdirectory)
}

// string override_subdirectory = 3;
inline void Runtime::clear_override_subdirectory() {
  override_subdirectory_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Runtime::override_subdirectory() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Runtime.override_subdirectory)
  return override_subdirectory_.GetNoArena();
}
inline void Runtime::set_override_subdirectory(const ::std::string& value) {
  
  override_subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Runtime.override_subdirectory)
}
#if LANG_CXX11
inline void Runtime::set_override_subdirectory(::std::string&& value) {
  
  override_subdirectory_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Runtime.override_subdirectory)
}
#endif
inline void Runtime::set_override_subdirectory(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  override_subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Runtime.override_subdirectory)
}
inline void Runtime::set_override_subdirectory(const char* value, size_t size) {
  
  override_subdirectory_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Runtime.override_subdirectory)
}
inline ::std::string* Runtime::mutable_override_subdirectory() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Runtime.override_subdirectory)
  return override_subdirectory_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Runtime::release_override_subdirectory() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Runtime.override_subdirectory)
  
  return override_subdirectory_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Runtime::set_allocated_override_subdirectory(::std::string* override_subdirectory) {
  if (override_subdirectory != NULL) {
    
  } else {
    
  }
  override_subdirectory_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), override_subdirectory);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Runtime.override_subdirectory)
}

// -------------------------------------------------------------------

// RateLimitServiceConfig

// string cluster_name = 1;
inline void RateLimitServiceConfig::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimitServiceConfig::cluster_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimitServiceConfig.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void RateLimitServiceConfig::set_cluster_name(const ::std::string& value) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimitServiceConfig.cluster_name)
}
#if LANG_CXX11
inline void RateLimitServiceConfig::set_cluster_name(::std::string&& value) {
  
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimitServiceConfig.cluster_name)
}
#endif
inline void RateLimitServiceConfig::set_cluster_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimitServiceConfig.cluster_name)
}
inline void RateLimitServiceConfig::set_cluster_name(const char* value, size_t size) {
  
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimitServiceConfig.cluster_name)
}
inline ::std::string* RateLimitServiceConfig::mutable_cluster_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimitServiceConfig.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimitServiceConfig::release_cluster_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimitServiceConfig.cluster_name)
  
  return cluster_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimitServiceConfig::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    
  } else {
    
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimitServiceConfig.cluster_name)
}

// -------------------------------------------------------------------

// Bootstrap_StaticResources

// repeated .envoy.api.v2.Listener listeners = 1;
inline int Bootstrap_StaticResources::listeners_size() const {
  return listeners_.size();
}
inline void Bootstrap_StaticResources::clear_listeners() {
  listeners_.Clear();
}
inline const ::envoy::api::v2::Listener& Bootstrap_StaticResources::listeners(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.StaticResources.listeners)
  return listeners_.Get(index);
}
inline ::envoy::api::v2::Listener* Bootstrap_StaticResources::mutable_listeners(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.StaticResources.listeners)
  return listeners_.Mutable(index);
}
inline ::envoy::api::v2::Listener* Bootstrap_StaticResources::add_listeners() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.Bootstrap.StaticResources.listeners)
  return listeners_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Listener >*
Bootstrap_StaticResources::mutable_listeners() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.Bootstrap.StaticResources.listeners)
  return &listeners_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Listener >&
Bootstrap_StaticResources::listeners() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.Bootstrap.StaticResources.listeners)
  return listeners_;
}

// repeated .envoy.api.v2.Cluster clusters = 2;
inline int Bootstrap_StaticResources::clusters_size() const {
  return clusters_.size();
}
inline void Bootstrap_StaticResources::clear_clusters() {
  clusters_.Clear();
}
inline const ::envoy::api::v2::Cluster& Bootstrap_StaticResources::clusters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.StaticResources.clusters)
  return clusters_.Get(index);
}
inline ::envoy::api::v2::Cluster* Bootstrap_StaticResources::mutable_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.StaticResources.clusters)
  return clusters_.Mutable(index);
}
inline ::envoy::api::v2::Cluster* Bootstrap_StaticResources::add_clusters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.Bootstrap.StaticResources.clusters)
  return clusters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Cluster >*
Bootstrap_StaticResources::mutable_clusters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.Bootstrap.StaticResources.clusters)
  return &clusters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Cluster >&
Bootstrap_StaticResources::clusters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.Bootstrap.StaticResources.clusters)
  return clusters_;
}

// -------------------------------------------------------------------

// Bootstrap_DynamicResources_DeprecatedV1

// .envoy.api.v2.ConfigSource sds_config = 1;
inline bool Bootstrap_DynamicResources_DeprecatedV1::has_sds_config() const {
  return this != internal_default_instance() && sds_config_ != NULL;
}
inline void Bootstrap_DynamicResources_DeprecatedV1::clear_sds_config() {
  if (GetArenaNoVirtual() == NULL && sds_config_ != NULL) delete sds_config_;
  sds_config_ = NULL;
}
inline const ::envoy::api::v2::ConfigSource& Bootstrap_DynamicResources_DeprecatedV1::sds_config() const {
  const ::envoy::api::v2::ConfigSource* p = sds_config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1.sds_config)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ConfigSource*>(
      &::envoy::api::v2::_ConfigSource_default_instance_);
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources_DeprecatedV1::mutable_sds_config() {
  
  if (sds_config_ == NULL) {
    sds_config_ = new ::envoy::api::v2::ConfigSource;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1.sds_config)
  return sds_config_;
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources_DeprecatedV1::release_sds_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1.sds_config)
  
  ::envoy::api::v2::ConfigSource* temp = sds_config_;
  sds_config_ = NULL;
  return temp;
}
inline void Bootstrap_DynamicResources_DeprecatedV1::set_allocated_sds_config(::envoy::api::v2::ConfigSource* sds_config) {
  delete sds_config_;
  sds_config_ = sds_config;
  if (sds_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1.sds_config)
}

// -------------------------------------------------------------------

// Bootstrap_DynamicResources

// .envoy.api.v2.ConfigSource lds_config = 1;
inline bool Bootstrap_DynamicResources::has_lds_config() const {
  return this != internal_default_instance() && lds_config_ != NULL;
}
inline void Bootstrap_DynamicResources::clear_lds_config() {
  if (GetArenaNoVirtual() == NULL && lds_config_ != NULL) delete lds_config_;
  lds_config_ = NULL;
}
inline const ::envoy::api::v2::ConfigSource& Bootstrap_DynamicResources::lds_config() const {
  const ::envoy::api::v2::ConfigSource* p = lds_config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.DynamicResources.lds_config)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ConfigSource*>(
      &::envoy::api::v2::_ConfigSource_default_instance_);
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources::mutable_lds_config() {
  
  if (lds_config_ == NULL) {
    lds_config_ = new ::envoy::api::v2::ConfigSource;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.DynamicResources.lds_config)
  return lds_config_;
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources::release_lds_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.DynamicResources.lds_config)
  
  ::envoy::api::v2::ConfigSource* temp = lds_config_;
  lds_config_ = NULL;
  return temp;
}
inline void Bootstrap_DynamicResources::set_allocated_lds_config(::envoy::api::v2::ConfigSource* lds_config) {
  delete lds_config_;
  lds_config_ = lds_config;
  if (lds_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.DynamicResources.lds_config)
}

// .envoy.api.v2.ConfigSource cds_config = 2;
inline bool Bootstrap_DynamicResources::has_cds_config() const {
  return this != internal_default_instance() && cds_config_ != NULL;
}
inline void Bootstrap_DynamicResources::clear_cds_config() {
  if (GetArenaNoVirtual() == NULL && cds_config_ != NULL) delete cds_config_;
  cds_config_ = NULL;
}
inline const ::envoy::api::v2::ConfigSource& Bootstrap_DynamicResources::cds_config() const {
  const ::envoy::api::v2::ConfigSource* p = cds_config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.DynamicResources.cds_config)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ConfigSource*>(
      &::envoy::api::v2::_ConfigSource_default_instance_);
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources::mutable_cds_config() {
  
  if (cds_config_ == NULL) {
    cds_config_ = new ::envoy::api::v2::ConfigSource;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.DynamicResources.cds_config)
  return cds_config_;
}
inline ::envoy::api::v2::ConfigSource* Bootstrap_DynamicResources::release_cds_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.DynamicResources.cds_config)
  
  ::envoy::api::v2::ConfigSource* temp = cds_config_;
  cds_config_ = NULL;
  return temp;
}
inline void Bootstrap_DynamicResources::set_allocated_cds_config(::envoy::api::v2::ConfigSource* cds_config) {
  delete cds_config_;
  cds_config_ = cds_config;
  if (cds_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.DynamicResources.cds_config)
}

// .envoy.api.v2.ApiConfigSource ads_config = 3;
inline bool Bootstrap_DynamicResources::has_ads_config() const {
  return this != internal_default_instance() && ads_config_ != NULL;
}
inline void Bootstrap_DynamicResources::clear_ads_config() {
  if (GetArenaNoVirtual() == NULL && ads_config_ != NULL) delete ads_config_;
  ads_config_ = NULL;
}
inline const ::envoy::api::v2::ApiConfigSource& Bootstrap_DynamicResources::ads_config() const {
  const ::envoy::api::v2::ApiConfigSource* p = ads_config_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.DynamicResources.ads_config)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ApiConfigSource*>(
      &::envoy::api::v2::_ApiConfigSource_default_instance_);
}
inline ::envoy::api::v2::ApiConfigSource* Bootstrap_DynamicResources::mutable_ads_config() {
  
  if (ads_config_ == NULL) {
    ads_config_ = new ::envoy::api::v2::ApiConfigSource;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.DynamicResources.ads_config)
  return ads_config_;
}
inline ::envoy::api::v2::ApiConfigSource* Bootstrap_DynamicResources::release_ads_config() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.DynamicResources.ads_config)
  
  ::envoy::api::v2::ApiConfigSource* temp = ads_config_;
  ads_config_ = NULL;
  return temp;
}
inline void Bootstrap_DynamicResources::set_allocated_ads_config(::envoy::api::v2::ApiConfigSource* ads_config) {
  delete ads_config_;
  ads_config_ = ads_config;
  if (ads_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.DynamicResources.ads_config)
}

// .envoy.api.v2.Bootstrap.DynamicResources.DeprecatedV1 deprecated_v1 = 4;
inline bool Bootstrap_DynamicResources::has_deprecated_v1() const {
  return this != internal_default_instance() && deprecated_v1_ != NULL;
}
inline void Bootstrap_DynamicResources::clear_deprecated_v1() {
  if (GetArenaNoVirtual() == NULL && deprecated_v1_ != NULL) delete deprecated_v1_;
  deprecated_v1_ = NULL;
}
inline const ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1& Bootstrap_DynamicResources::deprecated_v1() const {
  const ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* p = deprecated_v1_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.DynamicResources.deprecated_v1)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1*>(
      &::envoy::api::v2::_Bootstrap_DynamicResources_DeprecatedV1_default_instance_);
}
inline ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* Bootstrap_DynamicResources::mutable_deprecated_v1() {
  
  if (deprecated_v1_ == NULL) {
    deprecated_v1_ = new ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.DynamicResources.deprecated_v1)
  return deprecated_v1_;
}
inline ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* Bootstrap_DynamicResources::release_deprecated_v1() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.DynamicResources.deprecated_v1)
  
  ::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* temp = deprecated_v1_;
  deprecated_v1_ = NULL;
  return temp;
}
inline void Bootstrap_DynamicResources::set_allocated_deprecated_v1(::envoy::api::v2::Bootstrap_DynamicResources_DeprecatedV1* deprecated_v1) {
  delete deprecated_v1_;
  deprecated_v1_ = deprecated_v1;
  if (deprecated_v1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.DynamicResources.deprecated_v1)
}

// -------------------------------------------------------------------

// Bootstrap

// .envoy.api.v2.Node node = 1;
inline bool Bootstrap::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void Bootstrap::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) delete node_;
  node_ = NULL;
}
inline const ::envoy::api::v2::Node& Bootstrap::node() const {
  const ::envoy::api::v2::Node* p = node_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.node)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Node*>(
      &::envoy::api::v2::_Node_default_instance_);
}
inline ::envoy::api::v2::Node* Bootstrap::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::envoy::api::v2::Node;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.node)
  return node_;
}
inline ::envoy::api::v2::Node* Bootstrap::release_node() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.node)
  
  ::envoy::api::v2::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_node(::envoy::api::v2::Node* node) {
  delete node_;
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.node)
}

// .envoy.api.v2.Bootstrap.StaticResources static_resources = 2;
inline bool Bootstrap::has_static_resources() const {
  return this != internal_default_instance() && static_resources_ != NULL;
}
inline void Bootstrap::clear_static_resources() {
  if (GetArenaNoVirtual() == NULL && static_resources_ != NULL) delete static_resources_;
  static_resources_ = NULL;
}
inline const ::envoy::api::v2::Bootstrap_StaticResources& Bootstrap::static_resources() const {
  const ::envoy::api::v2::Bootstrap_StaticResources* p = static_resources_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.static_resources)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Bootstrap_StaticResources*>(
      &::envoy::api::v2::_Bootstrap_StaticResources_default_instance_);
}
inline ::envoy::api::v2::Bootstrap_StaticResources* Bootstrap::mutable_static_resources() {
  
  if (static_resources_ == NULL) {
    static_resources_ = new ::envoy::api::v2::Bootstrap_StaticResources;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.static_resources)
  return static_resources_;
}
inline ::envoy::api::v2::Bootstrap_StaticResources* Bootstrap::release_static_resources() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.static_resources)
  
  ::envoy::api::v2::Bootstrap_StaticResources* temp = static_resources_;
  static_resources_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_static_resources(::envoy::api::v2::Bootstrap_StaticResources* static_resources) {
  delete static_resources_;
  static_resources_ = static_resources;
  if (static_resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.static_resources)
}

// .envoy.api.v2.Bootstrap.DynamicResources dynamic_resources = 3;
inline bool Bootstrap::has_dynamic_resources() const {
  return this != internal_default_instance() && dynamic_resources_ != NULL;
}
inline void Bootstrap::clear_dynamic_resources() {
  if (GetArenaNoVirtual() == NULL && dynamic_resources_ != NULL) delete dynamic_resources_;
  dynamic_resources_ = NULL;
}
inline const ::envoy::api::v2::Bootstrap_DynamicResources& Bootstrap::dynamic_resources() const {
  const ::envoy::api::v2::Bootstrap_DynamicResources* p = dynamic_resources_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.dynamic_resources)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Bootstrap_DynamicResources*>(
      &::envoy::api::v2::_Bootstrap_DynamicResources_default_instance_);
}
inline ::envoy::api::v2::Bootstrap_DynamicResources* Bootstrap::mutable_dynamic_resources() {
  
  if (dynamic_resources_ == NULL) {
    dynamic_resources_ = new ::envoy::api::v2::Bootstrap_DynamicResources;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.dynamic_resources)
  return dynamic_resources_;
}
inline ::envoy::api::v2::Bootstrap_DynamicResources* Bootstrap::release_dynamic_resources() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.dynamic_resources)
  
  ::envoy::api::v2::Bootstrap_DynamicResources* temp = dynamic_resources_;
  dynamic_resources_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_dynamic_resources(::envoy::api::v2::Bootstrap_DynamicResources* dynamic_resources) {
  delete dynamic_resources_;
  dynamic_resources_ = dynamic_resources;
  if (dynamic_resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.dynamic_resources)
}

// .envoy.api.v2.ClusterManager cluster_manager = 4;
inline bool Bootstrap::has_cluster_manager() const {
  return this != internal_default_instance() && cluster_manager_ != NULL;
}
inline void Bootstrap::clear_cluster_manager() {
  if (GetArenaNoVirtual() == NULL && cluster_manager_ != NULL) delete cluster_manager_;
  cluster_manager_ = NULL;
}
inline const ::envoy::api::v2::ClusterManager& Bootstrap::cluster_manager() const {
  const ::envoy::api::v2::ClusterManager* p = cluster_manager_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.cluster_manager)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::ClusterManager*>(
      &::envoy::api::v2::_ClusterManager_default_instance_);
}
inline ::envoy::api::v2::ClusterManager* Bootstrap::mutable_cluster_manager() {
  
  if (cluster_manager_ == NULL) {
    cluster_manager_ = new ::envoy::api::v2::ClusterManager;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.cluster_manager)
  return cluster_manager_;
}
inline ::envoy::api::v2::ClusterManager* Bootstrap::release_cluster_manager() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.cluster_manager)
  
  ::envoy::api::v2::ClusterManager* temp = cluster_manager_;
  cluster_manager_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_cluster_manager(::envoy::api::v2::ClusterManager* cluster_manager) {
  delete cluster_manager_;
  cluster_manager_ = cluster_manager;
  if (cluster_manager) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.cluster_manager)
}

// string flags_path = 5;
inline void Bootstrap::clear_flags_path() {
  flags_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Bootstrap::flags_path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.flags_path)
  return flags_path_.GetNoArena();
}
inline void Bootstrap::set_flags_path(const ::std::string& value) {
  
  flags_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Bootstrap.flags_path)
}
#if LANG_CXX11
inline void Bootstrap::set_flags_path(::std::string&& value) {
  
  flags_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Bootstrap.flags_path)
}
#endif
inline void Bootstrap::set_flags_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  flags_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Bootstrap.flags_path)
}
inline void Bootstrap::set_flags_path(const char* value, size_t size) {
  
  flags_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Bootstrap.flags_path)
}
inline ::std::string* Bootstrap::mutable_flags_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.flags_path)
  return flags_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bootstrap::release_flags_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.flags_path)
  
  return flags_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bootstrap::set_allocated_flags_path(::std::string* flags_path) {
  if (flags_path != NULL) {
    
  } else {
    
  }
  flags_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), flags_path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.flags_path)
}

// repeated .envoy.api.v2.StatsSink stats_sinks = 6;
inline int Bootstrap::stats_sinks_size() const {
  return stats_sinks_.size();
}
inline void Bootstrap::clear_stats_sinks() {
  stats_sinks_.Clear();
}
inline const ::envoy::api::v2::StatsSink& Bootstrap::stats_sinks(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.stats_sinks)
  return stats_sinks_.Get(index);
}
inline ::envoy::api::v2::StatsSink* Bootstrap::mutable_stats_sinks(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.stats_sinks)
  return stats_sinks_.Mutable(index);
}
inline ::envoy::api::v2::StatsSink* Bootstrap::add_stats_sinks() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.Bootstrap.stats_sinks)
  return stats_sinks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::StatsSink >*
Bootstrap::mutable_stats_sinks() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.Bootstrap.stats_sinks)
  return &stats_sinks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::StatsSink >&
Bootstrap::stats_sinks() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.Bootstrap.stats_sinks)
  return stats_sinks_;
}

// .google.protobuf.Duration stats_flush_interval = 7;
inline bool Bootstrap::has_stats_flush_interval() const {
  return this != internal_default_instance() && stats_flush_interval_ != NULL;
}
inline void Bootstrap::clear_stats_flush_interval() {
  if (GetArenaNoVirtual() == NULL && stats_flush_interval_ != NULL) delete stats_flush_interval_;
  stats_flush_interval_ = NULL;
}
inline const ::google::protobuf::Duration& Bootstrap::stats_flush_interval() const {
  const ::google::protobuf::Duration* p = stats_flush_interval_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.stats_flush_interval)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* Bootstrap::mutable_stats_flush_interval() {
  
  if (stats_flush_interval_ == NULL) {
    stats_flush_interval_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.stats_flush_interval)
  return stats_flush_interval_;
}
inline ::google::protobuf::Duration* Bootstrap::release_stats_flush_interval() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.stats_flush_interval)
  
  ::google::protobuf::Duration* temp = stats_flush_interval_;
  stats_flush_interval_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_stats_flush_interval(::google::protobuf::Duration* stats_flush_interval) {
  delete stats_flush_interval_;
  if (stats_flush_interval != NULL && stats_flush_interval->GetArena() != NULL) {
    ::google::protobuf::Duration* new_stats_flush_interval = new ::google::protobuf::Duration;
    new_stats_flush_interval->CopyFrom(*stats_flush_interval);
    stats_flush_interval = new_stats_flush_interval;
  }
  stats_flush_interval_ = stats_flush_interval;
  if (stats_flush_interval) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.stats_flush_interval)
}

// .envoy.api.v2.Watchdog watchdog = 8;
inline bool Bootstrap::has_watchdog() const {
  return this != internal_default_instance() && watchdog_ != NULL;
}
inline void Bootstrap::clear_watchdog() {
  if (GetArenaNoVirtual() == NULL && watchdog_ != NULL) delete watchdog_;
  watchdog_ = NULL;
}
inline const ::envoy::api::v2::Watchdog& Bootstrap::watchdog() const {
  const ::envoy::api::v2::Watchdog* p = watchdog_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.watchdog)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Watchdog*>(
      &::envoy::api::v2::_Watchdog_default_instance_);
}
inline ::envoy::api::v2::Watchdog* Bootstrap::mutable_watchdog() {
  
  if (watchdog_ == NULL) {
    watchdog_ = new ::envoy::api::v2::Watchdog;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.watchdog)
  return watchdog_;
}
inline ::envoy::api::v2::Watchdog* Bootstrap::release_watchdog() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.watchdog)
  
  ::envoy::api::v2::Watchdog* temp = watchdog_;
  watchdog_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_watchdog(::envoy::api::v2::Watchdog* watchdog) {
  delete watchdog_;
  watchdog_ = watchdog;
  if (watchdog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.watchdog)
}

// .envoy.api.v2.Tracing tracing = 9;
inline bool Bootstrap::has_tracing() const {
  return this != internal_default_instance() && tracing_ != NULL;
}
inline void Bootstrap::clear_tracing() {
  if (GetArenaNoVirtual() == NULL && tracing_ != NULL) delete tracing_;
  tracing_ = NULL;
}
inline const ::envoy::api::v2::Tracing& Bootstrap::tracing() const {
  const ::envoy::api::v2::Tracing* p = tracing_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.tracing)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Tracing*>(
      &::envoy::api::v2::_Tracing_default_instance_);
}
inline ::envoy::api::v2::Tracing* Bootstrap::mutable_tracing() {
  
  if (tracing_ == NULL) {
    tracing_ = new ::envoy::api::v2::Tracing;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.tracing)
  return tracing_;
}
inline ::envoy::api::v2::Tracing* Bootstrap::release_tracing() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.tracing)
  
  ::envoy::api::v2::Tracing* temp = tracing_;
  tracing_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_tracing(::envoy::api::v2::Tracing* tracing) {
  delete tracing_;
  tracing_ = tracing;
  if (tracing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.tracing)
}

// .envoy.api.v2.RateLimitServiceConfig rate_limit_service = 10;
inline bool Bootstrap::has_rate_limit_service() const {
  return this != internal_default_instance() && rate_limit_service_ != NULL;
}
inline void Bootstrap::clear_rate_limit_service() {
  if (GetArenaNoVirtual() == NULL && rate_limit_service_ != NULL) delete rate_limit_service_;
  rate_limit_service_ = NULL;
}
inline const ::envoy::api::v2::RateLimitServiceConfig& Bootstrap::rate_limit_service() const {
  const ::envoy::api::v2::RateLimitServiceConfig* p = rate_limit_service_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.rate_limit_service)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RateLimitServiceConfig*>(
      &::envoy::api::v2::_RateLimitServiceConfig_default_instance_);
}
inline ::envoy::api::v2::RateLimitServiceConfig* Bootstrap::mutable_rate_limit_service() {
  
  if (rate_limit_service_ == NULL) {
    rate_limit_service_ = new ::envoy::api::v2::RateLimitServiceConfig;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.rate_limit_service)
  return rate_limit_service_;
}
inline ::envoy::api::v2::RateLimitServiceConfig* Bootstrap::release_rate_limit_service() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.rate_limit_service)
  
  ::envoy::api::v2::RateLimitServiceConfig* temp = rate_limit_service_;
  rate_limit_service_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_rate_limit_service(::envoy::api::v2::RateLimitServiceConfig* rate_limit_service) {
  delete rate_limit_service_;
  rate_limit_service_ = rate_limit_service;
  if (rate_limit_service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.rate_limit_service)
}

// .envoy.api.v2.Runtime runtime = 11;
inline bool Bootstrap::has_runtime() const {
  return this != internal_default_instance() && runtime_ != NULL;
}
inline void Bootstrap::clear_runtime() {
  if (GetArenaNoVirtual() == NULL && runtime_ != NULL) delete runtime_;
  runtime_ = NULL;
}
inline const ::envoy::api::v2::Runtime& Bootstrap::runtime() const {
  const ::envoy::api::v2::Runtime* p = runtime_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.runtime)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Runtime*>(
      &::envoy::api::v2::_Runtime_default_instance_);
}
inline ::envoy::api::v2::Runtime* Bootstrap::mutable_runtime() {
  
  if (runtime_ == NULL) {
    runtime_ = new ::envoy::api::v2::Runtime;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.runtime)
  return runtime_;
}
inline ::envoy::api::v2::Runtime* Bootstrap::release_runtime() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.runtime)
  
  ::envoy::api::v2::Runtime* temp = runtime_;
  runtime_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_runtime(::envoy::api::v2::Runtime* runtime) {
  delete runtime_;
  runtime_ = runtime;
  if (runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.runtime)
}

// .envoy.api.v2.Admin admin = 12;
inline bool Bootstrap::has_admin() const {
  return this != internal_default_instance() && admin_ != NULL;
}
inline void Bootstrap::clear_admin() {
  if (GetArenaNoVirtual() == NULL && admin_ != NULL) delete admin_;
  admin_ = NULL;
}
inline const ::envoy::api::v2::Admin& Bootstrap::admin() const {
  const ::envoy::api::v2::Admin* p = admin_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Bootstrap.admin)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Admin*>(
      &::envoy::api::v2::_Admin_default_instance_);
}
inline ::envoy::api::v2::Admin* Bootstrap::mutable_admin() {
  
  if (admin_ == NULL) {
    admin_ = new ::envoy::api::v2::Admin;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Bootstrap.admin)
  return admin_;
}
inline ::envoy::api::v2::Admin* Bootstrap::release_admin() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Bootstrap.admin)
  
  ::envoy::api::v2::Admin* temp = admin_;
  admin_ = NULL;
  return temp;
}
inline void Bootstrap::set_allocated_admin(::envoy::api::v2::Admin* admin) {
  delete admin_;
  admin_ = admin;
  if (admin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Bootstrap.admin)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace v2
}  // namespace api
}  // namespace envoy

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2fbootstrap_2eproto__INCLUDED
