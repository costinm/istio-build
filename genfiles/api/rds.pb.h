// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/rds.proto

#ifndef PROTOBUF_api_2frds_2eproto__INCLUDED
#define PROTOBUF_api_2frds_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "api/base.pb.h"
#include "api/discovery.pb.h"
#include "google/api/annotations.pb.h"
#include <google/protobuf/duration.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
namespace envoy {
namespace api {
namespace v2 {
class CorsPolicy;
class CorsPolicyDefaultTypeInternal;
extern CorsPolicyDefaultTypeInternal _CorsPolicy_default_instance_;
class Decorator;
class DecoratorDefaultTypeInternal;
extern DecoratorDefaultTypeInternal _Decorator_default_instance_;
class HeaderMatcher;
class HeaderMatcherDefaultTypeInternal;
extern HeaderMatcherDefaultTypeInternal _HeaderMatcher_default_instance_;
class RateLimit;
class RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class RateLimit_Action;
class RateLimit_ActionDefaultTypeInternal;
extern RateLimit_ActionDefaultTypeInternal _RateLimit_Action_default_instance_;
class RateLimit_Action_DestinationCluster;
class RateLimit_Action_DestinationClusterDefaultTypeInternal;
extern RateLimit_Action_DestinationClusterDefaultTypeInternal _RateLimit_Action_DestinationCluster_default_instance_;
class RateLimit_Action_GenericKey;
class RateLimit_Action_GenericKeyDefaultTypeInternal;
extern RateLimit_Action_GenericKeyDefaultTypeInternal _RateLimit_Action_GenericKey_default_instance_;
class RateLimit_Action_HeaderValueMatch;
class RateLimit_Action_HeaderValueMatchDefaultTypeInternal;
extern RateLimit_Action_HeaderValueMatchDefaultTypeInternal _RateLimit_Action_HeaderValueMatch_default_instance_;
class RateLimit_Action_RemoteAddress;
class RateLimit_Action_RemoteAddressDefaultTypeInternal;
extern RateLimit_Action_RemoteAddressDefaultTypeInternal _RateLimit_Action_RemoteAddress_default_instance_;
class RateLimit_Action_RequestHeaders;
class RateLimit_Action_RequestHeadersDefaultTypeInternal;
extern RateLimit_Action_RequestHeadersDefaultTypeInternal _RateLimit_Action_RequestHeaders_default_instance_;
class RateLimit_Action_SourceCluster;
class RateLimit_Action_SourceClusterDefaultTypeInternal;
extern RateLimit_Action_SourceClusterDefaultTypeInternal _RateLimit_Action_SourceCluster_default_instance_;
class RedirectAction;
class RedirectActionDefaultTypeInternal;
extern RedirectActionDefaultTypeInternal _RedirectAction_default_instance_;
class Route;
class RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class RouteAction;
class RouteActionDefaultTypeInternal;
extern RouteActionDefaultTypeInternal _RouteAction_default_instance_;
class RouteAction_HashPolicy;
class RouteAction_HashPolicyDefaultTypeInternal;
extern RouteAction_HashPolicyDefaultTypeInternal _RouteAction_HashPolicy_default_instance_;
class RouteAction_HashPolicy_ConnectionProperties;
class RouteAction_HashPolicy_ConnectionPropertiesDefaultTypeInternal;
extern RouteAction_HashPolicy_ConnectionPropertiesDefaultTypeInternal _RouteAction_HashPolicy_ConnectionProperties_default_instance_;
class RouteAction_HashPolicy_Cookie;
class RouteAction_HashPolicy_CookieDefaultTypeInternal;
extern RouteAction_HashPolicy_CookieDefaultTypeInternal _RouteAction_HashPolicy_Cookie_default_instance_;
class RouteAction_HashPolicy_Header;
class RouteAction_HashPolicy_HeaderDefaultTypeInternal;
extern RouteAction_HashPolicy_HeaderDefaultTypeInternal _RouteAction_HashPolicy_Header_default_instance_;
class RouteAction_RequestMirrorPolicy;
class RouteAction_RequestMirrorPolicyDefaultTypeInternal;
extern RouteAction_RequestMirrorPolicyDefaultTypeInternal _RouteAction_RequestMirrorPolicy_default_instance_;
class RouteAction_RetryPolicy;
class RouteAction_RetryPolicyDefaultTypeInternal;
extern RouteAction_RetryPolicyDefaultTypeInternal _RouteAction_RetryPolicy_default_instance_;
class RouteConfiguration;
class RouteConfigurationDefaultTypeInternal;
extern RouteConfigurationDefaultTypeInternal _RouteConfiguration_default_instance_;
class RouteMatch;
class RouteMatchDefaultTypeInternal;
extern RouteMatchDefaultTypeInternal _RouteMatch_default_instance_;
class VirtualCluster;
class VirtualClusterDefaultTypeInternal;
extern VirtualClusterDefaultTypeInternal _VirtualCluster_default_instance_;
class VirtualHost;
class VirtualHostDefaultTypeInternal;
extern VirtualHostDefaultTypeInternal _VirtualHost_default_instance_;
class WeightedCluster;
class WeightedClusterDefaultTypeInternal;
extern WeightedClusterDefaultTypeInternal _WeightedCluster_default_instance_;
class WeightedCluster_ClusterWeight;
class WeightedCluster_ClusterWeightDefaultTypeInternal;
extern WeightedCluster_ClusterWeightDefaultTypeInternal _WeightedCluster_ClusterWeight_default_instance_;
}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace envoy {
namespace api {
namespace v2 {

namespace protobuf_api_2frds_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_api_2frds_2eproto

enum VirtualHost_TlsRequirementType {
  VirtualHost_TlsRequirementType_NONE = 0,
  VirtualHost_TlsRequirementType_EXTERNAL_ONLY = 1,
  VirtualHost_TlsRequirementType_ALL = 2,
  VirtualHost_TlsRequirementType_VirtualHost_TlsRequirementType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VirtualHost_TlsRequirementType_VirtualHost_TlsRequirementType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VirtualHost_TlsRequirementType_IsValid(int value);
const VirtualHost_TlsRequirementType VirtualHost_TlsRequirementType_TlsRequirementType_MIN = VirtualHost_TlsRequirementType_NONE;
const VirtualHost_TlsRequirementType VirtualHost_TlsRequirementType_TlsRequirementType_MAX = VirtualHost_TlsRequirementType_ALL;
const int VirtualHost_TlsRequirementType_TlsRequirementType_ARRAYSIZE = VirtualHost_TlsRequirementType_TlsRequirementType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VirtualHost_TlsRequirementType_descriptor();
inline const ::std::string& VirtualHost_TlsRequirementType_Name(VirtualHost_TlsRequirementType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VirtualHost_TlsRequirementType_descriptor(), value);
}
inline bool VirtualHost_TlsRequirementType_Parse(
    const ::std::string& name, VirtualHost_TlsRequirementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VirtualHost_TlsRequirementType>(
    VirtualHost_TlsRequirementType_descriptor(), name, value);
}
// ===================================================================

class WeightedCluster_ClusterWeight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.WeightedCluster.ClusterWeight) */ {
 public:
  WeightedCluster_ClusterWeight();
  virtual ~WeightedCluster_ClusterWeight();

  WeightedCluster_ClusterWeight(const WeightedCluster_ClusterWeight& from);

  inline WeightedCluster_ClusterWeight& operator=(const WeightedCluster_ClusterWeight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeightedCluster_ClusterWeight(WeightedCluster_ClusterWeight&& from) noexcept
    : WeightedCluster_ClusterWeight() {
    *this = ::std::move(from);
  }

  inline WeightedCluster_ClusterWeight& operator=(WeightedCluster_ClusterWeight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightedCluster_ClusterWeight& default_instance();

  static inline const WeightedCluster_ClusterWeight* internal_default_instance() {
    return reinterpret_cast<const WeightedCluster_ClusterWeight*>(
               &_WeightedCluster_ClusterWeight_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(WeightedCluster_ClusterWeight* other);
  friend void swap(WeightedCluster_ClusterWeight& a, WeightedCluster_ClusterWeight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeightedCluster_ClusterWeight* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightedCluster_ClusterWeight* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeightedCluster_ClusterWeight& from);
  void MergeFrom(const WeightedCluster_ClusterWeight& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeightedCluster_ClusterWeight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.UInt32Value weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  const ::google::protobuf::UInt32Value& weight() const;
  ::google::protobuf::UInt32Value* mutable_weight();
  ::google::protobuf::UInt32Value* release_weight();
  void set_allocated_weight(::google::protobuf::UInt32Value* weight);

  // .envoy.api.v2.Metadata metadata_match = 3;
  bool has_metadata_match() const;
  void clear_metadata_match();
  static const int kMetadataMatchFieldNumber = 3;
  const ::envoy::api::v2::Metadata& metadata_match() const;
  ::envoy::api::v2::Metadata* mutable_metadata_match();
  ::envoy::api::v2::Metadata* release_metadata_match();
  void set_allocated_metadata_match(::envoy::api::v2::Metadata* metadata_match);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.WeightedCluster.ClusterWeight)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::UInt32Value* weight_;
  ::envoy::api::v2::Metadata* metadata_match_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeightedCluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.WeightedCluster) */ {
 public:
  WeightedCluster();
  virtual ~WeightedCluster();

  WeightedCluster(const WeightedCluster& from);

  inline WeightedCluster& operator=(const WeightedCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeightedCluster(WeightedCluster&& from) noexcept
    : WeightedCluster() {
    *this = ::std::move(from);
  }

  inline WeightedCluster& operator=(WeightedCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeightedCluster& default_instance();

  static inline const WeightedCluster* internal_default_instance() {
    return reinterpret_cast<const WeightedCluster*>(
               &_WeightedCluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(WeightedCluster* other);
  friend void swap(WeightedCluster& a, WeightedCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeightedCluster* New() const PROTOBUF_FINAL { return New(NULL); }

  WeightedCluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WeightedCluster& from);
  void MergeFrom(const WeightedCluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WeightedCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef WeightedCluster_ClusterWeight ClusterWeight;

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.WeightedCluster.ClusterWeight clusters = 1;
  int clusters_size() const;
  void clear_clusters();
  static const int kClustersFieldNumber = 1;
  const ::envoy::api::v2::WeightedCluster_ClusterWeight& clusters(int index) const;
  ::envoy::api::v2::WeightedCluster_ClusterWeight* mutable_clusters(int index);
  ::envoy::api::v2::WeightedCluster_ClusterWeight* add_clusters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::WeightedCluster_ClusterWeight >*
      mutable_clusters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::WeightedCluster_ClusterWeight >&
      clusters() const;

  // string runtime_key_prefix = 2;
  void clear_runtime_key_prefix();
  static const int kRuntimeKeyPrefixFieldNumber = 2;
  const ::std::string& runtime_key_prefix() const;
  void set_runtime_key_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_key_prefix(::std::string&& value);
  #endif
  void set_runtime_key_prefix(const char* value);
  void set_runtime_key_prefix(const char* value, size_t size);
  ::std::string* mutable_runtime_key_prefix();
  ::std::string* release_runtime_key_prefix();
  void set_allocated_runtime_key_prefix(::std::string* runtime_key_prefix);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.WeightedCluster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::WeightedCluster_ClusterWeight > clusters_;
  ::google::protobuf::internal::ArenaStringPtr runtime_key_prefix_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteMatch) */ {
 public:
  RouteMatch();
  virtual ~RouteMatch();

  RouteMatch(const RouteMatch& from);

  inline RouteMatch& operator=(const RouteMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteMatch(RouteMatch&& from) noexcept
    : RouteMatch() {
    *this = ::std::move(from);
  }

  inline RouteMatch& operator=(RouteMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteMatch& default_instance();

  enum PathSpecifierCase {
    kPrefix = 1,
    kPath = 2,
    kRegex = 3,
    PATH_SPECIFIER_NOT_SET = 0,
  };

  static inline const RouteMatch* internal_default_instance() {
    return reinterpret_cast<const RouteMatch*>(
               &_RouteMatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RouteMatch* other);
  friend void swap(RouteMatch& a, RouteMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteMatch* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteMatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteMatch& from);
  void MergeFrom(const RouteMatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.HeaderMatcher headers = 6;
  int headers_size() const;
  void clear_headers();
  static const int kHeadersFieldNumber = 6;
  const ::envoy::api::v2::HeaderMatcher& headers(int index) const;
  ::envoy::api::v2::HeaderMatcher* mutable_headers(int index);
  ::envoy::api::v2::HeaderMatcher* add_headers();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >*
      mutable_headers();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >&
      headers() const;

  // .google.protobuf.BoolValue case_sensitive = 4;
  bool has_case_sensitive() const;
  void clear_case_sensitive();
  static const int kCaseSensitiveFieldNumber = 4;
  const ::google::protobuf::BoolValue& case_sensitive() const;
  ::google::protobuf::BoolValue* mutable_case_sensitive();
  ::google::protobuf::BoolValue* release_case_sensitive();
  void set_allocated_case_sensitive(::google::protobuf::BoolValue* case_sensitive);

  // .envoy.api.v2.RuntimeUInt32 runtime = 5;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 5;
  const ::envoy::api::v2::RuntimeUInt32& runtime() const;
  ::envoy::api::v2::RuntimeUInt32* mutable_runtime();
  ::envoy::api::v2::RuntimeUInt32* release_runtime();
  void set_allocated_runtime(::envoy::api::v2::RuntimeUInt32* runtime);

  // string prefix = 1;
  private:
  bool has_prefix() const;
  public:
  void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  const ::std::string& prefix() const;
  void set_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix(::std::string&& value);
  #endif
  void set_prefix(const char* value);
  void set_prefix(const char* value, size_t size);
  ::std::string* mutable_prefix();
  ::std::string* release_prefix();
  void set_allocated_prefix(::std::string* prefix);

  // string path = 2;
  private:
  bool has_path() const;
  public:
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // string regex = 3;
  private:
  bool has_regex() const;
  public:
  void clear_regex();
  static const int kRegexFieldNumber = 3;
  const ::std::string& regex() const;
  void set_regex(const ::std::string& value);
  #if LANG_CXX11
  void set_regex(::std::string&& value);
  #endif
  void set_regex(const char* value);
  void set_regex(const char* value, size_t size);
  ::std::string* mutable_regex();
  ::std::string* release_regex();
  void set_allocated_regex(::std::string* regex);

  PathSpecifierCase path_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteMatch)
 private:
  void set_has_prefix();
  void set_has_path();
  void set_has_regex();

  inline bool has_path_specifier() const;
  void clear_path_specifier();
  inline void clear_has_path_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher > headers_;
  ::google::protobuf::BoolValue* case_sensitive_;
  ::envoy::api::v2::RuntimeUInt32* runtime_;
  union PathSpecifierUnion {
    PathSpecifierUnion() {}
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr regex_;
  } path_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CorsPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.CorsPolicy) */ {
 public:
  CorsPolicy();
  virtual ~CorsPolicy();

  CorsPolicy(const CorsPolicy& from);

  inline CorsPolicy& operator=(const CorsPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CorsPolicy(CorsPolicy&& from) noexcept
    : CorsPolicy() {
    *this = ::std::move(from);
  }

  inline CorsPolicy& operator=(CorsPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CorsPolicy& default_instance();

  static inline const CorsPolicy* internal_default_instance() {
    return reinterpret_cast<const CorsPolicy*>(
               &_CorsPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(CorsPolicy* other);
  friend void swap(CorsPolicy& a, CorsPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CorsPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  CorsPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CorsPolicy& from);
  void MergeFrom(const CorsPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CorsPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string allow_origin = 1;
  int allow_origin_size() const;
  void clear_allow_origin();
  static const int kAllowOriginFieldNumber = 1;
  const ::std::string& allow_origin(int index) const;
  ::std::string* mutable_allow_origin(int index);
  void set_allow_origin(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_allow_origin(int index, ::std::string&& value);
  #endif
  void set_allow_origin(int index, const char* value);
  void set_allow_origin(int index, const char* value, size_t size);
  ::std::string* add_allow_origin();
  void add_allow_origin(const ::std::string& value);
  #if LANG_CXX11
  void add_allow_origin(::std::string&& value);
  #endif
  void add_allow_origin(const char* value);
  void add_allow_origin(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& allow_origin() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_allow_origin();

  // string allow_methods = 2;
  void clear_allow_methods();
  static const int kAllowMethodsFieldNumber = 2;
  const ::std::string& allow_methods() const;
  void set_allow_methods(const ::std::string& value);
  #if LANG_CXX11
  void set_allow_methods(::std::string&& value);
  #endif
  void set_allow_methods(const char* value);
  void set_allow_methods(const char* value, size_t size);
  ::std::string* mutable_allow_methods();
  ::std::string* release_allow_methods();
  void set_allocated_allow_methods(::std::string* allow_methods);

  // string allow_headers = 3;
  void clear_allow_headers();
  static const int kAllowHeadersFieldNumber = 3;
  const ::std::string& allow_headers() const;
  void set_allow_headers(const ::std::string& value);
  #if LANG_CXX11
  void set_allow_headers(::std::string&& value);
  #endif
  void set_allow_headers(const char* value);
  void set_allow_headers(const char* value, size_t size);
  ::std::string* mutable_allow_headers();
  ::std::string* release_allow_headers();
  void set_allocated_allow_headers(::std::string* allow_headers);

  // string expose_headers = 4;
  void clear_expose_headers();
  static const int kExposeHeadersFieldNumber = 4;
  const ::std::string& expose_headers() const;
  void set_expose_headers(const ::std::string& value);
  #if LANG_CXX11
  void set_expose_headers(::std::string&& value);
  #endif
  void set_expose_headers(const char* value);
  void set_expose_headers(const char* value, size_t size);
  ::std::string* mutable_expose_headers();
  ::std::string* release_expose_headers();
  void set_allocated_expose_headers(::std::string* expose_headers);

  // string max_age = 5;
  void clear_max_age();
  static const int kMaxAgeFieldNumber = 5;
  const ::std::string& max_age() const;
  void set_max_age(const ::std::string& value);
  #if LANG_CXX11
  void set_max_age(::std::string&& value);
  #endif
  void set_max_age(const char* value);
  void set_max_age(const char* value, size_t size);
  ::std::string* mutable_max_age();
  ::std::string* release_max_age();
  void set_allocated_max_age(::std::string* max_age);

  // .google.protobuf.BoolValue allow_credentials = 6;
  bool has_allow_credentials() const;
  void clear_allow_credentials();
  static const int kAllowCredentialsFieldNumber = 6;
  const ::google::protobuf::BoolValue& allow_credentials() const;
  ::google::protobuf::BoolValue* mutable_allow_credentials();
  ::google::protobuf::BoolValue* release_allow_credentials();
  void set_allocated_allow_credentials(::google::protobuf::BoolValue* allow_credentials);

  // .google.protobuf.BoolValue enabled = 7;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 7;
  const ::google::protobuf::BoolValue& enabled() const;
  ::google::protobuf::BoolValue* mutable_enabled();
  ::google::protobuf::BoolValue* release_enabled();
  void set_allocated_enabled(::google::protobuf::BoolValue* enabled);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.CorsPolicy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> allow_origin_;
  ::google::protobuf::internal::ArenaStringPtr allow_methods_;
  ::google::protobuf::internal::ArenaStringPtr allow_headers_;
  ::google::protobuf::internal::ArenaStringPtr expose_headers_;
  ::google::protobuf::internal::ArenaStringPtr max_age_;
  ::google::protobuf::BoolValue* allow_credentials_;
  ::google::protobuf::BoolValue* enabled_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_RetryPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.RetryPolicy) */ {
 public:
  RouteAction_RetryPolicy();
  virtual ~RouteAction_RetryPolicy();

  RouteAction_RetryPolicy(const RouteAction_RetryPolicy& from);

  inline RouteAction_RetryPolicy& operator=(const RouteAction_RetryPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_RetryPolicy(RouteAction_RetryPolicy&& from) noexcept
    : RouteAction_RetryPolicy() {
    *this = ::std::move(from);
  }

  inline RouteAction_RetryPolicy& operator=(RouteAction_RetryPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_RetryPolicy& default_instance();

  static inline const RouteAction_RetryPolicy* internal_default_instance() {
    return reinterpret_cast<const RouteAction_RetryPolicy*>(
               &_RouteAction_RetryPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RouteAction_RetryPolicy* other);
  friend void swap(RouteAction_RetryPolicy& a, RouteAction_RetryPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_RetryPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_RetryPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_RetryPolicy& from);
  void MergeFrom(const RouteAction_RetryPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_RetryPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string retry_on = 1;
  void clear_retry_on();
  static const int kRetryOnFieldNumber = 1;
  const ::std::string& retry_on() const;
  void set_retry_on(const ::std::string& value);
  #if LANG_CXX11
  void set_retry_on(::std::string&& value);
  #endif
  void set_retry_on(const char* value);
  void set_retry_on(const char* value, size_t size);
  ::std::string* mutable_retry_on();
  ::std::string* release_retry_on();
  void set_allocated_retry_on(::std::string* retry_on);

  // .google.protobuf.UInt32Value num_retries = 2;
  bool has_num_retries() const;
  void clear_num_retries();
  static const int kNumRetriesFieldNumber = 2;
  const ::google::protobuf::UInt32Value& num_retries() const;
  ::google::protobuf::UInt32Value* mutable_num_retries();
  ::google::protobuf::UInt32Value* release_num_retries();
  void set_allocated_num_retries(::google::protobuf::UInt32Value* num_retries);

  // .google.protobuf.Duration per_try_timeout = 3;
  bool has_per_try_timeout() const;
  void clear_per_try_timeout();
  static const int kPerTryTimeoutFieldNumber = 3;
  const ::google::protobuf::Duration& per_try_timeout() const;
  ::google::protobuf::Duration* mutable_per_try_timeout();
  ::google::protobuf::Duration* release_per_try_timeout();
  void set_allocated_per_try_timeout(::google::protobuf::Duration* per_try_timeout);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.RetryPolicy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr retry_on_;
  ::google::protobuf::UInt32Value* num_retries_;
  ::google::protobuf::Duration* per_try_timeout_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_RequestMirrorPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.RequestMirrorPolicy) */ {
 public:
  RouteAction_RequestMirrorPolicy();
  virtual ~RouteAction_RequestMirrorPolicy();

  RouteAction_RequestMirrorPolicy(const RouteAction_RequestMirrorPolicy& from);

  inline RouteAction_RequestMirrorPolicy& operator=(const RouteAction_RequestMirrorPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_RequestMirrorPolicy(RouteAction_RequestMirrorPolicy&& from) noexcept
    : RouteAction_RequestMirrorPolicy() {
    *this = ::std::move(from);
  }

  inline RouteAction_RequestMirrorPolicy& operator=(RouteAction_RequestMirrorPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_RequestMirrorPolicy& default_instance();

  static inline const RouteAction_RequestMirrorPolicy* internal_default_instance() {
    return reinterpret_cast<const RouteAction_RequestMirrorPolicy*>(
               &_RouteAction_RequestMirrorPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RouteAction_RequestMirrorPolicy* other);
  friend void swap(RouteAction_RequestMirrorPolicy& a, RouteAction_RequestMirrorPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_RequestMirrorPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_RequestMirrorPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_RequestMirrorPolicy& from);
  void MergeFrom(const RouteAction_RequestMirrorPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_RequestMirrorPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string cluster = 1;
  void clear_cluster();
  static const int kClusterFieldNumber = 1;
  const ::std::string& cluster() const;
  void set_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster(::std::string&& value);
  #endif
  void set_cluster(const char* value);
  void set_cluster(const char* value, size_t size);
  ::std::string* mutable_cluster();
  ::std::string* release_cluster();
  void set_allocated_cluster(::std::string* cluster);

  // string runtime_key = 2;
  void clear_runtime_key();
  static const int kRuntimeKeyFieldNumber = 2;
  const ::std::string& runtime_key() const;
  void set_runtime_key(const ::std::string& value);
  #if LANG_CXX11
  void set_runtime_key(::std::string&& value);
  #endif
  void set_runtime_key(const char* value);
  void set_runtime_key(const char* value, size_t size);
  ::std::string* mutable_runtime_key();
  ::std::string* release_runtime_key();
  void set_allocated_runtime_key(::std::string* runtime_key);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.RequestMirrorPolicy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr cluster_;
  ::google::protobuf::internal::ArenaStringPtr runtime_key_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_HashPolicy_Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.HashPolicy.Header) */ {
 public:
  RouteAction_HashPolicy_Header();
  virtual ~RouteAction_HashPolicy_Header();

  RouteAction_HashPolicy_Header(const RouteAction_HashPolicy_Header& from);

  inline RouteAction_HashPolicy_Header& operator=(const RouteAction_HashPolicy_Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_HashPolicy_Header(RouteAction_HashPolicy_Header&& from) noexcept
    : RouteAction_HashPolicy_Header() {
    *this = ::std::move(from);
  }

  inline RouteAction_HashPolicy_Header& operator=(RouteAction_HashPolicy_Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_HashPolicy_Header& default_instance();

  static inline const RouteAction_HashPolicy_Header* internal_default_instance() {
    return reinterpret_cast<const RouteAction_HashPolicy_Header*>(
               &_RouteAction_HashPolicy_Header_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(RouteAction_HashPolicy_Header* other);
  friend void swap(RouteAction_HashPolicy_Header& a, RouteAction_HashPolicy_Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_HashPolicy_Header* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_HashPolicy_Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_HashPolicy_Header& from);
  void MergeFrom(const RouteAction_HashPolicy_Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_HashPolicy_Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string header_name = 1;
  void clear_header_name();
  static const int kHeaderNameFieldNumber = 1;
  const ::std::string& header_name() const;
  void set_header_name(const ::std::string& value);
  #if LANG_CXX11
  void set_header_name(::std::string&& value);
  #endif
  void set_header_name(const char* value);
  void set_header_name(const char* value, size_t size);
  ::std::string* mutable_header_name();
  ::std::string* release_header_name();
  void set_allocated_header_name(::std::string* header_name);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.HashPolicy.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr header_name_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_HashPolicy_Cookie : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.HashPolicy.Cookie) */ {
 public:
  RouteAction_HashPolicy_Cookie();
  virtual ~RouteAction_HashPolicy_Cookie();

  RouteAction_HashPolicy_Cookie(const RouteAction_HashPolicy_Cookie& from);

  inline RouteAction_HashPolicy_Cookie& operator=(const RouteAction_HashPolicy_Cookie& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_HashPolicy_Cookie(RouteAction_HashPolicy_Cookie&& from) noexcept
    : RouteAction_HashPolicy_Cookie() {
    *this = ::std::move(from);
  }

  inline RouteAction_HashPolicy_Cookie& operator=(RouteAction_HashPolicy_Cookie&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_HashPolicy_Cookie& default_instance();

  static inline const RouteAction_HashPolicy_Cookie* internal_default_instance() {
    return reinterpret_cast<const RouteAction_HashPolicy_Cookie*>(
               &_RouteAction_HashPolicy_Cookie_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(RouteAction_HashPolicy_Cookie* other);
  friend void swap(RouteAction_HashPolicy_Cookie& a, RouteAction_HashPolicy_Cookie& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_HashPolicy_Cookie* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_HashPolicy_Cookie* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_HashPolicy_Cookie& from);
  void MergeFrom(const RouteAction_HashPolicy_Cookie& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_HashPolicy_Cookie* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.Duration ttl = 2;
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 2;
  const ::google::protobuf::Duration& ttl() const;
  ::google::protobuf::Duration* mutable_ttl();
  ::google::protobuf::Duration* release_ttl();
  void set_allocated_ttl(::google::protobuf::Duration* ttl);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.HashPolicy.Cookie)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::Duration* ttl_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_HashPolicy_ConnectionProperties : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties) */ {
 public:
  RouteAction_HashPolicy_ConnectionProperties();
  virtual ~RouteAction_HashPolicy_ConnectionProperties();

  RouteAction_HashPolicy_ConnectionProperties(const RouteAction_HashPolicy_ConnectionProperties& from);

  inline RouteAction_HashPolicy_ConnectionProperties& operator=(const RouteAction_HashPolicy_ConnectionProperties& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_HashPolicy_ConnectionProperties(RouteAction_HashPolicy_ConnectionProperties&& from) noexcept
    : RouteAction_HashPolicy_ConnectionProperties() {
    *this = ::std::move(from);
  }

  inline RouteAction_HashPolicy_ConnectionProperties& operator=(RouteAction_HashPolicy_ConnectionProperties&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_HashPolicy_ConnectionProperties& default_instance();

  static inline const RouteAction_HashPolicy_ConnectionProperties* internal_default_instance() {
    return reinterpret_cast<const RouteAction_HashPolicy_ConnectionProperties*>(
               &_RouteAction_HashPolicy_ConnectionProperties_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(RouteAction_HashPolicy_ConnectionProperties* other);
  friend void swap(RouteAction_HashPolicy_ConnectionProperties& a, RouteAction_HashPolicy_ConnectionProperties& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_HashPolicy_ConnectionProperties* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_HashPolicy_ConnectionProperties* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_HashPolicy_ConnectionProperties& from);
  void MergeFrom(const RouteAction_HashPolicy_ConnectionProperties& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_HashPolicy_ConnectionProperties* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool source_ip = 1;
  void clear_source_ip();
  static const int kSourceIpFieldNumber = 1;
  bool source_ip() const;
  void set_source_ip(bool value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool source_ip_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction_HashPolicy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction.HashPolicy) */ {
 public:
  RouteAction_HashPolicy();
  virtual ~RouteAction_HashPolicy();

  RouteAction_HashPolicy(const RouteAction_HashPolicy& from);

  inline RouteAction_HashPolicy& operator=(const RouteAction_HashPolicy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction_HashPolicy(RouteAction_HashPolicy&& from) noexcept
    : RouteAction_HashPolicy() {
    *this = ::std::move(from);
  }

  inline RouteAction_HashPolicy& operator=(RouteAction_HashPolicy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction_HashPolicy& default_instance();

  enum PolicySpecifierCase {
    kHeader = 1,
    kCookie = 2,
    kConnectionProperties = 3,
    POLICY_SPECIFIER_NOT_SET = 0,
  };

  static inline const RouteAction_HashPolicy* internal_default_instance() {
    return reinterpret_cast<const RouteAction_HashPolicy*>(
               &_RouteAction_HashPolicy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RouteAction_HashPolicy* other);
  friend void swap(RouteAction_HashPolicy& a, RouteAction_HashPolicy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction_HashPolicy* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction_HashPolicy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction_HashPolicy& from);
  void MergeFrom(const RouteAction_HashPolicy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction_HashPolicy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RouteAction_HashPolicy_Header Header;
  typedef RouteAction_HashPolicy_Cookie Cookie;
  typedef RouteAction_HashPolicy_ConnectionProperties ConnectionProperties;

  // accessors -------------------------------------------------------

  // .envoy.api.v2.RouteAction.HashPolicy.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::envoy::api::v2::RouteAction_HashPolicy_Header& header() const;
  ::envoy::api::v2::RouteAction_HashPolicy_Header* mutable_header();
  ::envoy::api::v2::RouteAction_HashPolicy_Header* release_header();
  void set_allocated_header(::envoy::api::v2::RouteAction_HashPolicy_Header* header);

  // .envoy.api.v2.RouteAction.HashPolicy.Cookie cookie = 2;
  bool has_cookie() const;
  void clear_cookie();
  static const int kCookieFieldNumber = 2;
  const ::envoy::api::v2::RouteAction_HashPolicy_Cookie& cookie() const;
  ::envoy::api::v2::RouteAction_HashPolicy_Cookie* mutable_cookie();
  ::envoy::api::v2::RouteAction_HashPolicy_Cookie* release_cookie();
  void set_allocated_cookie(::envoy::api::v2::RouteAction_HashPolicy_Cookie* cookie);

  // .envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;
  bool has_connection_properties() const;
  void clear_connection_properties();
  static const int kConnectionPropertiesFieldNumber = 3;
  const ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties& connection_properties() const;
  ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* mutable_connection_properties();
  ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* release_connection_properties();
  void set_allocated_connection_properties(::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* connection_properties);

  PolicySpecifierCase policy_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction.HashPolicy)
 private:
  void set_has_header();
  void set_has_cookie();
  void set_has_connection_properties();

  inline bool has_policy_specifier() const;
  void clear_policy_specifier();
  inline void clear_has_policy_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union PolicySpecifierUnion {
    PolicySpecifierUnion() {}
    ::envoy::api::v2::RouteAction_HashPolicy_Header* header_;
    ::envoy::api::v2::RouteAction_HashPolicy_Cookie* cookie_;
    ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* connection_properties_;
  } policy_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteAction) */ {
 public:
  RouteAction();
  virtual ~RouteAction();

  RouteAction(const RouteAction& from);

  inline RouteAction& operator=(const RouteAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteAction(RouteAction&& from) noexcept
    : RouteAction() {
    *this = ::std::move(from);
  }

  inline RouteAction& operator=(RouteAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteAction& default_instance();

  enum ClusterSpecifierCase {
    kCluster = 1,
    kClusterHeader = 2,
    kWeightedClusters = 3,
    CLUSTER_SPECIFIER_NOT_SET = 0,
  };

  enum HostRewriteSpecifierCase {
    kHostRewrite = 6,
    kAutoHostRewrite = 7,
    HOST_REWRITE_SPECIFIER_NOT_SET = 0,
  };

  static inline const RouteAction* internal_default_instance() {
    return reinterpret_cast<const RouteAction*>(
               &_RouteAction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(RouteAction* other);
  friend void swap(RouteAction& a, RouteAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteAction* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteAction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteAction& from);
  void MergeFrom(const RouteAction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RouteAction_RetryPolicy RetryPolicy;
  typedef RouteAction_RequestMirrorPolicy RequestMirrorPolicy;
  typedef RouteAction_HashPolicy HashPolicy;

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 12;
  int request_headers_to_add_size() const;
  void clear_request_headers_to_add();
  static const int kRequestHeadersToAddFieldNumber = 12;
  const ::envoy::api::v2::HeaderValueOption& request_headers_to_add(int index) const;
  ::envoy::api::v2::HeaderValueOption* mutable_request_headers_to_add(int index);
  ::envoy::api::v2::HeaderValueOption* add_request_headers_to_add();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
      mutable_request_headers_to_add();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
      request_headers_to_add() const;

  // repeated .envoy.api.v2.RateLimit rate_limits = 13;
  int rate_limits_size() const;
  void clear_rate_limits();
  static const int kRateLimitsFieldNumber = 13;
  const ::envoy::api::v2::RateLimit& rate_limits(int index) const;
  ::envoy::api::v2::RateLimit* mutable_rate_limits(int index);
  ::envoy::api::v2::RateLimit* add_rate_limits();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >*
      mutable_rate_limits();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >&
      rate_limits() const;

  // repeated .envoy.api.v2.RouteAction.HashPolicy hash_policy = 15;
  int hash_policy_size() const;
  void clear_hash_policy();
  static const int kHashPolicyFieldNumber = 15;
  const ::envoy::api::v2::RouteAction_HashPolicy& hash_policy(int index) const;
  ::envoy::api::v2::RouteAction_HashPolicy* mutable_hash_policy(int index);
  ::envoy::api::v2::RouteAction_HashPolicy* add_hash_policy();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RouteAction_HashPolicy >*
      mutable_hash_policy();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RouteAction_HashPolicy >&
      hash_policy() const;

  // string prefix_rewrite = 5;
  void clear_prefix_rewrite();
  static const int kPrefixRewriteFieldNumber = 5;
  const ::std::string& prefix_rewrite() const;
  void set_prefix_rewrite(const ::std::string& value);
  #if LANG_CXX11
  void set_prefix_rewrite(::std::string&& value);
  #endif
  void set_prefix_rewrite(const char* value);
  void set_prefix_rewrite(const char* value, size_t size);
  ::std::string* mutable_prefix_rewrite();
  ::std::string* release_prefix_rewrite();
  void set_allocated_prefix_rewrite(::std::string* prefix_rewrite);

  // .envoy.api.v2.Metadata metadata_match = 4;
  bool has_metadata_match() const;
  void clear_metadata_match();
  static const int kMetadataMatchFieldNumber = 4;
  const ::envoy::api::v2::Metadata& metadata_match() const;
  ::envoy::api::v2::Metadata* mutable_metadata_match();
  ::envoy::api::v2::Metadata* release_metadata_match();
  void set_allocated_metadata_match(::envoy::api::v2::Metadata* metadata_match);

  // .google.protobuf.Duration timeout = 8;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 8;
  const ::google::protobuf::Duration& timeout() const;
  ::google::protobuf::Duration* mutable_timeout();
  ::google::protobuf::Duration* release_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* timeout);

  // .envoy.api.v2.RouteAction.RetryPolicy retry_policy = 9;
  bool has_retry_policy() const;
  void clear_retry_policy();
  static const int kRetryPolicyFieldNumber = 9;
  const ::envoy::api::v2::RouteAction_RetryPolicy& retry_policy() const;
  ::envoy::api::v2::RouteAction_RetryPolicy* mutable_retry_policy();
  ::envoy::api::v2::RouteAction_RetryPolicy* release_retry_policy();
  void set_allocated_retry_policy(::envoy::api::v2::RouteAction_RetryPolicy* retry_policy);

  // .envoy.api.v2.RouteAction.RequestMirrorPolicy request_mirror_policy = 10;
  bool has_request_mirror_policy() const;
  void clear_request_mirror_policy();
  static const int kRequestMirrorPolicyFieldNumber = 10;
  const ::envoy::api::v2::RouteAction_RequestMirrorPolicy& request_mirror_policy() const;
  ::envoy::api::v2::RouteAction_RequestMirrorPolicy* mutable_request_mirror_policy();
  ::envoy::api::v2::RouteAction_RequestMirrorPolicy* release_request_mirror_policy();
  void set_allocated_request_mirror_policy(::envoy::api::v2::RouteAction_RequestMirrorPolicy* request_mirror_policy);

  // .google.protobuf.BoolValue include_vh_rate_limits = 14;
  bool has_include_vh_rate_limits() const;
  void clear_include_vh_rate_limits();
  static const int kIncludeVhRateLimitsFieldNumber = 14;
  const ::google::protobuf::BoolValue& include_vh_rate_limits() const;
  ::google::protobuf::BoolValue* mutable_include_vh_rate_limits();
  ::google::protobuf::BoolValue* release_include_vh_rate_limits();
  void set_allocated_include_vh_rate_limits(::google::protobuf::BoolValue* include_vh_rate_limits);

  // .google.protobuf.BoolValue use_websocket = 16;
  bool has_use_websocket() const;
  void clear_use_websocket();
  static const int kUseWebsocketFieldNumber = 16;
  const ::google::protobuf::BoolValue& use_websocket() const;
  ::google::protobuf::BoolValue* mutable_use_websocket();
  ::google::protobuf::BoolValue* release_use_websocket();
  void set_allocated_use_websocket(::google::protobuf::BoolValue* use_websocket);

  // .envoy.api.v2.CorsPolicy cors = 17;
  bool has_cors() const;
  void clear_cors();
  static const int kCorsFieldNumber = 17;
  const ::envoy::api::v2::CorsPolicy& cors() const;
  ::envoy::api::v2::CorsPolicy* mutable_cors();
  ::envoy::api::v2::CorsPolicy* release_cors();
  void set_allocated_cors(::envoy::api::v2::CorsPolicy* cors);

  // .envoy.api.v2.RoutingPriority priority = 11;
  void clear_priority();
  static const int kPriorityFieldNumber = 11;
  ::envoy::api::v2::RoutingPriority priority() const;
  void set_priority(::envoy::api::v2::RoutingPriority value);

  // string cluster = 1;
  private:
  bool has_cluster() const;
  public:
  void clear_cluster();
  static const int kClusterFieldNumber = 1;
  const ::std::string& cluster() const;
  void set_cluster(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster(::std::string&& value);
  #endif
  void set_cluster(const char* value);
  void set_cluster(const char* value, size_t size);
  ::std::string* mutable_cluster();
  ::std::string* release_cluster();
  void set_allocated_cluster(::std::string* cluster);

  // string cluster_header = 2;
  private:
  bool has_cluster_header() const;
  public:
  void clear_cluster_header();
  static const int kClusterHeaderFieldNumber = 2;
  const ::std::string& cluster_header() const;
  void set_cluster_header(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_header(::std::string&& value);
  #endif
  void set_cluster_header(const char* value);
  void set_cluster_header(const char* value, size_t size);
  ::std::string* mutable_cluster_header();
  ::std::string* release_cluster_header();
  void set_allocated_cluster_header(::std::string* cluster_header);

  // .envoy.api.v2.WeightedCluster weighted_clusters = 3;
  bool has_weighted_clusters() const;
  void clear_weighted_clusters();
  static const int kWeightedClustersFieldNumber = 3;
  const ::envoy::api::v2::WeightedCluster& weighted_clusters() const;
  ::envoy::api::v2::WeightedCluster* mutable_weighted_clusters();
  ::envoy::api::v2::WeightedCluster* release_weighted_clusters();
  void set_allocated_weighted_clusters(::envoy::api::v2::WeightedCluster* weighted_clusters);

  // string host_rewrite = 6;
  private:
  bool has_host_rewrite() const;
  public:
  void clear_host_rewrite();
  static const int kHostRewriteFieldNumber = 6;
  const ::std::string& host_rewrite() const;
  void set_host_rewrite(const ::std::string& value);
  #if LANG_CXX11
  void set_host_rewrite(::std::string&& value);
  #endif
  void set_host_rewrite(const char* value);
  void set_host_rewrite(const char* value, size_t size);
  ::std::string* mutable_host_rewrite();
  ::std::string* release_host_rewrite();
  void set_allocated_host_rewrite(::std::string* host_rewrite);

  // .google.protobuf.BoolValue auto_host_rewrite = 7;
  bool has_auto_host_rewrite() const;
  void clear_auto_host_rewrite();
  static const int kAutoHostRewriteFieldNumber = 7;
  const ::google::protobuf::BoolValue& auto_host_rewrite() const;
  ::google::protobuf::BoolValue* mutable_auto_host_rewrite();
  ::google::protobuf::BoolValue* release_auto_host_rewrite();
  void set_allocated_auto_host_rewrite(::google::protobuf::BoolValue* auto_host_rewrite);

  ClusterSpecifierCase cluster_specifier_case() const;
  HostRewriteSpecifierCase host_rewrite_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteAction)
 private:
  void set_has_cluster();
  void set_has_cluster_header();
  void set_has_weighted_clusters();
  void set_has_host_rewrite();
  void set_has_auto_host_rewrite();

  inline bool has_cluster_specifier() const;
  void clear_cluster_specifier();
  inline void clear_has_cluster_specifier();

  inline bool has_host_rewrite_specifier() const;
  void clear_host_rewrite_specifier();
  inline void clear_has_host_rewrite_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption > request_headers_to_add_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit > rate_limits_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RouteAction_HashPolicy > hash_policy_;
  ::google::protobuf::internal::ArenaStringPtr prefix_rewrite_;
  ::envoy::api::v2::Metadata* metadata_match_;
  ::google::protobuf::Duration* timeout_;
  ::envoy::api::v2::RouteAction_RetryPolicy* retry_policy_;
  ::envoy::api::v2::RouteAction_RequestMirrorPolicy* request_mirror_policy_;
  ::google::protobuf::BoolValue* include_vh_rate_limits_;
  ::google::protobuf::BoolValue* use_websocket_;
  ::envoy::api::v2::CorsPolicy* cors_;
  int priority_;
  union ClusterSpecifierUnion {
    ClusterSpecifierUnion() {}
    ::google::protobuf::internal::ArenaStringPtr cluster_;
    ::google::protobuf::internal::ArenaStringPtr cluster_header_;
    ::envoy::api::v2::WeightedCluster* weighted_clusters_;
  } cluster_specifier_;
  union HostRewriteSpecifierUnion {
    HostRewriteSpecifierUnion() {}
    ::google::protobuf::internal::ArenaStringPtr host_rewrite_;
    ::google::protobuf::BoolValue* auto_host_rewrite_;
  } host_rewrite_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RedirectAction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RedirectAction) */ {
 public:
  RedirectAction();
  virtual ~RedirectAction();

  RedirectAction(const RedirectAction& from);

  inline RedirectAction& operator=(const RedirectAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RedirectAction(RedirectAction&& from) noexcept
    : RedirectAction() {
    *this = ::std::move(from);
  }

  inline RedirectAction& operator=(RedirectAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RedirectAction& default_instance();

  static inline const RedirectAction* internal_default_instance() {
    return reinterpret_cast<const RedirectAction*>(
               &_RedirectAction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(RedirectAction* other);
  friend void swap(RedirectAction& a, RedirectAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RedirectAction* New() const PROTOBUF_FINAL { return New(NULL); }

  RedirectAction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RedirectAction& from);
  void MergeFrom(const RedirectAction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RedirectAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host_redirect = 1;
  void clear_host_redirect();
  static const int kHostRedirectFieldNumber = 1;
  const ::std::string& host_redirect() const;
  void set_host_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_host_redirect(::std::string&& value);
  #endif
  void set_host_redirect(const char* value);
  void set_host_redirect(const char* value, size_t size);
  ::std::string* mutable_host_redirect();
  ::std::string* release_host_redirect();
  void set_allocated_host_redirect(::std::string* host_redirect);

  // string path_redirect = 2;
  void clear_path_redirect();
  static const int kPathRedirectFieldNumber = 2;
  const ::std::string& path_redirect() const;
  void set_path_redirect(const ::std::string& value);
  #if LANG_CXX11
  void set_path_redirect(::std::string&& value);
  #endif
  void set_path_redirect(const char* value);
  void set_path_redirect(const char* value, size_t size);
  ::std::string* mutable_path_redirect();
  ::std::string* release_path_redirect();
  void set_allocated_path_redirect(::std::string* path_redirect);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RedirectAction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_redirect_;
  ::google::protobuf::internal::ArenaStringPtr path_redirect_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Decorator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Decorator) */ {
 public:
  Decorator();
  virtual ~Decorator();

  Decorator(const Decorator& from);

  inline Decorator& operator=(const Decorator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Decorator(Decorator&& from) noexcept
    : Decorator() {
    *this = ::std::move(from);
  }

  inline Decorator& operator=(Decorator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Decorator& default_instance();

  static inline const Decorator* internal_default_instance() {
    return reinterpret_cast<const Decorator*>(
               &_Decorator_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(Decorator* other);
  friend void swap(Decorator& a, Decorator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Decorator* New() const PROTOBUF_FINAL { return New(NULL); }

  Decorator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Decorator& from);
  void MergeFrom(const Decorator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Decorator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string operation = 1;
  void clear_operation();
  static const int kOperationFieldNumber = 1;
  const ::std::string& operation() const;
  void set_operation(const ::std::string& value);
  #if LANG_CXX11
  void set_operation(::std::string&& value);
  #endif
  void set_operation(const char* value);
  void set_operation(const char* value, size_t size);
  ::std::string* mutable_operation();
  ::std::string* release_operation();
  void set_allocated_operation(::std::string* operation);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.Decorator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr operation_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Route : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.Route) */ {
 public:
  Route();
  virtual ~Route();

  Route(const Route& from);

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(Route&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Route& default_instance();

  enum ActionCase {
    kRoute = 2,
    kRedirect = 3,
    ACTION_NOT_SET = 0,
  };

  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(Route* other);
  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Route* New() const PROTOBUF_FINAL { return New(NULL); }

  Route* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Route& from);
  void MergeFrom(const Route& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Route* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .envoy.api.v2.RouteMatch match = 1;
  bool has_match() const;
  void clear_match();
  static const int kMatchFieldNumber = 1;
  const ::envoy::api::v2::RouteMatch& match() const;
  ::envoy::api::v2::RouteMatch* mutable_match();
  ::envoy::api::v2::RouteMatch* release_match();
  void set_allocated_match(::envoy::api::v2::RouteMatch* match);

  // .envoy.api.v2.Metadata metadata = 4;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 4;
  const ::envoy::api::v2::Metadata& metadata() const;
  ::envoy::api::v2::Metadata* mutable_metadata();
  ::envoy::api::v2::Metadata* release_metadata();
  void set_allocated_metadata(::envoy::api::v2::Metadata* metadata);

  // .envoy.api.v2.Decorator decorator = 5;
  bool has_decorator() const;
  void clear_decorator();
  static const int kDecoratorFieldNumber = 5;
  const ::envoy::api::v2::Decorator& decorator() const;
  ::envoy::api::v2::Decorator* mutable_decorator();
  ::envoy::api::v2::Decorator* release_decorator();
  void set_allocated_decorator(::envoy::api::v2::Decorator* decorator);

  // .envoy.api.v2.RouteAction route = 2;
  bool has_route() const;
  void clear_route();
  static const int kRouteFieldNumber = 2;
  const ::envoy::api::v2::RouteAction& route() const;
  ::envoy::api::v2::RouteAction* mutable_route();
  ::envoy::api::v2::RouteAction* release_route();
  void set_allocated_route(::envoy::api::v2::RouteAction* route);

  // .envoy.api.v2.RedirectAction redirect = 3;
  bool has_redirect() const;
  void clear_redirect();
  static const int kRedirectFieldNumber = 3;
  const ::envoy::api::v2::RedirectAction& redirect() const;
  ::envoy::api::v2::RedirectAction* mutable_redirect();
  ::envoy::api::v2::RedirectAction* release_redirect();
  void set_allocated_redirect(::envoy::api::v2::RedirectAction* redirect);

  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.Route)
 private:
  void set_has_route();
  void set_has_redirect();

  inline bool has_action() const;
  void clear_action();
  inline void clear_has_action();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::envoy::api::v2::RouteMatch* match_;
  ::envoy::api::v2::Metadata* metadata_;
  ::envoy::api::v2::Decorator* decorator_;
  union ActionUnion {
    ActionUnion() {}
    ::envoy::api::v2::RouteAction* route_;
    ::envoy::api::v2::RedirectAction* redirect_;
  } action_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VirtualCluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.VirtualCluster) */ {
 public:
  VirtualCluster();
  virtual ~VirtualCluster();

  VirtualCluster(const VirtualCluster& from);

  inline VirtualCluster& operator=(const VirtualCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VirtualCluster(VirtualCluster&& from) noexcept
    : VirtualCluster() {
    *this = ::std::move(from);
  }

  inline VirtualCluster& operator=(VirtualCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VirtualCluster& default_instance();

  static inline const VirtualCluster* internal_default_instance() {
    return reinterpret_cast<const VirtualCluster*>(
               &_VirtualCluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(VirtualCluster* other);
  friend void swap(VirtualCluster& a, VirtualCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VirtualCluster* New() const PROTOBUF_FINAL { return New(NULL); }

  VirtualCluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VirtualCluster& from);
  void MergeFrom(const VirtualCluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VirtualCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pattern = 1;
  void clear_pattern();
  static const int kPatternFieldNumber = 1;
  const ::std::string& pattern() const;
  void set_pattern(const ::std::string& value);
  #if LANG_CXX11
  void set_pattern(::std::string&& value);
  #endif
  void set_pattern(const char* value);
  void set_pattern(const char* value, size_t size);
  ::std::string* mutable_pattern();
  ::std::string* release_pattern();
  void set_allocated_pattern(::std::string* pattern);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .envoy.api.v2.RequestMethod method = 3;
  void clear_method();
  static const int kMethodFieldNumber = 3;
  ::envoy::api::v2::RequestMethod method() const;
  void set_method(::envoy::api::v2::RequestMethod value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.VirtualCluster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pattern_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int method_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_SourceCluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.SourceCluster) */ {
 public:
  RateLimit_Action_SourceCluster();
  virtual ~RateLimit_Action_SourceCluster();

  RateLimit_Action_SourceCluster(const RateLimit_Action_SourceCluster& from);

  inline RateLimit_Action_SourceCluster& operator=(const RateLimit_Action_SourceCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_SourceCluster(RateLimit_Action_SourceCluster&& from) noexcept
    : RateLimit_Action_SourceCluster() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_SourceCluster& operator=(RateLimit_Action_SourceCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_SourceCluster& default_instance();

  static inline const RateLimit_Action_SourceCluster* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_SourceCluster*>(
               &_RateLimit_Action_SourceCluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(RateLimit_Action_SourceCluster* other);
  friend void swap(RateLimit_Action_SourceCluster& a, RateLimit_Action_SourceCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_SourceCluster* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_SourceCluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_SourceCluster& from);
  void MergeFrom(const RateLimit_Action_SourceCluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_SourceCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.SourceCluster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_DestinationCluster : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.DestinationCluster) */ {
 public:
  RateLimit_Action_DestinationCluster();
  virtual ~RateLimit_Action_DestinationCluster();

  RateLimit_Action_DestinationCluster(const RateLimit_Action_DestinationCluster& from);

  inline RateLimit_Action_DestinationCluster& operator=(const RateLimit_Action_DestinationCluster& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_DestinationCluster(RateLimit_Action_DestinationCluster&& from) noexcept
    : RateLimit_Action_DestinationCluster() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_DestinationCluster& operator=(RateLimit_Action_DestinationCluster&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_DestinationCluster& default_instance();

  static inline const RateLimit_Action_DestinationCluster* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_DestinationCluster*>(
               &_RateLimit_Action_DestinationCluster_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(RateLimit_Action_DestinationCluster* other);
  friend void swap(RateLimit_Action_DestinationCluster& a, RateLimit_Action_DestinationCluster& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_DestinationCluster* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_DestinationCluster* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_DestinationCluster& from);
  void MergeFrom(const RateLimit_Action_DestinationCluster& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_DestinationCluster* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.DestinationCluster)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_RequestHeaders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.RequestHeaders) */ {
 public:
  RateLimit_Action_RequestHeaders();
  virtual ~RateLimit_Action_RequestHeaders();

  RateLimit_Action_RequestHeaders(const RateLimit_Action_RequestHeaders& from);

  inline RateLimit_Action_RequestHeaders& operator=(const RateLimit_Action_RequestHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_RequestHeaders(RateLimit_Action_RequestHeaders&& from) noexcept
    : RateLimit_Action_RequestHeaders() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_RequestHeaders& operator=(RateLimit_Action_RequestHeaders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_RequestHeaders& default_instance();

  static inline const RateLimit_Action_RequestHeaders* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_RequestHeaders*>(
               &_RateLimit_Action_RequestHeaders_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(RateLimit_Action_RequestHeaders* other);
  friend void swap(RateLimit_Action_RequestHeaders& a, RateLimit_Action_RequestHeaders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_RequestHeaders* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_RequestHeaders* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_RequestHeaders& from);
  void MergeFrom(const RateLimit_Action_RequestHeaders& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_RequestHeaders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string header_name = 1;
  void clear_header_name();
  static const int kHeaderNameFieldNumber = 1;
  const ::std::string& header_name() const;
  void set_header_name(const ::std::string& value);
  #if LANG_CXX11
  void set_header_name(::std::string&& value);
  #endif
  void set_header_name(const char* value);
  void set_header_name(const char* value, size_t size);
  ::std::string* mutable_header_name();
  ::std::string* release_header_name();
  void set_allocated_header_name(::std::string* header_name);

  // string descriptor_key = 2;
  void clear_descriptor_key();
  static const int kDescriptorKeyFieldNumber = 2;
  const ::std::string& descriptor_key() const;
  void set_descriptor_key(const ::std::string& value);
  #if LANG_CXX11
  void set_descriptor_key(::std::string&& value);
  #endif
  void set_descriptor_key(const char* value);
  void set_descriptor_key(const char* value, size_t size);
  ::std::string* mutable_descriptor_key();
  ::std::string* release_descriptor_key();
  void set_allocated_descriptor_key(::std::string* descriptor_key);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.RequestHeaders)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr header_name_;
  ::google::protobuf::internal::ArenaStringPtr descriptor_key_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_RemoteAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.RemoteAddress) */ {
 public:
  RateLimit_Action_RemoteAddress();
  virtual ~RateLimit_Action_RemoteAddress();

  RateLimit_Action_RemoteAddress(const RateLimit_Action_RemoteAddress& from);

  inline RateLimit_Action_RemoteAddress& operator=(const RateLimit_Action_RemoteAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_RemoteAddress(RateLimit_Action_RemoteAddress&& from) noexcept
    : RateLimit_Action_RemoteAddress() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_RemoteAddress& operator=(RateLimit_Action_RemoteAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_RemoteAddress& default_instance();

  static inline const RateLimit_Action_RemoteAddress* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_RemoteAddress*>(
               &_RateLimit_Action_RemoteAddress_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(RateLimit_Action_RemoteAddress* other);
  friend void swap(RateLimit_Action_RemoteAddress& a, RateLimit_Action_RemoteAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_RemoteAddress* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_RemoteAddress* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_RemoteAddress& from);
  void MergeFrom(const RateLimit_Action_RemoteAddress& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_RemoteAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.RemoteAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_GenericKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.GenericKey) */ {
 public:
  RateLimit_Action_GenericKey();
  virtual ~RateLimit_Action_GenericKey();

  RateLimit_Action_GenericKey(const RateLimit_Action_GenericKey& from);

  inline RateLimit_Action_GenericKey& operator=(const RateLimit_Action_GenericKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_GenericKey(RateLimit_Action_GenericKey&& from) noexcept
    : RateLimit_Action_GenericKey() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_GenericKey& operator=(RateLimit_Action_GenericKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_GenericKey& default_instance();

  static inline const RateLimit_Action_GenericKey* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_GenericKey*>(
               &_RateLimit_Action_GenericKey_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(RateLimit_Action_GenericKey* other);
  friend void swap(RateLimit_Action_GenericKey& a, RateLimit_Action_GenericKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_GenericKey* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_GenericKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_GenericKey& from);
  void MergeFrom(const RateLimit_Action_GenericKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_GenericKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string descriptor_value = 1;
  void clear_descriptor_value();
  static const int kDescriptorValueFieldNumber = 1;
  const ::std::string& descriptor_value() const;
  void set_descriptor_value(const ::std::string& value);
  #if LANG_CXX11
  void set_descriptor_value(::std::string&& value);
  #endif
  void set_descriptor_value(const char* value);
  void set_descriptor_value(const char* value, size_t size);
  ::std::string* mutable_descriptor_value();
  ::std::string* release_descriptor_value();
  void set_allocated_descriptor_value(::std::string* descriptor_value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.GenericKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr descriptor_value_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action_HeaderValueMatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action.HeaderValueMatch) */ {
 public:
  RateLimit_Action_HeaderValueMatch();
  virtual ~RateLimit_Action_HeaderValueMatch();

  RateLimit_Action_HeaderValueMatch(const RateLimit_Action_HeaderValueMatch& from);

  inline RateLimit_Action_HeaderValueMatch& operator=(const RateLimit_Action_HeaderValueMatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action_HeaderValueMatch(RateLimit_Action_HeaderValueMatch&& from) noexcept
    : RateLimit_Action_HeaderValueMatch() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action_HeaderValueMatch& operator=(RateLimit_Action_HeaderValueMatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action_HeaderValueMatch& default_instance();

  static inline const RateLimit_Action_HeaderValueMatch* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action_HeaderValueMatch*>(
               &_RateLimit_Action_HeaderValueMatch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RateLimit_Action_HeaderValueMatch* other);
  friend void swap(RateLimit_Action_HeaderValueMatch& a, RateLimit_Action_HeaderValueMatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action_HeaderValueMatch* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action_HeaderValueMatch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action_HeaderValueMatch& from);
  void MergeFrom(const RateLimit_Action_HeaderValueMatch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action_HeaderValueMatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.HeaderMatcher headers = 3;
  int headers_size() const;
  void clear_headers();
  static const int kHeadersFieldNumber = 3;
  const ::envoy::api::v2::HeaderMatcher& headers(int index) const;
  ::envoy::api::v2::HeaderMatcher* mutable_headers(int index);
  ::envoy::api::v2::HeaderMatcher* add_headers();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >*
      mutable_headers();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >&
      headers() const;

  // string descriptor_value = 1;
  void clear_descriptor_value();
  static const int kDescriptorValueFieldNumber = 1;
  const ::std::string& descriptor_value() const;
  void set_descriptor_value(const ::std::string& value);
  #if LANG_CXX11
  void set_descriptor_value(::std::string&& value);
  #endif
  void set_descriptor_value(const char* value);
  void set_descriptor_value(const char* value, size_t size);
  ::std::string* mutable_descriptor_value();
  ::std::string* release_descriptor_value();
  void set_allocated_descriptor_value(::std::string* descriptor_value);

  // .google.protobuf.BoolValue expect_match = 2;
  bool has_expect_match() const;
  void clear_expect_match();
  static const int kExpectMatchFieldNumber = 2;
  const ::google::protobuf::BoolValue& expect_match() const;
  ::google::protobuf::BoolValue* mutable_expect_match();
  ::google::protobuf::BoolValue* release_expect_match();
  void set_allocated_expect_match(::google::protobuf::BoolValue* expect_match);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action.HeaderValueMatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher > headers_;
  ::google::protobuf::internal::ArenaStringPtr descriptor_value_;
  ::google::protobuf::BoolValue* expect_match_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit_Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit.Action) */ {
 public:
  RateLimit_Action();
  virtual ~RateLimit_Action();

  RateLimit_Action(const RateLimit_Action& from);

  inline RateLimit_Action& operator=(const RateLimit_Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit_Action(RateLimit_Action&& from) noexcept
    : RateLimit_Action() {
    *this = ::std::move(from);
  }

  inline RateLimit_Action& operator=(RateLimit_Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit_Action& default_instance();

  enum ActionSpecifierCase {
    kSourceCluster = 1,
    kDestinationCluster = 2,
    kRequestHeaders = 3,
    kRemoteAddress = 4,
    kGenericKey = 5,
    kHeaderValueMatch = 6,
    ACTION_SPECIFIER_NOT_SET = 0,
  };

  static inline const RateLimit_Action* internal_default_instance() {
    return reinterpret_cast<const RateLimit_Action*>(
               &_RateLimit_Action_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RateLimit_Action* other);
  friend void swap(RateLimit_Action& a, RateLimit_Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit_Action* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit_Action* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit_Action& from);
  void MergeFrom(const RateLimit_Action& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit_Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RateLimit_Action_SourceCluster SourceCluster;
  typedef RateLimit_Action_DestinationCluster DestinationCluster;
  typedef RateLimit_Action_RequestHeaders RequestHeaders;
  typedef RateLimit_Action_RemoteAddress RemoteAddress;
  typedef RateLimit_Action_GenericKey GenericKey;
  typedef RateLimit_Action_HeaderValueMatch HeaderValueMatch;

  // accessors -------------------------------------------------------

  // .envoy.api.v2.RateLimit.Action.SourceCluster source_cluster = 1;
  bool has_source_cluster() const;
  void clear_source_cluster();
  static const int kSourceClusterFieldNumber = 1;
  const ::envoy::api::v2::RateLimit_Action_SourceCluster& source_cluster() const;
  ::envoy::api::v2::RateLimit_Action_SourceCluster* mutable_source_cluster();
  ::envoy::api::v2::RateLimit_Action_SourceCluster* release_source_cluster();
  void set_allocated_source_cluster(::envoy::api::v2::RateLimit_Action_SourceCluster* source_cluster);

  // .envoy.api.v2.RateLimit.Action.DestinationCluster destination_cluster = 2;
  bool has_destination_cluster() const;
  void clear_destination_cluster();
  static const int kDestinationClusterFieldNumber = 2;
  const ::envoy::api::v2::RateLimit_Action_DestinationCluster& destination_cluster() const;
  ::envoy::api::v2::RateLimit_Action_DestinationCluster* mutable_destination_cluster();
  ::envoy::api::v2::RateLimit_Action_DestinationCluster* release_destination_cluster();
  void set_allocated_destination_cluster(::envoy::api::v2::RateLimit_Action_DestinationCluster* destination_cluster);

  // .envoy.api.v2.RateLimit.Action.RequestHeaders request_headers = 3;
  bool has_request_headers() const;
  void clear_request_headers();
  static const int kRequestHeadersFieldNumber = 3;
  const ::envoy::api::v2::RateLimit_Action_RequestHeaders& request_headers() const;
  ::envoy::api::v2::RateLimit_Action_RequestHeaders* mutable_request_headers();
  ::envoy::api::v2::RateLimit_Action_RequestHeaders* release_request_headers();
  void set_allocated_request_headers(::envoy::api::v2::RateLimit_Action_RequestHeaders* request_headers);

  // .envoy.api.v2.RateLimit.Action.RemoteAddress remote_address = 4;
  bool has_remote_address() const;
  void clear_remote_address();
  static const int kRemoteAddressFieldNumber = 4;
  const ::envoy::api::v2::RateLimit_Action_RemoteAddress& remote_address() const;
  ::envoy::api::v2::RateLimit_Action_RemoteAddress* mutable_remote_address();
  ::envoy::api::v2::RateLimit_Action_RemoteAddress* release_remote_address();
  void set_allocated_remote_address(::envoy::api::v2::RateLimit_Action_RemoteAddress* remote_address);

  // .envoy.api.v2.RateLimit.Action.GenericKey generic_key = 5;
  bool has_generic_key() const;
  void clear_generic_key();
  static const int kGenericKeyFieldNumber = 5;
  const ::envoy::api::v2::RateLimit_Action_GenericKey& generic_key() const;
  ::envoy::api::v2::RateLimit_Action_GenericKey* mutable_generic_key();
  ::envoy::api::v2::RateLimit_Action_GenericKey* release_generic_key();
  void set_allocated_generic_key(::envoy::api::v2::RateLimit_Action_GenericKey* generic_key);

  // .envoy.api.v2.RateLimit.Action.HeaderValueMatch header_value_match = 6;
  bool has_header_value_match() const;
  void clear_header_value_match();
  static const int kHeaderValueMatchFieldNumber = 6;
  const ::envoy::api::v2::RateLimit_Action_HeaderValueMatch& header_value_match() const;
  ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* mutable_header_value_match();
  ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* release_header_value_match();
  void set_allocated_header_value_match(::envoy::api::v2::RateLimit_Action_HeaderValueMatch* header_value_match);

  ActionSpecifierCase action_specifier_case() const;
  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit.Action)
 private:
  void set_has_source_cluster();
  void set_has_destination_cluster();
  void set_has_request_headers();
  void set_has_remote_address();
  void set_has_generic_key();
  void set_has_header_value_match();

  inline bool has_action_specifier() const;
  void clear_action_specifier();
  inline void clear_has_action_specifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ActionSpecifierUnion {
    ActionSpecifierUnion() {}
    ::envoy::api::v2::RateLimit_Action_SourceCluster* source_cluster_;
    ::envoy::api::v2::RateLimit_Action_DestinationCluster* destination_cluster_;
    ::envoy::api::v2::RateLimit_Action_RequestHeaders* request_headers_;
    ::envoy::api::v2::RateLimit_Action_RemoteAddress* remote_address_;
    ::envoy::api::v2::RateLimit_Action_GenericKey* generic_key_;
    ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* header_value_match_;
  } action_specifier_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RateLimit) */ {
 public:
  RateLimit();
  virtual ~RateLimit();

  RateLimit(const RateLimit& from);

  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit(RateLimit&& from) noexcept
    : RateLimit() {
    *this = ::std::move(from);
  }

  inline RateLimit& operator=(RateLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit& default_instance();

  static inline const RateLimit* internal_default_instance() {
    return reinterpret_cast<const RateLimit*>(
               &_RateLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(RateLimit* other);
  friend void swap(RateLimit& a, RateLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit& from);
  void MergeFrom(const RateLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RateLimit_Action Action;

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.RateLimit.Action actions = 3;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 3;
  const ::envoy::api::v2::RateLimit_Action& actions(int index) const;
  ::envoy::api::v2::RateLimit_Action* mutable_actions(int index);
  ::envoy::api::v2::RateLimit_Action* add_actions();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit_Action >*
      mutable_actions();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit_Action >&
      actions() const;

  // string disable_key = 2;
  void clear_disable_key();
  static const int kDisableKeyFieldNumber = 2;
  const ::std::string& disable_key() const;
  void set_disable_key(const ::std::string& value);
  #if LANG_CXX11
  void set_disable_key(::std::string&& value);
  #endif
  void set_disable_key(const char* value);
  void set_disable_key(const char* value, size_t size);
  ::std::string* mutable_disable_key();
  ::std::string* release_disable_key();
  void set_allocated_disable_key(::std::string* disable_key);

  // .google.protobuf.UInt32Value stage = 1;
  bool has_stage() const;
  void clear_stage();
  static const int kStageFieldNumber = 1;
  const ::google::protobuf::UInt32Value& stage() const;
  ::google::protobuf::UInt32Value* mutable_stage();
  ::google::protobuf::UInt32Value* release_stage();
  void set_allocated_stage(::google::protobuf::UInt32Value* stage);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RateLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit_Action > actions_;
  ::google::protobuf::internal::ArenaStringPtr disable_key_;
  ::google::protobuf::UInt32Value* stage_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeaderMatcher : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.HeaderMatcher) */ {
 public:
  HeaderMatcher();
  virtual ~HeaderMatcher();

  HeaderMatcher(const HeaderMatcher& from);

  inline HeaderMatcher& operator=(const HeaderMatcher& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeaderMatcher(HeaderMatcher&& from) noexcept
    : HeaderMatcher() {
    *this = ::std::move(from);
  }

  inline HeaderMatcher& operator=(HeaderMatcher&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeaderMatcher& default_instance();

  static inline const HeaderMatcher* internal_default_instance() {
    return reinterpret_cast<const HeaderMatcher*>(
               &_HeaderMatcher_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(HeaderMatcher* other);
  friend void swap(HeaderMatcher& a, HeaderMatcher& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeaderMatcher* New() const PROTOBUF_FINAL { return New(NULL); }

  HeaderMatcher* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeaderMatcher& from);
  void MergeFrom(const HeaderMatcher& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeaderMatcher* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .google.protobuf.BoolValue regex = 3;
  bool has_regex() const;
  void clear_regex();
  static const int kRegexFieldNumber = 3;
  const ::google::protobuf::BoolValue& regex() const;
  ::google::protobuf::BoolValue* mutable_regex();
  ::google::protobuf::BoolValue* release_regex();
  void set_allocated_regex(::google::protobuf::BoolValue* regex);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.HeaderMatcher)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::BoolValue* regex_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VirtualHost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.VirtualHost) */ {
 public:
  VirtualHost();
  virtual ~VirtualHost();

  VirtualHost(const VirtualHost& from);

  inline VirtualHost& operator=(const VirtualHost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VirtualHost(VirtualHost&& from) noexcept
    : VirtualHost() {
    *this = ::std::move(from);
  }

  inline VirtualHost& operator=(VirtualHost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VirtualHost& default_instance();

  static inline const VirtualHost* internal_default_instance() {
    return reinterpret_cast<const VirtualHost*>(
               &_VirtualHost_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(VirtualHost* other);
  friend void swap(VirtualHost& a, VirtualHost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VirtualHost* New() const PROTOBUF_FINAL { return New(NULL); }

  VirtualHost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VirtualHost& from);
  void MergeFrom(const VirtualHost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VirtualHost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VirtualHost_TlsRequirementType TlsRequirementType;
  static const TlsRequirementType NONE =
    VirtualHost_TlsRequirementType_NONE;
  static const TlsRequirementType EXTERNAL_ONLY =
    VirtualHost_TlsRequirementType_EXTERNAL_ONLY;
  static const TlsRequirementType ALL =
    VirtualHost_TlsRequirementType_ALL;
  static inline bool TlsRequirementType_IsValid(int value) {
    return VirtualHost_TlsRequirementType_IsValid(value);
  }
  static const TlsRequirementType TlsRequirementType_MIN =
    VirtualHost_TlsRequirementType_TlsRequirementType_MIN;
  static const TlsRequirementType TlsRequirementType_MAX =
    VirtualHost_TlsRequirementType_TlsRequirementType_MAX;
  static const int TlsRequirementType_ARRAYSIZE =
    VirtualHost_TlsRequirementType_TlsRequirementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TlsRequirementType_descriptor() {
    return VirtualHost_TlsRequirementType_descriptor();
  }
  static inline const ::std::string& TlsRequirementType_Name(TlsRequirementType value) {
    return VirtualHost_TlsRequirementType_Name(value);
  }
  static inline bool TlsRequirementType_Parse(const ::std::string& name,
      TlsRequirementType* value) {
    return VirtualHost_TlsRequirementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated string domains = 2;
  int domains_size() const;
  void clear_domains();
  static const int kDomainsFieldNumber = 2;
  const ::std::string& domains(int index) const;
  ::std::string* mutable_domains(int index);
  void set_domains(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_domains(int index, ::std::string&& value);
  #endif
  void set_domains(int index, const char* value);
  void set_domains(int index, const char* value, size_t size);
  ::std::string* add_domains();
  void add_domains(const ::std::string& value);
  #if LANG_CXX11
  void add_domains(::std::string&& value);
  #endif
  void add_domains(const char* value);
  void add_domains(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& domains() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_domains();

  // repeated .envoy.api.v2.Route routes = 3;
  int routes_size() const;
  void clear_routes();
  static const int kRoutesFieldNumber = 3;
  const ::envoy::api::v2::Route& routes(int index) const;
  ::envoy::api::v2::Route* mutable_routes(int index);
  ::envoy::api::v2::Route* add_routes();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Route >*
      mutable_routes();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Route >&
      routes() const;

  // repeated .envoy.api.v2.VirtualCluster virtual_clusters = 5;
  int virtual_clusters_size() const;
  void clear_virtual_clusters();
  static const int kVirtualClustersFieldNumber = 5;
  const ::envoy::api::v2::VirtualCluster& virtual_clusters(int index) const;
  ::envoy::api::v2::VirtualCluster* mutable_virtual_clusters(int index);
  ::envoy::api::v2::VirtualCluster* add_virtual_clusters();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualCluster >*
      mutable_virtual_clusters();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualCluster >&
      virtual_clusters() const;

  // repeated .envoy.api.v2.RateLimit rate_limits = 6;
  int rate_limits_size() const;
  void clear_rate_limits();
  static const int kRateLimitsFieldNumber = 6;
  const ::envoy::api::v2::RateLimit& rate_limits(int index) const;
  ::envoy::api::v2::RateLimit* mutable_rate_limits(int index);
  ::envoy::api::v2::RateLimit* add_rate_limits();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >*
      mutable_rate_limits();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >&
      rate_limits() const;

  // repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 7;
  int request_headers_to_add_size() const;
  void clear_request_headers_to_add();
  static const int kRequestHeadersToAddFieldNumber = 7;
  const ::envoy::api::v2::HeaderValueOption& request_headers_to_add(int index) const;
  ::envoy::api::v2::HeaderValueOption* mutable_request_headers_to_add(int index);
  ::envoy::api::v2::HeaderValueOption* add_request_headers_to_add();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
      mutable_request_headers_to_add();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
      request_headers_to_add() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .envoy.api.v2.CorsPolicy cors = 8;
  bool has_cors() const;
  void clear_cors();
  static const int kCorsFieldNumber = 8;
  const ::envoy::api::v2::CorsPolicy& cors() const;
  ::envoy::api::v2::CorsPolicy* mutable_cors();
  ::envoy::api::v2::CorsPolicy* release_cors();
  void set_allocated_cors(::envoy::api::v2::CorsPolicy* cors);

  // .envoy.api.v2.VirtualHost.TlsRequirementType require_tls = 4;
  void clear_require_tls();
  static const int kRequireTlsFieldNumber = 4;
  ::envoy::api::v2::VirtualHost_TlsRequirementType require_tls() const;
  void set_require_tls(::envoy::api::v2::VirtualHost_TlsRequirementType value);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.VirtualHost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> domains_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Route > routes_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualCluster > virtual_clusters_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit > rate_limits_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption > request_headers_to_add_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::envoy::api::v2::CorsPolicy* cors_;
  int require_tls_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteConfiguration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:envoy.api.v2.RouteConfiguration) */ {
 public:
  RouteConfiguration();
  virtual ~RouteConfiguration();

  RouteConfiguration(const RouteConfiguration& from);

  inline RouteConfiguration& operator=(const RouteConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteConfiguration(RouteConfiguration&& from) noexcept
    : RouteConfiguration() {
    *this = ::std::move(from);
  }

  inline RouteConfiguration& operator=(RouteConfiguration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteConfiguration& default_instance();

  static inline const RouteConfiguration* internal_default_instance() {
    return reinterpret_cast<const RouteConfiguration*>(
               &_RouteConfiguration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(RouteConfiguration* other);
  friend void swap(RouteConfiguration& a, RouteConfiguration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteConfiguration* New() const PROTOBUF_FINAL { return New(NULL); }

  RouteConfiguration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RouteConfiguration& from);
  void MergeFrom(const RouteConfiguration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RouteConfiguration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .envoy.api.v2.VirtualHost virtual_hosts = 2;
  int virtual_hosts_size() const;
  void clear_virtual_hosts();
  static const int kVirtualHostsFieldNumber = 2;
  const ::envoy::api::v2::VirtualHost& virtual_hosts(int index) const;
  ::envoy::api::v2::VirtualHost* mutable_virtual_hosts(int index);
  ::envoy::api::v2::VirtualHost* add_virtual_hosts();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualHost >*
      mutable_virtual_hosts();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualHost >&
      virtual_hosts() const;

  // repeated string internal_only_headers = 3;
  int internal_only_headers_size() const;
  void clear_internal_only_headers();
  static const int kInternalOnlyHeadersFieldNumber = 3;
  const ::std::string& internal_only_headers(int index) const;
  ::std::string* mutable_internal_only_headers(int index);
  void set_internal_only_headers(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_internal_only_headers(int index, ::std::string&& value);
  #endif
  void set_internal_only_headers(int index, const char* value);
  void set_internal_only_headers(int index, const char* value, size_t size);
  ::std::string* add_internal_only_headers();
  void add_internal_only_headers(const ::std::string& value);
  #if LANG_CXX11
  void add_internal_only_headers(::std::string&& value);
  #endif
  void add_internal_only_headers(const char* value);
  void add_internal_only_headers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& internal_only_headers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_internal_only_headers();

  // repeated .envoy.api.v2.HeaderValueOption response_headers_to_add = 4;
  int response_headers_to_add_size() const;
  void clear_response_headers_to_add();
  static const int kResponseHeadersToAddFieldNumber = 4;
  const ::envoy::api::v2::HeaderValueOption& response_headers_to_add(int index) const;
  ::envoy::api::v2::HeaderValueOption* mutable_response_headers_to_add(int index);
  ::envoy::api::v2::HeaderValueOption* add_response_headers_to_add();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
      mutable_response_headers_to_add();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
      response_headers_to_add() const;

  // repeated string response_headers_to_remove = 5;
  int response_headers_to_remove_size() const;
  void clear_response_headers_to_remove();
  static const int kResponseHeadersToRemoveFieldNumber = 5;
  const ::std::string& response_headers_to_remove(int index) const;
  ::std::string* mutable_response_headers_to_remove(int index);
  void set_response_headers_to_remove(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_response_headers_to_remove(int index, ::std::string&& value);
  #endif
  void set_response_headers_to_remove(int index, const char* value);
  void set_response_headers_to_remove(int index, const char* value, size_t size);
  ::std::string* add_response_headers_to_remove();
  void add_response_headers_to_remove(const ::std::string& value);
  #if LANG_CXX11
  void add_response_headers_to_remove(::std::string&& value);
  #endif
  void add_response_headers_to_remove(const char* value);
  void add_response_headers_to_remove(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& response_headers_to_remove() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_response_headers_to_remove();

  // repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 6;
  int request_headers_to_add_size() const;
  void clear_request_headers_to_add();
  static const int kRequestHeadersToAddFieldNumber = 6;
  const ::envoy::api::v2::HeaderValueOption& request_headers_to_add(int index) const;
  ::envoy::api::v2::HeaderValueOption* mutable_request_headers_to_add(int index);
  ::envoy::api::v2::HeaderValueOption* add_request_headers_to_add();
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
      mutable_request_headers_to_add();
  const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
      request_headers_to_add() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .google.protobuf.BoolValue validate_clusters = 7;
  bool has_validate_clusters() const;
  void clear_validate_clusters();
  static const int kValidateClustersFieldNumber = 7;
  const ::google::protobuf::BoolValue& validate_clusters() const;
  ::google::protobuf::BoolValue* mutable_validate_clusters();
  ::google::protobuf::BoolValue* release_validate_clusters();
  void set_allocated_validate_clusters(::google::protobuf::BoolValue* validate_clusters);

  // @@protoc_insertion_point(class_scope:envoy.api.v2.RouteConfiguration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualHost > virtual_hosts_;
  ::google::protobuf::RepeatedPtrField< ::std::string> internal_only_headers_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption > response_headers_to_add_;
  ::google::protobuf::RepeatedPtrField< ::std::string> response_headers_to_remove_;
  ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption > request_headers_to_add_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::BoolValue* validate_clusters_;
  mutable int _cached_size_;
  friend struct protobuf_api_2frds_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WeightedCluster_ClusterWeight

// string name = 1;
inline void WeightedCluster_ClusterWeight::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WeightedCluster_ClusterWeight::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.WeightedCluster.ClusterWeight.name)
  return name_.GetNoArena();
}
inline void WeightedCluster_ClusterWeight::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.WeightedCluster.ClusterWeight.name)
}
#if LANG_CXX11
inline void WeightedCluster_ClusterWeight::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.WeightedCluster.ClusterWeight.name)
}
#endif
inline void WeightedCluster_ClusterWeight::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.WeightedCluster.ClusterWeight.name)
}
inline void WeightedCluster_ClusterWeight::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.WeightedCluster.ClusterWeight.name)
}
inline ::std::string* WeightedCluster_ClusterWeight::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.WeightedCluster.ClusterWeight.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WeightedCluster_ClusterWeight::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.WeightedCluster.ClusterWeight.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WeightedCluster_ClusterWeight::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.WeightedCluster.ClusterWeight.name)
}

// .google.protobuf.UInt32Value weight = 2;
inline bool WeightedCluster_ClusterWeight::has_weight() const {
  return this != internal_default_instance() && weight_ != NULL;
}
inline void WeightedCluster_ClusterWeight::clear_weight() {
  if (GetArenaNoVirtual() == NULL && weight_ != NULL) delete weight_;
  weight_ = NULL;
}
inline const ::google::protobuf::UInt32Value& WeightedCluster_ClusterWeight::weight() const {
  const ::google::protobuf::UInt32Value* p = weight_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.WeightedCluster.ClusterWeight.weight)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* WeightedCluster_ClusterWeight::mutable_weight() {
  
  if (weight_ == NULL) {
    weight_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.WeightedCluster.ClusterWeight.weight)
  return weight_;
}
inline ::google::protobuf::UInt32Value* WeightedCluster_ClusterWeight::release_weight() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.WeightedCluster.ClusterWeight.weight)
  
  ::google::protobuf::UInt32Value* temp = weight_;
  weight_ = NULL;
  return temp;
}
inline void WeightedCluster_ClusterWeight::set_allocated_weight(::google::protobuf::UInt32Value* weight) {
  delete weight_;
  if (weight != NULL && weight->GetArena() != NULL) {
    ::google::protobuf::UInt32Value* new_weight = new ::google::protobuf::UInt32Value;
    new_weight->CopyFrom(*weight);
    weight = new_weight;
  }
  weight_ = weight;
  if (weight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.WeightedCluster.ClusterWeight.weight)
}

// .envoy.api.v2.Metadata metadata_match = 3;
inline bool WeightedCluster_ClusterWeight::has_metadata_match() const {
  return this != internal_default_instance() && metadata_match_ != NULL;
}
inline void WeightedCluster_ClusterWeight::clear_metadata_match() {
  if (GetArenaNoVirtual() == NULL && metadata_match_ != NULL) delete metadata_match_;
  metadata_match_ = NULL;
}
inline const ::envoy::api::v2::Metadata& WeightedCluster_ClusterWeight::metadata_match() const {
  const ::envoy::api::v2::Metadata* p = metadata_match_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.WeightedCluster.ClusterWeight.metadata_match)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Metadata*>(
      &::envoy::api::v2::_Metadata_default_instance_);
}
inline ::envoy::api::v2::Metadata* WeightedCluster_ClusterWeight::mutable_metadata_match() {
  
  if (metadata_match_ == NULL) {
    metadata_match_ = new ::envoy::api::v2::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.WeightedCluster.ClusterWeight.metadata_match)
  return metadata_match_;
}
inline ::envoy::api::v2::Metadata* WeightedCluster_ClusterWeight::release_metadata_match() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.WeightedCluster.ClusterWeight.metadata_match)
  
  ::envoy::api::v2::Metadata* temp = metadata_match_;
  metadata_match_ = NULL;
  return temp;
}
inline void WeightedCluster_ClusterWeight::set_allocated_metadata_match(::envoy::api::v2::Metadata* metadata_match) {
  delete metadata_match_;
  metadata_match_ = metadata_match;
  if (metadata_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.WeightedCluster.ClusterWeight.metadata_match)
}

// -------------------------------------------------------------------

// WeightedCluster

// repeated .envoy.api.v2.WeightedCluster.ClusterWeight clusters = 1;
inline int WeightedCluster::clusters_size() const {
  return clusters_.size();
}
inline void WeightedCluster::clear_clusters() {
  clusters_.Clear();
}
inline const ::envoy::api::v2::WeightedCluster_ClusterWeight& WeightedCluster::clusters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.WeightedCluster.clusters)
  return clusters_.Get(index);
}
inline ::envoy::api::v2::WeightedCluster_ClusterWeight* WeightedCluster::mutable_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.WeightedCluster.clusters)
  return clusters_.Mutable(index);
}
inline ::envoy::api::v2::WeightedCluster_ClusterWeight* WeightedCluster::add_clusters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.WeightedCluster.clusters)
  return clusters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::WeightedCluster_ClusterWeight >*
WeightedCluster::mutable_clusters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.WeightedCluster.clusters)
  return &clusters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::WeightedCluster_ClusterWeight >&
WeightedCluster::clusters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.WeightedCluster.clusters)
  return clusters_;
}

// string runtime_key_prefix = 2;
inline void WeightedCluster::clear_runtime_key_prefix() {
  runtime_key_prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WeightedCluster::runtime_key_prefix() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.WeightedCluster.runtime_key_prefix)
  return runtime_key_prefix_.GetNoArena();
}
inline void WeightedCluster::set_runtime_key_prefix(const ::std::string& value) {
  
  runtime_key_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.WeightedCluster.runtime_key_prefix)
}
#if LANG_CXX11
inline void WeightedCluster::set_runtime_key_prefix(::std::string&& value) {
  
  runtime_key_prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.WeightedCluster.runtime_key_prefix)
}
#endif
inline void WeightedCluster::set_runtime_key_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_key_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.WeightedCluster.runtime_key_prefix)
}
inline void WeightedCluster::set_runtime_key_prefix(const char* value, size_t size) {
  
  runtime_key_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.WeightedCluster.runtime_key_prefix)
}
inline ::std::string* WeightedCluster::mutable_runtime_key_prefix() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.WeightedCluster.runtime_key_prefix)
  return runtime_key_prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WeightedCluster::release_runtime_key_prefix() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.WeightedCluster.runtime_key_prefix)
  
  return runtime_key_prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WeightedCluster::set_allocated_runtime_key_prefix(::std::string* runtime_key_prefix) {
  if (runtime_key_prefix != NULL) {
    
  } else {
    
  }
  runtime_key_prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_key_prefix);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.WeightedCluster.runtime_key_prefix)
}

// -------------------------------------------------------------------

// RouteMatch

// string prefix = 1;
inline bool RouteMatch::has_prefix() const {
  return path_specifier_case() == kPrefix;
}
inline void RouteMatch::set_has_prefix() {
  _oneof_case_[0] = kPrefix;
}
inline void RouteMatch::clear_prefix() {
  if (has_prefix()) {
    path_specifier_.prefix_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_specifier();
  }
}
inline const ::std::string& RouteMatch::prefix() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.prefix)
  if (has_prefix()) {
    return path_specifier_.prefix_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteMatch::set_prefix(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.prefix)
  if (!has_prefix()) {
    clear_path_specifier();
    set_has_prefix();
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.prefix)
}
#if LANG_CXX11
inline void RouteMatch::set_prefix(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.prefix)
  if (!has_prefix()) {
    clear_path_specifier();
    set_has_prefix();
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteMatch.prefix)
}
#endif
inline void RouteMatch::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_prefix()) {
    clear_path_specifier();
    set_has_prefix();
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteMatch.prefix)
}
inline void RouteMatch::set_prefix(const char* value, size_t size) {
  if (!has_prefix()) {
    clear_path_specifier();
    set_has_prefix();
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteMatch.prefix)
}
inline ::std::string* RouteMatch::mutable_prefix() {
  if (!has_prefix()) {
    clear_path_specifier();
    set_has_prefix();
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.prefix)
  return path_specifier_.prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteMatch::release_prefix() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteMatch.prefix)
  if (has_prefix()) {
    clear_has_path_specifier();
    return path_specifier_.prefix_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteMatch::set_allocated_prefix(::std::string* prefix) {
  if (!has_prefix()) {
    path_specifier_.prefix_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_specifier();
  if (prefix != NULL) {
    set_has_prefix();
    path_specifier_.prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        prefix);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteMatch.prefix)
}

// string path = 2;
inline bool RouteMatch::has_path() const {
  return path_specifier_case() == kPath;
}
inline void RouteMatch::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void RouteMatch::clear_path() {
  if (has_path()) {
    path_specifier_.path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_specifier();
  }
}
inline const ::std::string& RouteMatch::path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.path)
  if (has_path()) {
    return path_specifier_.path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteMatch::set_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.path)
  if (!has_path()) {
    clear_path_specifier();
    set_has_path();
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.path)
}
#if LANG_CXX11
inline void RouteMatch::set_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.path)
  if (!has_path()) {
    clear_path_specifier();
    set_has_path();
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteMatch.path)
}
#endif
inline void RouteMatch::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_path()) {
    clear_path_specifier();
    set_has_path();
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteMatch.path)
}
inline void RouteMatch::set_path(const char* value, size_t size) {
  if (!has_path()) {
    clear_path_specifier();
    set_has_path();
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteMatch.path)
}
inline ::std::string* RouteMatch::mutable_path() {
  if (!has_path()) {
    clear_path_specifier();
    set_has_path();
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.path)
  return path_specifier_.path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteMatch::release_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteMatch.path)
  if (has_path()) {
    clear_has_path_specifier();
    return path_specifier_.path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteMatch::set_allocated_path(::std::string* path) {
  if (!has_path()) {
    path_specifier_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_specifier();
  if (path != NULL) {
    set_has_path();
    path_specifier_.path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        path);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteMatch.path)
}

// string regex = 3;
inline bool RouteMatch::has_regex() const {
  return path_specifier_case() == kRegex;
}
inline void RouteMatch::set_has_regex() {
  _oneof_case_[0] = kRegex;
}
inline void RouteMatch::clear_regex() {
  if (has_regex()) {
    path_specifier_.regex_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_path_specifier();
  }
}
inline const ::std::string& RouteMatch::regex() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.regex)
  if (has_regex()) {
    return path_specifier_.regex_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteMatch::set_regex(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.regex)
  if (!has_regex()) {
    clear_path_specifier();
    set_has_regex();
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.regex)
}
#if LANG_CXX11
inline void RouteMatch::set_regex(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteMatch.regex)
  if (!has_regex()) {
    clear_path_specifier();
    set_has_regex();
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.regex_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteMatch.regex)
}
#endif
inline void RouteMatch::set_regex(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_regex()) {
    clear_path_specifier();
    set_has_regex();
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteMatch.regex)
}
inline void RouteMatch::set_regex(const char* value, size_t size) {
  if (!has_regex()) {
    clear_path_specifier();
    set_has_regex();
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  path_specifier_.regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteMatch.regex)
}
inline ::std::string* RouteMatch::mutable_regex() {
  if (!has_regex()) {
    clear_path_specifier();
    set_has_regex();
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.regex)
  return path_specifier_.regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteMatch::release_regex() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteMatch.regex)
  if (has_regex()) {
    clear_has_path_specifier();
    return path_specifier_.regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteMatch::set_allocated_regex(::std::string* regex) {
  if (!has_regex()) {
    path_specifier_.regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_path_specifier();
  if (regex != NULL) {
    set_has_regex();
    path_specifier_.regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        regex);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteMatch.regex)
}

// .google.protobuf.BoolValue case_sensitive = 4;
inline bool RouteMatch::has_case_sensitive() const {
  return this != internal_default_instance() && case_sensitive_ != NULL;
}
inline void RouteMatch::clear_case_sensitive() {
  if (GetArenaNoVirtual() == NULL && case_sensitive_ != NULL) delete case_sensitive_;
  case_sensitive_ = NULL;
}
inline const ::google::protobuf::BoolValue& RouteMatch::case_sensitive() const {
  const ::google::protobuf::BoolValue* p = case_sensitive_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.case_sensitive)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* RouteMatch::mutable_case_sensitive() {
  
  if (case_sensitive_ == NULL) {
    case_sensitive_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.case_sensitive)
  return case_sensitive_;
}
inline ::google::protobuf::BoolValue* RouteMatch::release_case_sensitive() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteMatch.case_sensitive)
  
  ::google::protobuf::BoolValue* temp = case_sensitive_;
  case_sensitive_ = NULL;
  return temp;
}
inline void RouteMatch::set_allocated_case_sensitive(::google::protobuf::BoolValue* case_sensitive) {
  delete case_sensitive_;
  if (case_sensitive != NULL && case_sensitive->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_case_sensitive = new ::google::protobuf::BoolValue;
    new_case_sensitive->CopyFrom(*case_sensitive);
    case_sensitive = new_case_sensitive;
  }
  case_sensitive_ = case_sensitive;
  if (case_sensitive) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteMatch.case_sensitive)
}

// .envoy.api.v2.RuntimeUInt32 runtime = 5;
inline bool RouteMatch::has_runtime() const {
  return this != internal_default_instance() && runtime_ != NULL;
}
inline void RouteMatch::clear_runtime() {
  if (GetArenaNoVirtual() == NULL && runtime_ != NULL) delete runtime_;
  runtime_ = NULL;
}
inline const ::envoy::api::v2::RuntimeUInt32& RouteMatch::runtime() const {
  const ::envoy::api::v2::RuntimeUInt32* p = runtime_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.runtime)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RuntimeUInt32*>(
      &::envoy::api::v2::_RuntimeUInt32_default_instance_);
}
inline ::envoy::api::v2::RuntimeUInt32* RouteMatch::mutable_runtime() {
  
  if (runtime_ == NULL) {
    runtime_ = new ::envoy::api::v2::RuntimeUInt32;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.runtime)
  return runtime_;
}
inline ::envoy::api::v2::RuntimeUInt32* RouteMatch::release_runtime() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteMatch.runtime)
  
  ::envoy::api::v2::RuntimeUInt32* temp = runtime_;
  runtime_ = NULL;
  return temp;
}
inline void RouteMatch::set_allocated_runtime(::envoy::api::v2::RuntimeUInt32* runtime) {
  delete runtime_;
  runtime_ = runtime;
  if (runtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteMatch.runtime)
}

// repeated .envoy.api.v2.HeaderMatcher headers = 6;
inline int RouteMatch::headers_size() const {
  return headers_.size();
}
inline void RouteMatch::clear_headers() {
  headers_.Clear();
}
inline const ::envoy::api::v2::HeaderMatcher& RouteMatch::headers(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteMatch.headers)
  return headers_.Get(index);
}
inline ::envoy::api::v2::HeaderMatcher* RouteMatch::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteMatch.headers)
  return headers_.Mutable(index);
}
inline ::envoy::api::v2::HeaderMatcher* RouteMatch::add_headers() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteMatch.headers)
  return headers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >*
RouteMatch::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteMatch.headers)
  return &headers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >&
RouteMatch::headers() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteMatch.headers)
  return headers_;
}

inline bool RouteMatch::has_path_specifier() const {
  return path_specifier_case() != PATH_SPECIFIER_NOT_SET;
}
inline void RouteMatch::clear_has_path_specifier() {
  _oneof_case_[0] = PATH_SPECIFIER_NOT_SET;
}
inline RouteMatch::PathSpecifierCase RouteMatch::path_specifier_case() const {
  return RouteMatch::PathSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CorsPolicy

// repeated string allow_origin = 1;
inline int CorsPolicy::allow_origin_size() const {
  return allow_origin_.size();
}
inline void CorsPolicy::clear_allow_origin() {
  allow_origin_.Clear();
}
inline const ::std::string& CorsPolicy::allow_origin(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.allow_origin)
  return allow_origin_.Get(index);
}
inline ::std::string* CorsPolicy::mutable_allow_origin(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.allow_origin)
  return allow_origin_.Mutable(index);
}
inline void CorsPolicy::set_allow_origin(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.allow_origin)
  allow_origin_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CorsPolicy::set_allow_origin(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.allow_origin)
  allow_origin_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CorsPolicy::set_allow_origin(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allow_origin_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.CorsPolicy.allow_origin)
}
inline void CorsPolicy::set_allow_origin(int index, const char* value, size_t size) {
  allow_origin_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.CorsPolicy.allow_origin)
}
inline ::std::string* CorsPolicy::add_allow_origin() {
  // @@protoc_insertion_point(field_add_mutable:envoy.api.v2.CorsPolicy.allow_origin)
  return allow_origin_.Add();
}
inline void CorsPolicy::add_allow_origin(const ::std::string& value) {
  allow_origin_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:envoy.api.v2.CorsPolicy.allow_origin)
}
#if LANG_CXX11
inline void CorsPolicy::add_allow_origin(::std::string&& value) {
  allow_origin_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:envoy.api.v2.CorsPolicy.allow_origin)
}
#endif
inline void CorsPolicy::add_allow_origin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  allow_origin_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:envoy.api.v2.CorsPolicy.allow_origin)
}
inline void CorsPolicy::add_allow_origin(const char* value, size_t size) {
  allow_origin_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:envoy.api.v2.CorsPolicy.allow_origin)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CorsPolicy::allow_origin() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.CorsPolicy.allow_origin)
  return allow_origin_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CorsPolicy::mutable_allow_origin() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.CorsPolicy.allow_origin)
  return &allow_origin_;
}

// string allow_methods = 2;
inline void CorsPolicy::clear_allow_methods() {
  allow_methods_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CorsPolicy::allow_methods() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.allow_methods)
  return allow_methods_.GetNoArena();
}
inline void CorsPolicy::set_allow_methods(const ::std::string& value) {
  
  allow_methods_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.allow_methods)
}
#if LANG_CXX11
inline void CorsPolicy::set_allow_methods(::std::string&& value) {
  
  allow_methods_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.CorsPolicy.allow_methods)
}
#endif
inline void CorsPolicy::set_allow_methods(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  allow_methods_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.CorsPolicy.allow_methods)
}
inline void CorsPolicy::set_allow_methods(const char* value, size_t size) {
  
  allow_methods_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.CorsPolicy.allow_methods)
}
inline ::std::string* CorsPolicy::mutable_allow_methods() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.allow_methods)
  return allow_methods_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorsPolicy::release_allow_methods() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.allow_methods)
  
  return allow_methods_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorsPolicy::set_allocated_allow_methods(::std::string* allow_methods) {
  if (allow_methods != NULL) {
    
  } else {
    
  }
  allow_methods_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), allow_methods);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.allow_methods)
}

// string allow_headers = 3;
inline void CorsPolicy::clear_allow_headers() {
  allow_headers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CorsPolicy::allow_headers() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.allow_headers)
  return allow_headers_.GetNoArena();
}
inline void CorsPolicy::set_allow_headers(const ::std::string& value) {
  
  allow_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.allow_headers)
}
#if LANG_CXX11
inline void CorsPolicy::set_allow_headers(::std::string&& value) {
  
  allow_headers_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.CorsPolicy.allow_headers)
}
#endif
inline void CorsPolicy::set_allow_headers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  allow_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.CorsPolicy.allow_headers)
}
inline void CorsPolicy::set_allow_headers(const char* value, size_t size) {
  
  allow_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.CorsPolicy.allow_headers)
}
inline ::std::string* CorsPolicy::mutable_allow_headers() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.allow_headers)
  return allow_headers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorsPolicy::release_allow_headers() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.allow_headers)
  
  return allow_headers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorsPolicy::set_allocated_allow_headers(::std::string* allow_headers) {
  if (allow_headers != NULL) {
    
  } else {
    
  }
  allow_headers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), allow_headers);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.allow_headers)
}

// string expose_headers = 4;
inline void CorsPolicy::clear_expose_headers() {
  expose_headers_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CorsPolicy::expose_headers() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.expose_headers)
  return expose_headers_.GetNoArena();
}
inline void CorsPolicy::set_expose_headers(const ::std::string& value) {
  
  expose_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.expose_headers)
}
#if LANG_CXX11
inline void CorsPolicy::set_expose_headers(::std::string&& value) {
  
  expose_headers_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.CorsPolicy.expose_headers)
}
#endif
inline void CorsPolicy::set_expose_headers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  expose_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.CorsPolicy.expose_headers)
}
inline void CorsPolicy::set_expose_headers(const char* value, size_t size) {
  
  expose_headers_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.CorsPolicy.expose_headers)
}
inline ::std::string* CorsPolicy::mutable_expose_headers() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.expose_headers)
  return expose_headers_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorsPolicy::release_expose_headers() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.expose_headers)
  
  return expose_headers_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorsPolicy::set_allocated_expose_headers(::std::string* expose_headers) {
  if (expose_headers != NULL) {
    
  } else {
    
  }
  expose_headers_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), expose_headers);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.expose_headers)
}

// string max_age = 5;
inline void CorsPolicy::clear_max_age() {
  max_age_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CorsPolicy::max_age() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.max_age)
  return max_age_.GetNoArena();
}
inline void CorsPolicy::set_max_age(const ::std::string& value) {
  
  max_age_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.CorsPolicy.max_age)
}
#if LANG_CXX11
inline void CorsPolicy::set_max_age(::std::string&& value) {
  
  max_age_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.CorsPolicy.max_age)
}
#endif
inline void CorsPolicy::set_max_age(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  max_age_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.CorsPolicy.max_age)
}
inline void CorsPolicy::set_max_age(const char* value, size_t size) {
  
  max_age_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.CorsPolicy.max_age)
}
inline ::std::string* CorsPolicy::mutable_max_age() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.max_age)
  return max_age_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CorsPolicy::release_max_age() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.max_age)
  
  return max_age_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CorsPolicy::set_allocated_max_age(::std::string* max_age) {
  if (max_age != NULL) {
    
  } else {
    
  }
  max_age_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), max_age);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.max_age)
}

// .google.protobuf.BoolValue allow_credentials = 6;
inline bool CorsPolicy::has_allow_credentials() const {
  return this != internal_default_instance() && allow_credentials_ != NULL;
}
inline void CorsPolicy::clear_allow_credentials() {
  if (GetArenaNoVirtual() == NULL && allow_credentials_ != NULL) delete allow_credentials_;
  allow_credentials_ = NULL;
}
inline const ::google::protobuf::BoolValue& CorsPolicy::allow_credentials() const {
  const ::google::protobuf::BoolValue* p = allow_credentials_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.allow_credentials)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* CorsPolicy::mutable_allow_credentials() {
  
  if (allow_credentials_ == NULL) {
    allow_credentials_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.allow_credentials)
  return allow_credentials_;
}
inline ::google::protobuf::BoolValue* CorsPolicy::release_allow_credentials() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.allow_credentials)
  
  ::google::protobuf::BoolValue* temp = allow_credentials_;
  allow_credentials_ = NULL;
  return temp;
}
inline void CorsPolicy::set_allocated_allow_credentials(::google::protobuf::BoolValue* allow_credentials) {
  delete allow_credentials_;
  if (allow_credentials != NULL && allow_credentials->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_allow_credentials = new ::google::protobuf::BoolValue;
    new_allow_credentials->CopyFrom(*allow_credentials);
    allow_credentials = new_allow_credentials;
  }
  allow_credentials_ = allow_credentials;
  if (allow_credentials) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.allow_credentials)
}

// .google.protobuf.BoolValue enabled = 7;
inline bool CorsPolicy::has_enabled() const {
  return this != internal_default_instance() && enabled_ != NULL;
}
inline void CorsPolicy::clear_enabled() {
  if (GetArenaNoVirtual() == NULL && enabled_ != NULL) delete enabled_;
  enabled_ = NULL;
}
inline const ::google::protobuf::BoolValue& CorsPolicy::enabled() const {
  const ::google::protobuf::BoolValue* p = enabled_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.CorsPolicy.enabled)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* CorsPolicy::mutable_enabled() {
  
  if (enabled_ == NULL) {
    enabled_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.CorsPolicy.enabled)
  return enabled_;
}
inline ::google::protobuf::BoolValue* CorsPolicy::release_enabled() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.CorsPolicy.enabled)
  
  ::google::protobuf::BoolValue* temp = enabled_;
  enabled_ = NULL;
  return temp;
}
inline void CorsPolicy::set_allocated_enabled(::google::protobuf::BoolValue* enabled) {
  delete enabled_;
  if (enabled != NULL && enabled->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_enabled = new ::google::protobuf::BoolValue;
    new_enabled->CopyFrom(*enabled);
    enabled = new_enabled;
  }
  enabled_ = enabled;
  if (enabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.CorsPolicy.enabled)
}

// -------------------------------------------------------------------

// RouteAction_RetryPolicy

// string retry_on = 1;
inline void RouteAction_RetryPolicy::clear_retry_on() {
  retry_on_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction_RetryPolicy::retry_on() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
  return retry_on_.GetNoArena();
}
inline void RouteAction_RetryPolicy::set_retry_on(const ::std::string& value) {
  
  retry_on_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
}
#if LANG_CXX11
inline void RouteAction_RetryPolicy::set_retry_on(::std::string&& value) {
  
  retry_on_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
}
#endif
inline void RouteAction_RetryPolicy::set_retry_on(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  retry_on_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
}
inline void RouteAction_RetryPolicy::set_retry_on(const char* value, size_t size) {
  
  retry_on_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
}
inline ::std::string* RouteAction_RetryPolicy::mutable_retry_on() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
  return retry_on_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction_RetryPolicy::release_retry_on() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
  
  return retry_on_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction_RetryPolicy::set_allocated_retry_on(::std::string* retry_on) {
  if (retry_on != NULL) {
    
  } else {
    
  }
  retry_on_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), retry_on);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.RetryPolicy.retry_on)
}

// .google.protobuf.UInt32Value num_retries = 2;
inline bool RouteAction_RetryPolicy::has_num_retries() const {
  return this != internal_default_instance() && num_retries_ != NULL;
}
inline void RouteAction_RetryPolicy::clear_num_retries() {
  if (GetArenaNoVirtual() == NULL && num_retries_ != NULL) delete num_retries_;
  num_retries_ = NULL;
}
inline const ::google::protobuf::UInt32Value& RouteAction_RetryPolicy::num_retries() const {
  const ::google::protobuf::UInt32Value* p = num_retries_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.RetryPolicy.num_retries)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* RouteAction_RetryPolicy::mutable_num_retries() {
  
  if (num_retries_ == NULL) {
    num_retries_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.RetryPolicy.num_retries)
  return num_retries_;
}
inline ::google::protobuf::UInt32Value* RouteAction_RetryPolicy::release_num_retries() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.RetryPolicy.num_retries)
  
  ::google::protobuf::UInt32Value* temp = num_retries_;
  num_retries_ = NULL;
  return temp;
}
inline void RouteAction_RetryPolicy::set_allocated_num_retries(::google::protobuf::UInt32Value* num_retries) {
  delete num_retries_;
  if (num_retries != NULL && num_retries->GetArena() != NULL) {
    ::google::protobuf::UInt32Value* new_num_retries = new ::google::protobuf::UInt32Value;
    new_num_retries->CopyFrom(*num_retries);
    num_retries = new_num_retries;
  }
  num_retries_ = num_retries;
  if (num_retries) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.RetryPolicy.num_retries)
}

// .google.protobuf.Duration per_try_timeout = 3;
inline bool RouteAction_RetryPolicy::has_per_try_timeout() const {
  return this != internal_default_instance() && per_try_timeout_ != NULL;
}
inline void RouteAction_RetryPolicy::clear_per_try_timeout() {
  if (GetArenaNoVirtual() == NULL && per_try_timeout_ != NULL) delete per_try_timeout_;
  per_try_timeout_ = NULL;
}
inline const ::google::protobuf::Duration& RouteAction_RetryPolicy::per_try_timeout() const {
  const ::google::protobuf::Duration* p = per_try_timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.RetryPolicy.per_try_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* RouteAction_RetryPolicy::mutable_per_try_timeout() {
  
  if (per_try_timeout_ == NULL) {
    per_try_timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.RetryPolicy.per_try_timeout)
  return per_try_timeout_;
}
inline ::google::protobuf::Duration* RouteAction_RetryPolicy::release_per_try_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.RetryPolicy.per_try_timeout)
  
  ::google::protobuf::Duration* temp = per_try_timeout_;
  per_try_timeout_ = NULL;
  return temp;
}
inline void RouteAction_RetryPolicy::set_allocated_per_try_timeout(::google::protobuf::Duration* per_try_timeout) {
  delete per_try_timeout_;
  if (per_try_timeout != NULL && per_try_timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_per_try_timeout = new ::google::protobuf::Duration;
    new_per_try_timeout->CopyFrom(*per_try_timeout);
    per_try_timeout = new_per_try_timeout;
  }
  per_try_timeout_ = per_try_timeout;
  if (per_try_timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.RetryPolicy.per_try_timeout)
}

// -------------------------------------------------------------------

// RouteAction_RequestMirrorPolicy

// string cluster = 1;
inline void RouteAction_RequestMirrorPolicy::clear_cluster() {
  cluster_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction_RequestMirrorPolicy::cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
  return cluster_.GetNoArena();
}
inline void RouteAction_RequestMirrorPolicy::set_cluster(const ::std::string& value) {
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
}
#if LANG_CXX11
inline void RouteAction_RequestMirrorPolicy::set_cluster(::std::string&& value) {
  
  cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
}
#endif
inline void RouteAction_RequestMirrorPolicy::set_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
}
inline void RouteAction_RequestMirrorPolicy::set_cluster(const char* value, size_t size) {
  
  cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
}
inline ::std::string* RouteAction_RequestMirrorPolicy::mutable_cluster() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
  return cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction_RequestMirrorPolicy::release_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
  
  return cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction_RequestMirrorPolicy::set_allocated_cluster(::std::string* cluster) {
  if (cluster != NULL) {
    
  } else {
    
  }
  cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.RequestMirrorPolicy.cluster)
}

// string runtime_key = 2;
inline void RouteAction_RequestMirrorPolicy::clear_runtime_key() {
  runtime_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction_RequestMirrorPolicy::runtime_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
  return runtime_key_.GetNoArena();
}
inline void RouteAction_RequestMirrorPolicy::set_runtime_key(const ::std::string& value) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
}
#if LANG_CXX11
inline void RouteAction_RequestMirrorPolicy::set_runtime_key(::std::string&& value) {
  
  runtime_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
}
#endif
inline void RouteAction_RequestMirrorPolicy::set_runtime_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
}
inline void RouteAction_RequestMirrorPolicy::set_runtime_key(const char* value, size_t size) {
  
  runtime_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
}
inline ::std::string* RouteAction_RequestMirrorPolicy::mutable_runtime_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
  return runtime_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction_RequestMirrorPolicy::release_runtime_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
  
  return runtime_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction_RequestMirrorPolicy::set_allocated_runtime_key(::std::string* runtime_key) {
  if (runtime_key != NULL) {
    
  } else {
    
  }
  runtime_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), runtime_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.RequestMirrorPolicy.runtime_key)
}

// -------------------------------------------------------------------

// RouteAction_HashPolicy_Header

// string header_name = 1;
inline void RouteAction_HashPolicy_Header::clear_header_name() {
  header_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction_HashPolicy_Header::header_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
  return header_name_.GetNoArena();
}
inline void RouteAction_HashPolicy_Header::set_header_name(const ::std::string& value) {
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
}
#if LANG_CXX11
inline void RouteAction_HashPolicy_Header::set_header_name(::std::string&& value) {
  
  header_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
}
#endif
inline void RouteAction_HashPolicy_Header::set_header_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
}
inline void RouteAction_HashPolicy_Header::set_header_name(const char* value, size_t size) {
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
}
inline ::std::string* RouteAction_HashPolicy_Header::mutable_header_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
  return header_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction_HashPolicy_Header::release_header_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
  
  return header_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction_HashPolicy_Header::set_allocated_header_name(::std::string* header_name) {
  if (header_name != NULL) {
    
  } else {
    
  }
  header_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.Header.header_name)
}

// -------------------------------------------------------------------

// RouteAction_HashPolicy_Cookie

// string name = 1;
inline void RouteAction_HashPolicy_Cookie::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction_HashPolicy_Cookie::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
  return name_.GetNoArena();
}
inline void RouteAction_HashPolicy_Cookie::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
}
#if LANG_CXX11
inline void RouteAction_HashPolicy_Cookie::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
}
#endif
inline void RouteAction_HashPolicy_Cookie::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
}
inline void RouteAction_HashPolicy_Cookie::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
}
inline ::std::string* RouteAction_HashPolicy_Cookie::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction_HashPolicy_Cookie::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction_HashPolicy_Cookie::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.Cookie.name)
}

// .google.protobuf.Duration ttl = 2;
inline bool RouteAction_HashPolicy_Cookie::has_ttl() const {
  return this != internal_default_instance() && ttl_ != NULL;
}
inline void RouteAction_HashPolicy_Cookie::clear_ttl() {
  if (GetArenaNoVirtual() == NULL && ttl_ != NULL) delete ttl_;
  ttl_ = NULL;
}
inline const ::google::protobuf::Duration& RouteAction_HashPolicy_Cookie::ttl() const {
  const ::google::protobuf::Duration* p = ttl_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.Cookie.ttl)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* RouteAction_HashPolicy_Cookie::mutable_ttl() {
  
  if (ttl_ == NULL) {
    ttl_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.Cookie.ttl)
  return ttl_;
}
inline ::google::protobuf::Duration* RouteAction_HashPolicy_Cookie::release_ttl() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.Cookie.ttl)
  
  ::google::protobuf::Duration* temp = ttl_;
  ttl_ = NULL;
  return temp;
}
inline void RouteAction_HashPolicy_Cookie::set_allocated_ttl(::google::protobuf::Duration* ttl) {
  delete ttl_;
  if (ttl != NULL && ttl->GetArena() != NULL) {
    ::google::protobuf::Duration* new_ttl = new ::google::protobuf::Duration;
    new_ttl->CopyFrom(*ttl);
    ttl = new_ttl;
  }
  ttl_ = ttl;
  if (ttl) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.Cookie.ttl)
}

// -------------------------------------------------------------------

// RouteAction_HashPolicy_ConnectionProperties

// bool source_ip = 1;
inline void RouteAction_HashPolicy_ConnectionProperties::clear_source_ip() {
  source_ip_ = false;
}
inline bool RouteAction_HashPolicy_ConnectionProperties::source_ip() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties.source_ip)
  return source_ip_;
}
inline void RouteAction_HashPolicy_ConnectionProperties::set_source_ip(bool value) {
  
  source_ip_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties.source_ip)
}

// -------------------------------------------------------------------

// RouteAction_HashPolicy

// .envoy.api.v2.RouteAction.HashPolicy.Header header = 1;
inline bool RouteAction_HashPolicy::has_header() const {
  return policy_specifier_case() == kHeader;
}
inline void RouteAction_HashPolicy::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void RouteAction_HashPolicy::clear_header() {
  if (has_header()) {
    delete policy_specifier_.header_;
    clear_has_policy_specifier();
  }
}
inline  const ::envoy::api::v2::RouteAction_HashPolicy_Header& RouteAction_HashPolicy::header() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.header)
  return has_header()
      ? *policy_specifier_.header_
      : ::envoy::api::v2::RouteAction_HashPolicy_Header::default_instance();
}
inline ::envoy::api::v2::RouteAction_HashPolicy_Header* RouteAction_HashPolicy::mutable_header() {
  if (!has_header()) {
    clear_policy_specifier();
    set_has_header();
    policy_specifier_.header_ = new ::envoy::api::v2::RouteAction_HashPolicy_Header;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.header)
  return policy_specifier_.header_;
}
inline ::envoy::api::v2::RouteAction_HashPolicy_Header* RouteAction_HashPolicy::release_header() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.header)
  if (has_header()) {
    clear_has_policy_specifier();
    ::envoy::api::v2::RouteAction_HashPolicy_Header* temp = policy_specifier_.header_;
    policy_specifier_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RouteAction_HashPolicy::set_allocated_header(::envoy::api::v2::RouteAction_HashPolicy_Header* header) {
  clear_policy_specifier();
  if (header) {
    set_has_header();
    policy_specifier_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.header)
}

// .envoy.api.v2.RouteAction.HashPolicy.Cookie cookie = 2;
inline bool RouteAction_HashPolicy::has_cookie() const {
  return policy_specifier_case() == kCookie;
}
inline void RouteAction_HashPolicy::set_has_cookie() {
  _oneof_case_[0] = kCookie;
}
inline void RouteAction_HashPolicy::clear_cookie() {
  if (has_cookie()) {
    delete policy_specifier_.cookie_;
    clear_has_policy_specifier();
  }
}
inline  const ::envoy::api::v2::RouteAction_HashPolicy_Cookie& RouteAction_HashPolicy::cookie() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.cookie)
  return has_cookie()
      ? *policy_specifier_.cookie_
      : ::envoy::api::v2::RouteAction_HashPolicy_Cookie::default_instance();
}
inline ::envoy::api::v2::RouteAction_HashPolicy_Cookie* RouteAction_HashPolicy::mutable_cookie() {
  if (!has_cookie()) {
    clear_policy_specifier();
    set_has_cookie();
    policy_specifier_.cookie_ = new ::envoy::api::v2::RouteAction_HashPolicy_Cookie;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.cookie)
  return policy_specifier_.cookie_;
}
inline ::envoy::api::v2::RouteAction_HashPolicy_Cookie* RouteAction_HashPolicy::release_cookie() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.cookie)
  if (has_cookie()) {
    clear_has_policy_specifier();
    ::envoy::api::v2::RouteAction_HashPolicy_Cookie* temp = policy_specifier_.cookie_;
    policy_specifier_.cookie_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RouteAction_HashPolicy::set_allocated_cookie(::envoy::api::v2::RouteAction_HashPolicy_Cookie* cookie) {
  clear_policy_specifier();
  if (cookie) {
    set_has_cookie();
    policy_specifier_.cookie_ = cookie;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.cookie)
}

// .envoy.api.v2.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;
inline bool RouteAction_HashPolicy::has_connection_properties() const {
  return policy_specifier_case() == kConnectionProperties;
}
inline void RouteAction_HashPolicy::set_has_connection_properties() {
  _oneof_case_[0] = kConnectionProperties;
}
inline void RouteAction_HashPolicy::clear_connection_properties() {
  if (has_connection_properties()) {
    delete policy_specifier_.connection_properties_;
    clear_has_policy_specifier();
  }
}
inline  const ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties& RouteAction_HashPolicy::connection_properties() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.HashPolicy.connection_properties)
  return has_connection_properties()
      ? *policy_specifier_.connection_properties_
      : ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties::default_instance();
}
inline ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* RouteAction_HashPolicy::mutable_connection_properties() {
  if (!has_connection_properties()) {
    clear_policy_specifier();
    set_has_connection_properties();
    policy_specifier_.connection_properties_ = new ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.HashPolicy.connection_properties)
  return policy_specifier_.connection_properties_;
}
inline ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* RouteAction_HashPolicy::release_connection_properties() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.HashPolicy.connection_properties)
  if (has_connection_properties()) {
    clear_has_policy_specifier();
    ::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* temp = policy_specifier_.connection_properties_;
    policy_specifier_.connection_properties_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RouteAction_HashPolicy::set_allocated_connection_properties(::envoy::api::v2::RouteAction_HashPolicy_ConnectionProperties* connection_properties) {
  clear_policy_specifier();
  if (connection_properties) {
    set_has_connection_properties();
    policy_specifier_.connection_properties_ = connection_properties;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.HashPolicy.connection_properties)
}

inline bool RouteAction_HashPolicy::has_policy_specifier() const {
  return policy_specifier_case() != POLICY_SPECIFIER_NOT_SET;
}
inline void RouteAction_HashPolicy::clear_has_policy_specifier() {
  _oneof_case_[0] = POLICY_SPECIFIER_NOT_SET;
}
inline RouteAction_HashPolicy::PolicySpecifierCase RouteAction_HashPolicy::policy_specifier_case() const {
  return RouteAction_HashPolicy::PolicySpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RouteAction

// string cluster = 1;
inline bool RouteAction::has_cluster() const {
  return cluster_specifier_case() == kCluster;
}
inline void RouteAction::set_has_cluster() {
  _oneof_case_[0] = kCluster;
}
inline void RouteAction::clear_cluster() {
  if (has_cluster()) {
    cluster_specifier_.cluster_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_cluster_specifier();
  }
}
inline const ::std::string& RouteAction::cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.cluster)
  if (has_cluster()) {
    return cluster_specifier_.cluster_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAction::set_cluster(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster)
  if (!has_cluster()) {
    clear_cluster_specifier();
    set_has_cluster();
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster)
}
#if LANG_CXX11
inline void RouteAction::set_cluster(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster)
  if (!has_cluster()) {
    clear_cluster_specifier();
    set_has_cluster();
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.cluster)
}
#endif
inline void RouteAction::set_cluster(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_cluster()) {
    clear_cluster_specifier();
    set_has_cluster();
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.cluster)
}
inline void RouteAction::set_cluster(const char* value, size_t size) {
  if (!has_cluster()) {
    clear_cluster_specifier();
    set_has_cluster();
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.cluster)
}
inline ::std::string* RouteAction::mutable_cluster() {
  if (!has_cluster()) {
    clear_cluster_specifier();
    set_has_cluster();
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.cluster)
  return cluster_specifier_.cluster_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction::release_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.cluster)
  if (has_cluster()) {
    clear_has_cluster_specifier();
    return cluster_specifier_.cluster_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteAction::set_allocated_cluster(::std::string* cluster) {
  if (!has_cluster()) {
    cluster_specifier_.cluster_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_cluster_specifier();
  if (cluster != NULL) {
    set_has_cluster();
    cluster_specifier_.cluster_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        cluster);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.cluster)
}

// string cluster_header = 2;
inline bool RouteAction::has_cluster_header() const {
  return cluster_specifier_case() == kClusterHeader;
}
inline void RouteAction::set_has_cluster_header() {
  _oneof_case_[0] = kClusterHeader;
}
inline void RouteAction::clear_cluster_header() {
  if (has_cluster_header()) {
    cluster_specifier_.cluster_header_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_cluster_specifier();
  }
}
inline const ::std::string& RouteAction::cluster_header() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.cluster_header)
  if (has_cluster_header()) {
    return cluster_specifier_.cluster_header_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAction::set_cluster_header(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster_header)
  if (!has_cluster_header()) {
    clear_cluster_specifier();
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster_header)
}
#if LANG_CXX11
inline void RouteAction::set_cluster_header(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.cluster_header)
  if (!has_cluster_header()) {
    clear_cluster_specifier();
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_header_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.cluster_header)
}
#endif
inline void RouteAction::set_cluster_header(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_cluster_header()) {
    clear_cluster_specifier();
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.cluster_header)
}
inline void RouteAction::set_cluster_header(const char* value, size_t size) {
  if (!has_cluster_header()) {
    clear_cluster_specifier();
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  cluster_specifier_.cluster_header_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.cluster_header)
}
inline ::std::string* RouteAction::mutable_cluster_header() {
  if (!has_cluster_header()) {
    clear_cluster_specifier();
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.cluster_header)
  return cluster_specifier_.cluster_header_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction::release_cluster_header() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.cluster_header)
  if (has_cluster_header()) {
    clear_has_cluster_specifier();
    return cluster_specifier_.cluster_header_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteAction::set_allocated_cluster_header(::std::string* cluster_header) {
  if (!has_cluster_header()) {
    cluster_specifier_.cluster_header_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_cluster_specifier();
  if (cluster_header != NULL) {
    set_has_cluster_header();
    cluster_specifier_.cluster_header_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        cluster_header);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.cluster_header)
}

// .envoy.api.v2.WeightedCluster weighted_clusters = 3;
inline bool RouteAction::has_weighted_clusters() const {
  return cluster_specifier_case() == kWeightedClusters;
}
inline void RouteAction::set_has_weighted_clusters() {
  _oneof_case_[0] = kWeightedClusters;
}
inline void RouteAction::clear_weighted_clusters() {
  if (has_weighted_clusters()) {
    delete cluster_specifier_.weighted_clusters_;
    clear_has_cluster_specifier();
  }
}
inline  const ::envoy::api::v2::WeightedCluster& RouteAction::weighted_clusters() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.weighted_clusters)
  return has_weighted_clusters()
      ? *cluster_specifier_.weighted_clusters_
      : ::envoy::api::v2::WeightedCluster::default_instance();
}
inline ::envoy::api::v2::WeightedCluster* RouteAction::mutable_weighted_clusters() {
  if (!has_weighted_clusters()) {
    clear_cluster_specifier();
    set_has_weighted_clusters();
    cluster_specifier_.weighted_clusters_ = new ::envoy::api::v2::WeightedCluster;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.weighted_clusters)
  return cluster_specifier_.weighted_clusters_;
}
inline ::envoy::api::v2::WeightedCluster* RouteAction::release_weighted_clusters() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.weighted_clusters)
  if (has_weighted_clusters()) {
    clear_has_cluster_specifier();
    ::envoy::api::v2::WeightedCluster* temp = cluster_specifier_.weighted_clusters_;
    cluster_specifier_.weighted_clusters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RouteAction::set_allocated_weighted_clusters(::envoy::api::v2::WeightedCluster* weighted_clusters) {
  clear_cluster_specifier();
  if (weighted_clusters) {
    set_has_weighted_clusters();
    cluster_specifier_.weighted_clusters_ = weighted_clusters;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.weighted_clusters)
}

// .envoy.api.v2.Metadata metadata_match = 4;
inline bool RouteAction::has_metadata_match() const {
  return this != internal_default_instance() && metadata_match_ != NULL;
}
inline void RouteAction::clear_metadata_match() {
  if (GetArenaNoVirtual() == NULL && metadata_match_ != NULL) delete metadata_match_;
  metadata_match_ = NULL;
}
inline const ::envoy::api::v2::Metadata& RouteAction::metadata_match() const {
  const ::envoy::api::v2::Metadata* p = metadata_match_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.metadata_match)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Metadata*>(
      &::envoy::api::v2::_Metadata_default_instance_);
}
inline ::envoy::api::v2::Metadata* RouteAction::mutable_metadata_match() {
  
  if (metadata_match_ == NULL) {
    metadata_match_ = new ::envoy::api::v2::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.metadata_match)
  return metadata_match_;
}
inline ::envoy::api::v2::Metadata* RouteAction::release_metadata_match() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.metadata_match)
  
  ::envoy::api::v2::Metadata* temp = metadata_match_;
  metadata_match_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_metadata_match(::envoy::api::v2::Metadata* metadata_match) {
  delete metadata_match_;
  metadata_match_ = metadata_match;
  if (metadata_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.metadata_match)
}

// string prefix_rewrite = 5;
inline void RouteAction::clear_prefix_rewrite() {
  prefix_rewrite_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteAction::prefix_rewrite() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.prefix_rewrite)
  return prefix_rewrite_.GetNoArena();
}
inline void RouteAction::set_prefix_rewrite(const ::std::string& value) {
  
  prefix_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.prefix_rewrite)
}
#if LANG_CXX11
inline void RouteAction::set_prefix_rewrite(::std::string&& value) {
  
  prefix_rewrite_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.prefix_rewrite)
}
#endif
inline void RouteAction::set_prefix_rewrite(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prefix_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.prefix_rewrite)
}
inline void RouteAction::set_prefix_rewrite(const char* value, size_t size) {
  
  prefix_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.prefix_rewrite)
}
inline ::std::string* RouteAction::mutable_prefix_rewrite() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.prefix_rewrite)
  return prefix_rewrite_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction::release_prefix_rewrite() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.prefix_rewrite)
  
  return prefix_rewrite_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteAction::set_allocated_prefix_rewrite(::std::string* prefix_rewrite) {
  if (prefix_rewrite != NULL) {
    
  } else {
    
  }
  prefix_rewrite_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prefix_rewrite);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.prefix_rewrite)
}

// string host_rewrite = 6;
inline bool RouteAction::has_host_rewrite() const {
  return host_rewrite_specifier_case() == kHostRewrite;
}
inline void RouteAction::set_has_host_rewrite() {
  _oneof_case_[1] = kHostRewrite;
}
inline void RouteAction::clear_host_rewrite() {
  if (has_host_rewrite()) {
    host_rewrite_specifier_.host_rewrite_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_host_rewrite_specifier();
  }
}
inline const ::std::string& RouteAction::host_rewrite() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.host_rewrite)
  if (has_host_rewrite()) {
    return host_rewrite_specifier_.host_rewrite_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RouteAction::set_host_rewrite(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.host_rewrite)
  if (!has_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  host_rewrite_specifier_.host_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.host_rewrite)
}
#if LANG_CXX11
inline void RouteAction::set_host_rewrite(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.host_rewrite)
  if (!has_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  host_rewrite_specifier_.host_rewrite_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteAction.host_rewrite)
}
#endif
inline void RouteAction::set_host_rewrite(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  host_rewrite_specifier_.host_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteAction.host_rewrite)
}
inline void RouteAction::set_host_rewrite(const char* value, size_t size) {
  if (!has_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  host_rewrite_specifier_.host_rewrite_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteAction.host_rewrite)
}
inline ::std::string* RouteAction::mutable_host_rewrite() {
  if (!has_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.host_rewrite)
  return host_rewrite_specifier_.host_rewrite_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteAction::release_host_rewrite() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.host_rewrite)
  if (has_host_rewrite()) {
    clear_has_host_rewrite_specifier();
    return host_rewrite_specifier_.host_rewrite_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RouteAction::set_allocated_host_rewrite(::std::string* host_rewrite) {
  if (!has_host_rewrite()) {
    host_rewrite_specifier_.host_rewrite_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_host_rewrite_specifier();
  if (host_rewrite != NULL) {
    set_has_host_rewrite();
    host_rewrite_specifier_.host_rewrite_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        host_rewrite);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.host_rewrite)
}

// .google.protobuf.BoolValue auto_host_rewrite = 7;
inline bool RouteAction::has_auto_host_rewrite() const {
  return host_rewrite_specifier_case() == kAutoHostRewrite;
}
inline void RouteAction::set_has_auto_host_rewrite() {
  _oneof_case_[1] = kAutoHostRewrite;
}
inline void RouteAction::clear_auto_host_rewrite() {
  if (has_auto_host_rewrite()) {
    delete host_rewrite_specifier_.auto_host_rewrite_;
    clear_has_host_rewrite_specifier();
  }
}
inline  const ::google::protobuf::BoolValue& RouteAction::auto_host_rewrite() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.auto_host_rewrite)
  return has_auto_host_rewrite()
      ? *host_rewrite_specifier_.auto_host_rewrite_
      : ::google::protobuf::BoolValue::default_instance();
}
inline ::google::protobuf::BoolValue* RouteAction::mutable_auto_host_rewrite() {
  if (!has_auto_host_rewrite()) {
    clear_host_rewrite_specifier();
    set_has_auto_host_rewrite();
    host_rewrite_specifier_.auto_host_rewrite_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.auto_host_rewrite)
  return host_rewrite_specifier_.auto_host_rewrite_;
}
inline ::google::protobuf::BoolValue* RouteAction::release_auto_host_rewrite() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.auto_host_rewrite)
  if (has_auto_host_rewrite()) {
    clear_has_host_rewrite_specifier();
    ::google::protobuf::BoolValue* temp = host_rewrite_specifier_.auto_host_rewrite_;
    host_rewrite_specifier_.auto_host_rewrite_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RouteAction::set_allocated_auto_host_rewrite(::google::protobuf::BoolValue* auto_host_rewrite) {
  clear_host_rewrite_specifier();
  if (auto_host_rewrite) {
    if (static_cast< ::google::protobuf::BoolValue*>(auto_host_rewrite)->GetArena() != NULL) {
      ::google::protobuf::BoolValue* new_auto_host_rewrite = new ::google::protobuf::BoolValue;
      new_auto_host_rewrite->CopyFrom(*auto_host_rewrite);
      auto_host_rewrite = new_auto_host_rewrite;
    }
    set_has_auto_host_rewrite();
    host_rewrite_specifier_.auto_host_rewrite_ = auto_host_rewrite;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.auto_host_rewrite)
}

// .google.protobuf.Duration timeout = 8;
inline bool RouteAction::has_timeout() const {
  return this != internal_default_instance() && timeout_ != NULL;
}
inline void RouteAction::clear_timeout() {
  if (GetArenaNoVirtual() == NULL && timeout_ != NULL) delete timeout_;
  timeout_ = NULL;
}
inline const ::google::protobuf::Duration& RouteAction::timeout() const {
  const ::google::protobuf::Duration* p = timeout_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Duration*>(
      &::google::protobuf::_Duration_default_instance_);
}
inline ::google::protobuf::Duration* RouteAction::mutable_timeout() {
  
  if (timeout_ == NULL) {
    timeout_ = new ::google::protobuf::Duration;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.timeout)
  return timeout_;
}
inline ::google::protobuf::Duration* RouteAction::release_timeout() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.timeout)
  
  ::google::protobuf::Duration* temp = timeout_;
  timeout_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_timeout(::google::protobuf::Duration* timeout) {
  delete timeout_;
  if (timeout != NULL && timeout->GetArena() != NULL) {
    ::google::protobuf::Duration* new_timeout = new ::google::protobuf::Duration;
    new_timeout->CopyFrom(*timeout);
    timeout = new_timeout;
  }
  timeout_ = timeout;
  if (timeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.timeout)
}

// .envoy.api.v2.RouteAction.RetryPolicy retry_policy = 9;
inline bool RouteAction::has_retry_policy() const {
  return this != internal_default_instance() && retry_policy_ != NULL;
}
inline void RouteAction::clear_retry_policy() {
  if (GetArenaNoVirtual() == NULL && retry_policy_ != NULL) delete retry_policy_;
  retry_policy_ = NULL;
}
inline const ::envoy::api::v2::RouteAction_RetryPolicy& RouteAction::retry_policy() const {
  const ::envoy::api::v2::RouteAction_RetryPolicy* p = retry_policy_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.retry_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RouteAction_RetryPolicy*>(
      &::envoy::api::v2::_RouteAction_RetryPolicy_default_instance_);
}
inline ::envoy::api::v2::RouteAction_RetryPolicy* RouteAction::mutable_retry_policy() {
  
  if (retry_policy_ == NULL) {
    retry_policy_ = new ::envoy::api::v2::RouteAction_RetryPolicy;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.retry_policy)
  return retry_policy_;
}
inline ::envoy::api::v2::RouteAction_RetryPolicy* RouteAction::release_retry_policy() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.retry_policy)
  
  ::envoy::api::v2::RouteAction_RetryPolicy* temp = retry_policy_;
  retry_policy_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_retry_policy(::envoy::api::v2::RouteAction_RetryPolicy* retry_policy) {
  delete retry_policy_;
  retry_policy_ = retry_policy;
  if (retry_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.retry_policy)
}

// .envoy.api.v2.RouteAction.RequestMirrorPolicy request_mirror_policy = 10;
inline bool RouteAction::has_request_mirror_policy() const {
  return this != internal_default_instance() && request_mirror_policy_ != NULL;
}
inline void RouteAction::clear_request_mirror_policy() {
  if (GetArenaNoVirtual() == NULL && request_mirror_policy_ != NULL) delete request_mirror_policy_;
  request_mirror_policy_ = NULL;
}
inline const ::envoy::api::v2::RouteAction_RequestMirrorPolicy& RouteAction::request_mirror_policy() const {
  const ::envoy::api::v2::RouteAction_RequestMirrorPolicy* p = request_mirror_policy_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.request_mirror_policy)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RouteAction_RequestMirrorPolicy*>(
      &::envoy::api::v2::_RouteAction_RequestMirrorPolicy_default_instance_);
}
inline ::envoy::api::v2::RouteAction_RequestMirrorPolicy* RouteAction::mutable_request_mirror_policy() {
  
  if (request_mirror_policy_ == NULL) {
    request_mirror_policy_ = new ::envoy::api::v2::RouteAction_RequestMirrorPolicy;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.request_mirror_policy)
  return request_mirror_policy_;
}
inline ::envoy::api::v2::RouteAction_RequestMirrorPolicy* RouteAction::release_request_mirror_policy() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.request_mirror_policy)
  
  ::envoy::api::v2::RouteAction_RequestMirrorPolicy* temp = request_mirror_policy_;
  request_mirror_policy_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_request_mirror_policy(::envoy::api::v2::RouteAction_RequestMirrorPolicy* request_mirror_policy) {
  delete request_mirror_policy_;
  request_mirror_policy_ = request_mirror_policy;
  if (request_mirror_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.request_mirror_policy)
}

// .envoy.api.v2.RoutingPriority priority = 11;
inline void RouteAction::clear_priority() {
  priority_ = 0;
}
inline ::envoy::api::v2::RoutingPriority RouteAction::priority() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.priority)
  return static_cast< ::envoy::api::v2::RoutingPriority >(priority_);
}
inline void RouteAction::set_priority(::envoy::api::v2::RoutingPriority value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteAction.priority)
}

// repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 12;
inline int RouteAction::request_headers_to_add_size() const {
  return request_headers_to_add_.size();
}
inline void RouteAction::clear_request_headers_to_add() {
  request_headers_to_add_.Clear();
}
inline const ::envoy::api::v2::HeaderValueOption& RouteAction::request_headers_to_add(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.request_headers_to_add)
  return request_headers_to_add_.Get(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteAction::mutable_request_headers_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.request_headers_to_add)
  return request_headers_to_add_.Mutable(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteAction::add_request_headers_to_add() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteAction.request_headers_to_add)
  return request_headers_to_add_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
RouteAction::mutable_request_headers_to_add() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteAction.request_headers_to_add)
  return &request_headers_to_add_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
RouteAction::request_headers_to_add() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteAction.request_headers_to_add)
  return request_headers_to_add_;
}

// repeated .envoy.api.v2.RateLimit rate_limits = 13;
inline int RouteAction::rate_limits_size() const {
  return rate_limits_.size();
}
inline void RouteAction::clear_rate_limits() {
  rate_limits_.Clear();
}
inline const ::envoy::api::v2::RateLimit& RouteAction::rate_limits(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.rate_limits)
  return rate_limits_.Get(index);
}
inline ::envoy::api::v2::RateLimit* RouteAction::mutable_rate_limits(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.rate_limits)
  return rate_limits_.Mutable(index);
}
inline ::envoy::api::v2::RateLimit* RouteAction::add_rate_limits() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteAction.rate_limits)
  return rate_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >*
RouteAction::mutable_rate_limits() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteAction.rate_limits)
  return &rate_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >&
RouteAction::rate_limits() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteAction.rate_limits)
  return rate_limits_;
}

// .google.protobuf.BoolValue include_vh_rate_limits = 14;
inline bool RouteAction::has_include_vh_rate_limits() const {
  return this != internal_default_instance() && include_vh_rate_limits_ != NULL;
}
inline void RouteAction::clear_include_vh_rate_limits() {
  if (GetArenaNoVirtual() == NULL && include_vh_rate_limits_ != NULL) delete include_vh_rate_limits_;
  include_vh_rate_limits_ = NULL;
}
inline const ::google::protobuf::BoolValue& RouteAction::include_vh_rate_limits() const {
  const ::google::protobuf::BoolValue* p = include_vh_rate_limits_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.include_vh_rate_limits)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* RouteAction::mutable_include_vh_rate_limits() {
  
  if (include_vh_rate_limits_ == NULL) {
    include_vh_rate_limits_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.include_vh_rate_limits)
  return include_vh_rate_limits_;
}
inline ::google::protobuf::BoolValue* RouteAction::release_include_vh_rate_limits() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.include_vh_rate_limits)
  
  ::google::protobuf::BoolValue* temp = include_vh_rate_limits_;
  include_vh_rate_limits_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_include_vh_rate_limits(::google::protobuf::BoolValue* include_vh_rate_limits) {
  delete include_vh_rate_limits_;
  if (include_vh_rate_limits != NULL && include_vh_rate_limits->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_include_vh_rate_limits = new ::google::protobuf::BoolValue;
    new_include_vh_rate_limits->CopyFrom(*include_vh_rate_limits);
    include_vh_rate_limits = new_include_vh_rate_limits;
  }
  include_vh_rate_limits_ = include_vh_rate_limits;
  if (include_vh_rate_limits) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.include_vh_rate_limits)
}

// repeated .envoy.api.v2.RouteAction.HashPolicy hash_policy = 15;
inline int RouteAction::hash_policy_size() const {
  return hash_policy_.size();
}
inline void RouteAction::clear_hash_policy() {
  hash_policy_.Clear();
}
inline const ::envoy::api::v2::RouteAction_HashPolicy& RouteAction::hash_policy(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.hash_policy)
  return hash_policy_.Get(index);
}
inline ::envoy::api::v2::RouteAction_HashPolicy* RouteAction::mutable_hash_policy(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.hash_policy)
  return hash_policy_.Mutable(index);
}
inline ::envoy::api::v2::RouteAction_HashPolicy* RouteAction::add_hash_policy() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteAction.hash_policy)
  return hash_policy_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RouteAction_HashPolicy >*
RouteAction::mutable_hash_policy() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteAction.hash_policy)
  return &hash_policy_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RouteAction_HashPolicy >&
RouteAction::hash_policy() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteAction.hash_policy)
  return hash_policy_;
}

// .google.protobuf.BoolValue use_websocket = 16;
inline bool RouteAction::has_use_websocket() const {
  return this != internal_default_instance() && use_websocket_ != NULL;
}
inline void RouteAction::clear_use_websocket() {
  if (GetArenaNoVirtual() == NULL && use_websocket_ != NULL) delete use_websocket_;
  use_websocket_ = NULL;
}
inline const ::google::protobuf::BoolValue& RouteAction::use_websocket() const {
  const ::google::protobuf::BoolValue* p = use_websocket_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.use_websocket)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* RouteAction::mutable_use_websocket() {
  
  if (use_websocket_ == NULL) {
    use_websocket_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.use_websocket)
  return use_websocket_;
}
inline ::google::protobuf::BoolValue* RouteAction::release_use_websocket() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.use_websocket)
  
  ::google::protobuf::BoolValue* temp = use_websocket_;
  use_websocket_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_use_websocket(::google::protobuf::BoolValue* use_websocket) {
  delete use_websocket_;
  if (use_websocket != NULL && use_websocket->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_use_websocket = new ::google::protobuf::BoolValue;
    new_use_websocket->CopyFrom(*use_websocket);
    use_websocket = new_use_websocket;
  }
  use_websocket_ = use_websocket;
  if (use_websocket) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.use_websocket)
}

// .envoy.api.v2.CorsPolicy cors = 17;
inline bool RouteAction::has_cors() const {
  return this != internal_default_instance() && cors_ != NULL;
}
inline void RouteAction::clear_cors() {
  if (GetArenaNoVirtual() == NULL && cors_ != NULL) delete cors_;
  cors_ = NULL;
}
inline const ::envoy::api::v2::CorsPolicy& RouteAction::cors() const {
  const ::envoy::api::v2::CorsPolicy* p = cors_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteAction.cors)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::CorsPolicy*>(
      &::envoy::api::v2::_CorsPolicy_default_instance_);
}
inline ::envoy::api::v2::CorsPolicy* RouteAction::mutable_cors() {
  
  if (cors_ == NULL) {
    cors_ = new ::envoy::api::v2::CorsPolicy;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteAction.cors)
  return cors_;
}
inline ::envoy::api::v2::CorsPolicy* RouteAction::release_cors() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteAction.cors)
  
  ::envoy::api::v2::CorsPolicy* temp = cors_;
  cors_ = NULL;
  return temp;
}
inline void RouteAction::set_allocated_cors(::envoy::api::v2::CorsPolicy* cors) {
  delete cors_;
  cors_ = cors;
  if (cors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteAction.cors)
}

inline bool RouteAction::has_cluster_specifier() const {
  return cluster_specifier_case() != CLUSTER_SPECIFIER_NOT_SET;
}
inline void RouteAction::clear_has_cluster_specifier() {
  _oneof_case_[0] = CLUSTER_SPECIFIER_NOT_SET;
}
inline bool RouteAction::has_host_rewrite_specifier() const {
  return host_rewrite_specifier_case() != HOST_REWRITE_SPECIFIER_NOT_SET;
}
inline void RouteAction::clear_has_host_rewrite_specifier() {
  _oneof_case_[1] = HOST_REWRITE_SPECIFIER_NOT_SET;
}
inline RouteAction::ClusterSpecifierCase RouteAction::cluster_specifier_case() const {
  return RouteAction::ClusterSpecifierCase(_oneof_case_[0]);
}
inline RouteAction::HostRewriteSpecifierCase RouteAction::host_rewrite_specifier_case() const {
  return RouteAction::HostRewriteSpecifierCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// RedirectAction

// string host_redirect = 1;
inline void RedirectAction::clear_host_redirect() {
  host_redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedirectAction::host_redirect() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RedirectAction.host_redirect)
  return host_redirect_.GetNoArena();
}
inline void RedirectAction::set_host_redirect(const ::std::string& value) {
  
  host_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RedirectAction.host_redirect)
}
#if LANG_CXX11
inline void RedirectAction::set_host_redirect(::std::string&& value) {
  
  host_redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RedirectAction.host_redirect)
}
#endif
inline void RedirectAction::set_host_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RedirectAction.host_redirect)
}
inline void RedirectAction::set_host_redirect(const char* value, size_t size) {
  
  host_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RedirectAction.host_redirect)
}
inline ::std::string* RedirectAction::mutable_host_redirect() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RedirectAction.host_redirect)
  return host_redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectAction::release_host_redirect() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RedirectAction.host_redirect)
  
  return host_redirect_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectAction::set_allocated_host_redirect(::std::string* host_redirect) {
  if (host_redirect != NULL) {
    
  } else {
    
  }
  host_redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_redirect);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RedirectAction.host_redirect)
}

// string path_redirect = 2;
inline void RedirectAction::clear_path_redirect() {
  path_redirect_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RedirectAction::path_redirect() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RedirectAction.path_redirect)
  return path_redirect_.GetNoArena();
}
inline void RedirectAction::set_path_redirect(const ::std::string& value) {
  
  path_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RedirectAction.path_redirect)
}
#if LANG_CXX11
inline void RedirectAction::set_path_redirect(::std::string&& value) {
  
  path_redirect_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RedirectAction.path_redirect)
}
#endif
inline void RedirectAction::set_path_redirect(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  path_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RedirectAction.path_redirect)
}
inline void RedirectAction::set_path_redirect(const char* value, size_t size) {
  
  path_redirect_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RedirectAction.path_redirect)
}
inline ::std::string* RedirectAction::mutable_path_redirect() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RedirectAction.path_redirect)
  return path_redirect_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RedirectAction::release_path_redirect() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RedirectAction.path_redirect)
  
  return path_redirect_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RedirectAction::set_allocated_path_redirect(::std::string* path_redirect) {
  if (path_redirect != NULL) {
    
  } else {
    
  }
  path_redirect_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_redirect);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RedirectAction.path_redirect)
}

// -------------------------------------------------------------------

// Decorator

// string operation = 1;
inline void Decorator::clear_operation() {
  operation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Decorator::operation() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Decorator.operation)
  return operation_.GetNoArena();
}
inline void Decorator::set_operation(const ::std::string& value) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Decorator.operation)
}
#if LANG_CXX11
inline void Decorator::set_operation(::std::string&& value) {
  
  operation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Decorator.operation)
}
#endif
inline void Decorator::set_operation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Decorator.operation)
}
inline void Decorator::set_operation(const char* value, size_t size) {
  
  operation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Decorator.operation)
}
inline ::std::string* Decorator::mutable_operation() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Decorator.operation)
  return operation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Decorator::release_operation() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Decorator.operation)
  
  return operation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Decorator::set_allocated_operation(::std::string* operation) {
  if (operation != NULL) {
    
  } else {
    
  }
  operation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), operation);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Decorator.operation)
}

// -------------------------------------------------------------------

// Route

// .envoy.api.v2.RouteMatch match = 1;
inline bool Route::has_match() const {
  return this != internal_default_instance() && match_ != NULL;
}
inline void Route::clear_match() {
  if (GetArenaNoVirtual() == NULL && match_ != NULL) delete match_;
  match_ = NULL;
}
inline const ::envoy::api::v2::RouteMatch& Route::match() const {
  const ::envoy::api::v2::RouteMatch* p = match_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Route.match)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::RouteMatch*>(
      &::envoy::api::v2::_RouteMatch_default_instance_);
}
inline ::envoy::api::v2::RouteMatch* Route::mutable_match() {
  
  if (match_ == NULL) {
    match_ = new ::envoy::api::v2::RouteMatch;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Route.match)
  return match_;
}
inline ::envoy::api::v2::RouteMatch* Route::release_match() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Route.match)
  
  ::envoy::api::v2::RouteMatch* temp = match_;
  match_ = NULL;
  return temp;
}
inline void Route::set_allocated_match(::envoy::api::v2::RouteMatch* match) {
  delete match_;
  match_ = match;
  if (match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Route.match)
}

// .envoy.api.v2.RouteAction route = 2;
inline bool Route::has_route() const {
  return action_case() == kRoute;
}
inline void Route::set_has_route() {
  _oneof_case_[0] = kRoute;
}
inline void Route::clear_route() {
  if (has_route()) {
    delete action_.route_;
    clear_has_action();
  }
}
inline  const ::envoy::api::v2::RouteAction& Route::route() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Route.route)
  return has_route()
      ? *action_.route_
      : ::envoy::api::v2::RouteAction::default_instance();
}
inline ::envoy::api::v2::RouteAction* Route::mutable_route() {
  if (!has_route()) {
    clear_action();
    set_has_route();
    action_.route_ = new ::envoy::api::v2::RouteAction;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Route.route)
  return action_.route_;
}
inline ::envoy::api::v2::RouteAction* Route::release_route() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Route.route)
  if (has_route()) {
    clear_has_action();
    ::envoy::api::v2::RouteAction* temp = action_.route_;
    action_.route_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Route::set_allocated_route(::envoy::api::v2::RouteAction* route) {
  clear_action();
  if (route) {
    set_has_route();
    action_.route_ = route;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Route.route)
}

// .envoy.api.v2.RedirectAction redirect = 3;
inline bool Route::has_redirect() const {
  return action_case() == kRedirect;
}
inline void Route::set_has_redirect() {
  _oneof_case_[0] = kRedirect;
}
inline void Route::clear_redirect() {
  if (has_redirect()) {
    delete action_.redirect_;
    clear_has_action();
  }
}
inline  const ::envoy::api::v2::RedirectAction& Route::redirect() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Route.redirect)
  return has_redirect()
      ? *action_.redirect_
      : ::envoy::api::v2::RedirectAction::default_instance();
}
inline ::envoy::api::v2::RedirectAction* Route::mutable_redirect() {
  if (!has_redirect()) {
    clear_action();
    set_has_redirect();
    action_.redirect_ = new ::envoy::api::v2::RedirectAction;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Route.redirect)
  return action_.redirect_;
}
inline ::envoy::api::v2::RedirectAction* Route::release_redirect() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Route.redirect)
  if (has_redirect()) {
    clear_has_action();
    ::envoy::api::v2::RedirectAction* temp = action_.redirect_;
    action_.redirect_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Route::set_allocated_redirect(::envoy::api::v2::RedirectAction* redirect) {
  clear_action();
  if (redirect) {
    set_has_redirect();
    action_.redirect_ = redirect;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Route.redirect)
}

// .envoy.api.v2.Metadata metadata = 4;
inline bool Route::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline void Route::clear_metadata() {
  if (GetArenaNoVirtual() == NULL && metadata_ != NULL) delete metadata_;
  metadata_ = NULL;
}
inline const ::envoy::api::v2::Metadata& Route::metadata() const {
  const ::envoy::api::v2::Metadata* p = metadata_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Route.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Metadata*>(
      &::envoy::api::v2::_Metadata_default_instance_);
}
inline ::envoy::api::v2::Metadata* Route::mutable_metadata() {
  
  if (metadata_ == NULL) {
    metadata_ = new ::envoy::api::v2::Metadata;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Route.metadata)
  return metadata_;
}
inline ::envoy::api::v2::Metadata* Route::release_metadata() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Route.metadata)
  
  ::envoy::api::v2::Metadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void Route::set_allocated_metadata(::envoy::api::v2::Metadata* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Route.metadata)
}

// .envoy.api.v2.Decorator decorator = 5;
inline bool Route::has_decorator() const {
  return this != internal_default_instance() && decorator_ != NULL;
}
inline void Route::clear_decorator() {
  if (GetArenaNoVirtual() == NULL && decorator_ != NULL) delete decorator_;
  decorator_ = NULL;
}
inline const ::envoy::api::v2::Decorator& Route::decorator() const {
  const ::envoy::api::v2::Decorator* p = decorator_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.Route.decorator)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::Decorator*>(
      &::envoy::api::v2::_Decorator_default_instance_);
}
inline ::envoy::api::v2::Decorator* Route::mutable_decorator() {
  
  if (decorator_ == NULL) {
    decorator_ = new ::envoy::api::v2::Decorator;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Route.decorator)
  return decorator_;
}
inline ::envoy::api::v2::Decorator* Route::release_decorator() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Route.decorator)
  
  ::envoy::api::v2::Decorator* temp = decorator_;
  decorator_ = NULL;
  return temp;
}
inline void Route::set_allocated_decorator(::envoy::api::v2::Decorator* decorator) {
  delete decorator_;
  decorator_ = decorator;
  if (decorator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Route.decorator)
}

inline bool Route::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Route::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline Route::ActionCase Route::action_case() const {
  return Route::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VirtualCluster

// string pattern = 1;
inline void VirtualCluster::clear_pattern() {
  pattern_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VirtualCluster::pattern() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualCluster.pattern)
  return pattern_.GetNoArena();
}
inline void VirtualCluster::set_pattern(const ::std::string& value) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualCluster.pattern)
}
#if LANG_CXX11
inline void VirtualCluster::set_pattern(::std::string&& value) {
  
  pattern_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.VirtualCluster.pattern)
}
#endif
inline void VirtualCluster::set_pattern(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.VirtualCluster.pattern)
}
inline void VirtualCluster::set_pattern(const char* value, size_t size) {
  
  pattern_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.VirtualCluster.pattern)
}
inline ::std::string* VirtualCluster::mutable_pattern() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualCluster.pattern)
  return pattern_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VirtualCluster::release_pattern() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.VirtualCluster.pattern)
  
  return pattern_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VirtualCluster::set_allocated_pattern(::std::string* pattern) {
  if (pattern != NULL) {
    
  } else {
    
  }
  pattern_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pattern);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.VirtualCluster.pattern)
}

// string name = 2;
inline void VirtualCluster::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VirtualCluster::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualCluster.name)
  return name_.GetNoArena();
}
inline void VirtualCluster::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualCluster.name)
}
#if LANG_CXX11
inline void VirtualCluster::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.VirtualCluster.name)
}
#endif
inline void VirtualCluster::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.VirtualCluster.name)
}
inline void VirtualCluster::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.VirtualCluster.name)
}
inline ::std::string* VirtualCluster::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualCluster.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VirtualCluster::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.VirtualCluster.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VirtualCluster::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.VirtualCluster.name)
}

// .envoy.api.v2.RequestMethod method = 3;
inline void VirtualCluster::clear_method() {
  method_ = 0;
}
inline ::envoy::api::v2::RequestMethod VirtualCluster::method() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualCluster.method)
  return static_cast< ::envoy::api::v2::RequestMethod >(method_);
}
inline void VirtualCluster::set_method(::envoy::api::v2::RequestMethod value) {
  
  method_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualCluster.method)
}

// -------------------------------------------------------------------

// RateLimit_Action_SourceCluster

// -------------------------------------------------------------------

// RateLimit_Action_DestinationCluster

// -------------------------------------------------------------------

// RateLimit_Action_RequestHeaders

// string header_name = 1;
inline void RateLimit_Action_RequestHeaders::clear_header_name() {
  header_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimit_Action_RequestHeaders::header_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
  return header_name_.GetNoArena();
}
inline void RateLimit_Action_RequestHeaders::set_header_name(const ::std::string& value) {
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
}
#if LANG_CXX11
inline void RateLimit_Action_RequestHeaders::set_header_name(::std::string&& value) {
  
  header_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
}
#endif
inline void RateLimit_Action_RequestHeaders::set_header_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
}
inline void RateLimit_Action_RequestHeaders::set_header_name(const char* value, size_t size) {
  
  header_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
}
inline ::std::string* RateLimit_Action_RequestHeaders::mutable_header_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
  return header_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimit_Action_RequestHeaders::release_header_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
  
  return header_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimit_Action_RequestHeaders::set_allocated_header_name(::std::string* header_name) {
  if (header_name != NULL) {
    
  } else {
    
  }
  header_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), header_name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.RequestHeaders.header_name)
}

// string descriptor_key = 2;
inline void RateLimit_Action_RequestHeaders::clear_descriptor_key() {
  descriptor_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimit_Action_RequestHeaders::descriptor_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
  return descriptor_key_.GetNoArena();
}
inline void RateLimit_Action_RequestHeaders::set_descriptor_key(const ::std::string& value) {
  
  descriptor_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
}
#if LANG_CXX11
inline void RateLimit_Action_RequestHeaders::set_descriptor_key(::std::string&& value) {
  
  descriptor_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
}
#endif
inline void RateLimit_Action_RequestHeaders::set_descriptor_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  descriptor_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
}
inline void RateLimit_Action_RequestHeaders::set_descriptor_key(const char* value, size_t size) {
  
  descriptor_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
}
inline ::std::string* RateLimit_Action_RequestHeaders::mutable_descriptor_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
  return descriptor_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimit_Action_RequestHeaders::release_descriptor_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
  
  return descriptor_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimit_Action_RequestHeaders::set_allocated_descriptor_key(::std::string* descriptor_key) {
  if (descriptor_key != NULL) {
    
  } else {
    
  }
  descriptor_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), descriptor_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.RequestHeaders.descriptor_key)
}

// -------------------------------------------------------------------

// RateLimit_Action_RemoteAddress

// -------------------------------------------------------------------

// RateLimit_Action_GenericKey

// string descriptor_value = 1;
inline void RateLimit_Action_GenericKey::clear_descriptor_value() {
  descriptor_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimit_Action_GenericKey::descriptor_value() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
  return descriptor_value_.GetNoArena();
}
inline void RateLimit_Action_GenericKey::set_descriptor_value(const ::std::string& value) {
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
}
#if LANG_CXX11
inline void RateLimit_Action_GenericKey::set_descriptor_value(::std::string&& value) {
  
  descriptor_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
}
#endif
inline void RateLimit_Action_GenericKey::set_descriptor_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
}
inline void RateLimit_Action_GenericKey::set_descriptor_value(const char* value, size_t size) {
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
}
inline ::std::string* RateLimit_Action_GenericKey::mutable_descriptor_value() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
  return descriptor_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimit_Action_GenericKey::release_descriptor_value() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
  
  return descriptor_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimit_Action_GenericKey::set_allocated_descriptor_value(::std::string* descriptor_value) {
  if (descriptor_value != NULL) {
    
  } else {
    
  }
  descriptor_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), descriptor_value);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.GenericKey.descriptor_value)
}

// -------------------------------------------------------------------

// RateLimit_Action_HeaderValueMatch

// string descriptor_value = 1;
inline void RateLimit_Action_HeaderValueMatch::clear_descriptor_value() {
  descriptor_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimit_Action_HeaderValueMatch::descriptor_value() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
  return descriptor_value_.GetNoArena();
}
inline void RateLimit_Action_HeaderValueMatch::set_descriptor_value(const ::std::string& value) {
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
}
#if LANG_CXX11
inline void RateLimit_Action_HeaderValueMatch::set_descriptor_value(::std::string&& value) {
  
  descriptor_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
}
#endif
inline void RateLimit_Action_HeaderValueMatch::set_descriptor_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
}
inline void RateLimit_Action_HeaderValueMatch::set_descriptor_value(const char* value, size_t size) {
  
  descriptor_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
}
inline ::std::string* RateLimit_Action_HeaderValueMatch::mutable_descriptor_value() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
  return descriptor_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimit_Action_HeaderValueMatch::release_descriptor_value() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
  
  return descriptor_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimit_Action_HeaderValueMatch::set_allocated_descriptor_value(::std::string* descriptor_value) {
  if (descriptor_value != NULL) {
    
  } else {
    
  }
  descriptor_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), descriptor_value);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.HeaderValueMatch.descriptor_value)
}

// .google.protobuf.BoolValue expect_match = 2;
inline bool RateLimit_Action_HeaderValueMatch::has_expect_match() const {
  return this != internal_default_instance() && expect_match_ != NULL;
}
inline void RateLimit_Action_HeaderValueMatch::clear_expect_match() {
  if (GetArenaNoVirtual() == NULL && expect_match_ != NULL) delete expect_match_;
  expect_match_ = NULL;
}
inline const ::google::protobuf::BoolValue& RateLimit_Action_HeaderValueMatch::expect_match() const {
  const ::google::protobuf::BoolValue* p = expect_match_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.HeaderValueMatch.expect_match)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* RateLimit_Action_HeaderValueMatch::mutable_expect_match() {
  
  if (expect_match_ == NULL) {
    expect_match_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.HeaderValueMatch.expect_match)
  return expect_match_;
}
inline ::google::protobuf::BoolValue* RateLimit_Action_HeaderValueMatch::release_expect_match() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.HeaderValueMatch.expect_match)
  
  ::google::protobuf::BoolValue* temp = expect_match_;
  expect_match_ = NULL;
  return temp;
}
inline void RateLimit_Action_HeaderValueMatch::set_allocated_expect_match(::google::protobuf::BoolValue* expect_match) {
  delete expect_match_;
  if (expect_match != NULL && expect_match->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_expect_match = new ::google::protobuf::BoolValue;
    new_expect_match->CopyFrom(*expect_match);
    expect_match = new_expect_match;
  }
  expect_match_ = expect_match;
  if (expect_match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.HeaderValueMatch.expect_match)
}

// repeated .envoy.api.v2.HeaderMatcher headers = 3;
inline int RateLimit_Action_HeaderValueMatch::headers_size() const {
  return headers_.size();
}
inline void RateLimit_Action_HeaderValueMatch::clear_headers() {
  headers_.Clear();
}
inline const ::envoy::api::v2::HeaderMatcher& RateLimit_Action_HeaderValueMatch::headers(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.HeaderValueMatch.headers)
  return headers_.Get(index);
}
inline ::envoy::api::v2::HeaderMatcher* RateLimit_Action_HeaderValueMatch::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.HeaderValueMatch.headers)
  return headers_.Mutable(index);
}
inline ::envoy::api::v2::HeaderMatcher* RateLimit_Action_HeaderValueMatch::add_headers() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RateLimit.Action.HeaderValueMatch.headers)
  return headers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >*
RateLimit_Action_HeaderValueMatch::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RateLimit.Action.HeaderValueMatch.headers)
  return &headers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderMatcher >&
RateLimit_Action_HeaderValueMatch::headers() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RateLimit.Action.HeaderValueMatch.headers)
  return headers_;
}

// -------------------------------------------------------------------

// RateLimit_Action

// .envoy.api.v2.RateLimit.Action.SourceCluster source_cluster = 1;
inline bool RateLimit_Action::has_source_cluster() const {
  return action_specifier_case() == kSourceCluster;
}
inline void RateLimit_Action::set_has_source_cluster() {
  _oneof_case_[0] = kSourceCluster;
}
inline void RateLimit_Action::clear_source_cluster() {
  if (has_source_cluster()) {
    delete action_specifier_.source_cluster_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_SourceCluster& RateLimit_Action::source_cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.source_cluster)
  return has_source_cluster()
      ? *action_specifier_.source_cluster_
      : ::envoy::api::v2::RateLimit_Action_SourceCluster::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_SourceCluster* RateLimit_Action::mutable_source_cluster() {
  if (!has_source_cluster()) {
    clear_action_specifier();
    set_has_source_cluster();
    action_specifier_.source_cluster_ = new ::envoy::api::v2::RateLimit_Action_SourceCluster;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.source_cluster)
  return action_specifier_.source_cluster_;
}
inline ::envoy::api::v2::RateLimit_Action_SourceCluster* RateLimit_Action::release_source_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.source_cluster)
  if (has_source_cluster()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_SourceCluster* temp = action_specifier_.source_cluster_;
    action_specifier_.source_cluster_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_source_cluster(::envoy::api::v2::RateLimit_Action_SourceCluster* source_cluster) {
  clear_action_specifier();
  if (source_cluster) {
    set_has_source_cluster();
    action_specifier_.source_cluster_ = source_cluster;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.source_cluster)
}

// .envoy.api.v2.RateLimit.Action.DestinationCluster destination_cluster = 2;
inline bool RateLimit_Action::has_destination_cluster() const {
  return action_specifier_case() == kDestinationCluster;
}
inline void RateLimit_Action::set_has_destination_cluster() {
  _oneof_case_[0] = kDestinationCluster;
}
inline void RateLimit_Action::clear_destination_cluster() {
  if (has_destination_cluster()) {
    delete action_specifier_.destination_cluster_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_DestinationCluster& RateLimit_Action::destination_cluster() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.destination_cluster)
  return has_destination_cluster()
      ? *action_specifier_.destination_cluster_
      : ::envoy::api::v2::RateLimit_Action_DestinationCluster::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_DestinationCluster* RateLimit_Action::mutable_destination_cluster() {
  if (!has_destination_cluster()) {
    clear_action_specifier();
    set_has_destination_cluster();
    action_specifier_.destination_cluster_ = new ::envoy::api::v2::RateLimit_Action_DestinationCluster;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.destination_cluster)
  return action_specifier_.destination_cluster_;
}
inline ::envoy::api::v2::RateLimit_Action_DestinationCluster* RateLimit_Action::release_destination_cluster() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.destination_cluster)
  if (has_destination_cluster()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_DestinationCluster* temp = action_specifier_.destination_cluster_;
    action_specifier_.destination_cluster_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_destination_cluster(::envoy::api::v2::RateLimit_Action_DestinationCluster* destination_cluster) {
  clear_action_specifier();
  if (destination_cluster) {
    set_has_destination_cluster();
    action_specifier_.destination_cluster_ = destination_cluster;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.destination_cluster)
}

// .envoy.api.v2.RateLimit.Action.RequestHeaders request_headers = 3;
inline bool RateLimit_Action::has_request_headers() const {
  return action_specifier_case() == kRequestHeaders;
}
inline void RateLimit_Action::set_has_request_headers() {
  _oneof_case_[0] = kRequestHeaders;
}
inline void RateLimit_Action::clear_request_headers() {
  if (has_request_headers()) {
    delete action_specifier_.request_headers_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_RequestHeaders& RateLimit_Action::request_headers() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.request_headers)
  return has_request_headers()
      ? *action_specifier_.request_headers_
      : ::envoy::api::v2::RateLimit_Action_RequestHeaders::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_RequestHeaders* RateLimit_Action::mutable_request_headers() {
  if (!has_request_headers()) {
    clear_action_specifier();
    set_has_request_headers();
    action_specifier_.request_headers_ = new ::envoy::api::v2::RateLimit_Action_RequestHeaders;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.request_headers)
  return action_specifier_.request_headers_;
}
inline ::envoy::api::v2::RateLimit_Action_RequestHeaders* RateLimit_Action::release_request_headers() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.request_headers)
  if (has_request_headers()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_RequestHeaders* temp = action_specifier_.request_headers_;
    action_specifier_.request_headers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_request_headers(::envoy::api::v2::RateLimit_Action_RequestHeaders* request_headers) {
  clear_action_specifier();
  if (request_headers) {
    set_has_request_headers();
    action_specifier_.request_headers_ = request_headers;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.request_headers)
}

// .envoy.api.v2.RateLimit.Action.RemoteAddress remote_address = 4;
inline bool RateLimit_Action::has_remote_address() const {
  return action_specifier_case() == kRemoteAddress;
}
inline void RateLimit_Action::set_has_remote_address() {
  _oneof_case_[0] = kRemoteAddress;
}
inline void RateLimit_Action::clear_remote_address() {
  if (has_remote_address()) {
    delete action_specifier_.remote_address_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_RemoteAddress& RateLimit_Action::remote_address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.remote_address)
  return has_remote_address()
      ? *action_specifier_.remote_address_
      : ::envoy::api::v2::RateLimit_Action_RemoteAddress::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_RemoteAddress* RateLimit_Action::mutable_remote_address() {
  if (!has_remote_address()) {
    clear_action_specifier();
    set_has_remote_address();
    action_specifier_.remote_address_ = new ::envoy::api::v2::RateLimit_Action_RemoteAddress;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.remote_address)
  return action_specifier_.remote_address_;
}
inline ::envoy::api::v2::RateLimit_Action_RemoteAddress* RateLimit_Action::release_remote_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.remote_address)
  if (has_remote_address()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_RemoteAddress* temp = action_specifier_.remote_address_;
    action_specifier_.remote_address_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_remote_address(::envoy::api::v2::RateLimit_Action_RemoteAddress* remote_address) {
  clear_action_specifier();
  if (remote_address) {
    set_has_remote_address();
    action_specifier_.remote_address_ = remote_address;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.remote_address)
}

// .envoy.api.v2.RateLimit.Action.GenericKey generic_key = 5;
inline bool RateLimit_Action::has_generic_key() const {
  return action_specifier_case() == kGenericKey;
}
inline void RateLimit_Action::set_has_generic_key() {
  _oneof_case_[0] = kGenericKey;
}
inline void RateLimit_Action::clear_generic_key() {
  if (has_generic_key()) {
    delete action_specifier_.generic_key_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_GenericKey& RateLimit_Action::generic_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.generic_key)
  return has_generic_key()
      ? *action_specifier_.generic_key_
      : ::envoy::api::v2::RateLimit_Action_GenericKey::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_GenericKey* RateLimit_Action::mutable_generic_key() {
  if (!has_generic_key()) {
    clear_action_specifier();
    set_has_generic_key();
    action_specifier_.generic_key_ = new ::envoy::api::v2::RateLimit_Action_GenericKey;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.generic_key)
  return action_specifier_.generic_key_;
}
inline ::envoy::api::v2::RateLimit_Action_GenericKey* RateLimit_Action::release_generic_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.generic_key)
  if (has_generic_key()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_GenericKey* temp = action_specifier_.generic_key_;
    action_specifier_.generic_key_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_generic_key(::envoy::api::v2::RateLimit_Action_GenericKey* generic_key) {
  clear_action_specifier();
  if (generic_key) {
    set_has_generic_key();
    action_specifier_.generic_key_ = generic_key;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.generic_key)
}

// .envoy.api.v2.RateLimit.Action.HeaderValueMatch header_value_match = 6;
inline bool RateLimit_Action::has_header_value_match() const {
  return action_specifier_case() == kHeaderValueMatch;
}
inline void RateLimit_Action::set_has_header_value_match() {
  _oneof_case_[0] = kHeaderValueMatch;
}
inline void RateLimit_Action::clear_header_value_match() {
  if (has_header_value_match()) {
    delete action_specifier_.header_value_match_;
    clear_has_action_specifier();
  }
}
inline  const ::envoy::api::v2::RateLimit_Action_HeaderValueMatch& RateLimit_Action::header_value_match() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.Action.header_value_match)
  return has_header_value_match()
      ? *action_specifier_.header_value_match_
      : ::envoy::api::v2::RateLimit_Action_HeaderValueMatch::default_instance();
}
inline ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* RateLimit_Action::mutable_header_value_match() {
  if (!has_header_value_match()) {
    clear_action_specifier();
    set_has_header_value_match();
    action_specifier_.header_value_match_ = new ::envoy::api::v2::RateLimit_Action_HeaderValueMatch;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.Action.header_value_match)
  return action_specifier_.header_value_match_;
}
inline ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* RateLimit_Action::release_header_value_match() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.Action.header_value_match)
  if (has_header_value_match()) {
    clear_has_action_specifier();
    ::envoy::api::v2::RateLimit_Action_HeaderValueMatch* temp = action_specifier_.header_value_match_;
    action_specifier_.header_value_match_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RateLimit_Action::set_allocated_header_value_match(::envoy::api::v2::RateLimit_Action_HeaderValueMatch* header_value_match) {
  clear_action_specifier();
  if (header_value_match) {
    set_has_header_value_match();
    action_specifier_.header_value_match_ = header_value_match;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.Action.header_value_match)
}

inline bool RateLimit_Action::has_action_specifier() const {
  return action_specifier_case() != ACTION_SPECIFIER_NOT_SET;
}
inline void RateLimit_Action::clear_has_action_specifier() {
  _oneof_case_[0] = ACTION_SPECIFIER_NOT_SET;
}
inline RateLimit_Action::ActionSpecifierCase RateLimit_Action::action_specifier_case() const {
  return RateLimit_Action::ActionSpecifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RateLimit

// .google.protobuf.UInt32Value stage = 1;
inline bool RateLimit::has_stage() const {
  return this != internal_default_instance() && stage_ != NULL;
}
inline void RateLimit::clear_stage() {
  if (GetArenaNoVirtual() == NULL && stage_ != NULL) delete stage_;
  stage_ = NULL;
}
inline const ::google::protobuf::UInt32Value& RateLimit::stage() const {
  const ::google::protobuf::UInt32Value* p = stage_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.stage)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::UInt32Value*>(
      &::google::protobuf::_UInt32Value_default_instance_);
}
inline ::google::protobuf::UInt32Value* RateLimit::mutable_stage() {
  
  if (stage_ == NULL) {
    stage_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.stage)
  return stage_;
}
inline ::google::protobuf::UInt32Value* RateLimit::release_stage() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.stage)
  
  ::google::protobuf::UInt32Value* temp = stage_;
  stage_ = NULL;
  return temp;
}
inline void RateLimit::set_allocated_stage(::google::protobuf::UInt32Value* stage) {
  delete stage_;
  if (stage != NULL && stage->GetArena() != NULL) {
    ::google::protobuf::UInt32Value* new_stage = new ::google::protobuf::UInt32Value;
    new_stage->CopyFrom(*stage);
    stage = new_stage;
  }
  stage_ = stage;
  if (stage) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.stage)
}

// string disable_key = 2;
inline void RateLimit::clear_disable_key() {
  disable_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimit::disable_key() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.disable_key)
  return disable_key_.GetNoArena();
}
inline void RateLimit::set_disable_key(const ::std::string& value) {
  
  disable_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RateLimit.disable_key)
}
#if LANG_CXX11
inline void RateLimit::set_disable_key(::std::string&& value) {
  
  disable_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RateLimit.disable_key)
}
#endif
inline void RateLimit::set_disable_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  disable_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RateLimit.disable_key)
}
inline void RateLimit::set_disable_key(const char* value, size_t size) {
  
  disable_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RateLimit.disable_key)
}
inline ::std::string* RateLimit::mutable_disable_key() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.disable_key)
  return disable_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimit::release_disable_key() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RateLimit.disable_key)
  
  return disable_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimit::set_allocated_disable_key(::std::string* disable_key) {
  if (disable_key != NULL) {
    
  } else {
    
  }
  disable_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), disable_key);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RateLimit.disable_key)
}

// repeated .envoy.api.v2.RateLimit.Action actions = 3;
inline int RateLimit::actions_size() const {
  return actions_.size();
}
inline void RateLimit::clear_actions() {
  actions_.Clear();
}
inline const ::envoy::api::v2::RateLimit_Action& RateLimit::actions(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RateLimit.actions)
  return actions_.Get(index);
}
inline ::envoy::api::v2::RateLimit_Action* RateLimit::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RateLimit.actions)
  return actions_.Mutable(index);
}
inline ::envoy::api::v2::RateLimit_Action* RateLimit::add_actions() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RateLimit.actions)
  return actions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit_Action >*
RateLimit::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RateLimit.actions)
  return &actions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit_Action >&
RateLimit::actions() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RateLimit.actions)
  return actions_;
}

// -------------------------------------------------------------------

// HeaderMatcher

// string name = 1;
inline void HeaderMatcher::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeaderMatcher::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.HeaderMatcher.name)
  return name_.GetNoArena();
}
inline void HeaderMatcher::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.HeaderMatcher.name)
}
#if LANG_CXX11
inline void HeaderMatcher::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.HeaderMatcher.name)
}
#endif
inline void HeaderMatcher::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.HeaderMatcher.name)
}
inline void HeaderMatcher::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.HeaderMatcher.name)
}
inline ::std::string* HeaderMatcher::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.HeaderMatcher.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeaderMatcher::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.HeaderMatcher.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderMatcher::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.HeaderMatcher.name)
}

// string value = 2;
inline void HeaderMatcher::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeaderMatcher::value() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.HeaderMatcher.value)
  return value_.GetNoArena();
}
inline void HeaderMatcher::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.HeaderMatcher.value)
}
#if LANG_CXX11
inline void HeaderMatcher::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.HeaderMatcher.value)
}
#endif
inline void HeaderMatcher::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.HeaderMatcher.value)
}
inline void HeaderMatcher::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.HeaderMatcher.value)
}
inline ::std::string* HeaderMatcher::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.HeaderMatcher.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeaderMatcher::release_value() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.HeaderMatcher.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeaderMatcher::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.HeaderMatcher.value)
}

// .google.protobuf.BoolValue regex = 3;
inline bool HeaderMatcher::has_regex() const {
  return this != internal_default_instance() && regex_ != NULL;
}
inline void HeaderMatcher::clear_regex() {
  if (GetArenaNoVirtual() == NULL && regex_ != NULL) delete regex_;
  regex_ = NULL;
}
inline const ::google::protobuf::BoolValue& HeaderMatcher::regex() const {
  const ::google::protobuf::BoolValue* p = regex_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.HeaderMatcher.regex)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* HeaderMatcher::mutable_regex() {
  
  if (regex_ == NULL) {
    regex_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.HeaderMatcher.regex)
  return regex_;
}
inline ::google::protobuf::BoolValue* HeaderMatcher::release_regex() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.HeaderMatcher.regex)
  
  ::google::protobuf::BoolValue* temp = regex_;
  regex_ = NULL;
  return temp;
}
inline void HeaderMatcher::set_allocated_regex(::google::protobuf::BoolValue* regex) {
  delete regex_;
  if (regex != NULL && regex->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_regex = new ::google::protobuf::BoolValue;
    new_regex->CopyFrom(*regex);
    regex = new_regex;
  }
  regex_ = regex;
  if (regex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.HeaderMatcher.regex)
}

// -------------------------------------------------------------------

// VirtualHost

// string name = 1;
inline void VirtualHost::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VirtualHost::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.name)
  return name_.GetNoArena();
}
inline void VirtualHost::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualHost.name)
}
#if LANG_CXX11
inline void VirtualHost::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.VirtualHost.name)
}
#endif
inline void VirtualHost::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.VirtualHost.name)
}
inline void VirtualHost::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.VirtualHost.name)
}
inline ::std::string* VirtualHost::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VirtualHost::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.VirtualHost.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VirtualHost::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.VirtualHost.name)
}

// repeated string domains = 2;
inline int VirtualHost::domains_size() const {
  return domains_.size();
}
inline void VirtualHost::clear_domains() {
  domains_.Clear();
}
inline const ::std::string& VirtualHost::domains(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.domains)
  return domains_.Get(index);
}
inline ::std::string* VirtualHost::mutable_domains(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.domains)
  return domains_.Mutable(index);
}
inline void VirtualHost::set_domains(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualHost.domains)
  domains_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void VirtualHost::set_domains(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualHost.domains)
  domains_.Mutable(index)->assign(std::move(value));
}
#endif
inline void VirtualHost::set_domains(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  domains_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.VirtualHost.domains)
}
inline void VirtualHost::set_domains(int index, const char* value, size_t size) {
  domains_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.VirtualHost.domains)
}
inline ::std::string* VirtualHost::add_domains() {
  // @@protoc_insertion_point(field_add_mutable:envoy.api.v2.VirtualHost.domains)
  return domains_.Add();
}
inline void VirtualHost::add_domains(const ::std::string& value) {
  domains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.domains)
}
#if LANG_CXX11
inline void VirtualHost::add_domains(::std::string&& value) {
  domains_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.domains)
}
#endif
inline void VirtualHost::add_domains(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  domains_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:envoy.api.v2.VirtualHost.domains)
}
inline void VirtualHost::add_domains(const char* value, size_t size) {
  domains_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:envoy.api.v2.VirtualHost.domains)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VirtualHost::domains() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.VirtualHost.domains)
  return domains_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VirtualHost::mutable_domains() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.VirtualHost.domains)
  return &domains_;
}

// repeated .envoy.api.v2.Route routes = 3;
inline int VirtualHost::routes_size() const {
  return routes_.size();
}
inline void VirtualHost::clear_routes() {
  routes_.Clear();
}
inline const ::envoy::api::v2::Route& VirtualHost::routes(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.routes)
  return routes_.Get(index);
}
inline ::envoy::api::v2::Route* VirtualHost::mutable_routes(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.routes)
  return routes_.Mutable(index);
}
inline ::envoy::api::v2::Route* VirtualHost::add_routes() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.routes)
  return routes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Route >*
VirtualHost::mutable_routes() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.VirtualHost.routes)
  return &routes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::Route >&
VirtualHost::routes() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.VirtualHost.routes)
  return routes_;
}

// .envoy.api.v2.VirtualHost.TlsRequirementType require_tls = 4;
inline void VirtualHost::clear_require_tls() {
  require_tls_ = 0;
}
inline ::envoy::api::v2::VirtualHost_TlsRequirementType VirtualHost::require_tls() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.require_tls)
  return static_cast< ::envoy::api::v2::VirtualHost_TlsRequirementType >(require_tls_);
}
inline void VirtualHost::set_require_tls(::envoy::api::v2::VirtualHost_TlsRequirementType value) {
  
  require_tls_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.VirtualHost.require_tls)
}

// repeated .envoy.api.v2.VirtualCluster virtual_clusters = 5;
inline int VirtualHost::virtual_clusters_size() const {
  return virtual_clusters_.size();
}
inline void VirtualHost::clear_virtual_clusters() {
  virtual_clusters_.Clear();
}
inline const ::envoy::api::v2::VirtualCluster& VirtualHost::virtual_clusters(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.virtual_clusters)
  return virtual_clusters_.Get(index);
}
inline ::envoy::api::v2::VirtualCluster* VirtualHost::mutable_virtual_clusters(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.virtual_clusters)
  return virtual_clusters_.Mutable(index);
}
inline ::envoy::api::v2::VirtualCluster* VirtualHost::add_virtual_clusters() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.virtual_clusters)
  return virtual_clusters_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualCluster >*
VirtualHost::mutable_virtual_clusters() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.VirtualHost.virtual_clusters)
  return &virtual_clusters_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualCluster >&
VirtualHost::virtual_clusters() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.VirtualHost.virtual_clusters)
  return virtual_clusters_;
}

// repeated .envoy.api.v2.RateLimit rate_limits = 6;
inline int VirtualHost::rate_limits_size() const {
  return rate_limits_.size();
}
inline void VirtualHost::clear_rate_limits() {
  rate_limits_.Clear();
}
inline const ::envoy::api::v2::RateLimit& VirtualHost::rate_limits(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.rate_limits)
  return rate_limits_.Get(index);
}
inline ::envoy::api::v2::RateLimit* VirtualHost::mutable_rate_limits(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.rate_limits)
  return rate_limits_.Mutable(index);
}
inline ::envoy::api::v2::RateLimit* VirtualHost::add_rate_limits() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.rate_limits)
  return rate_limits_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >*
VirtualHost::mutable_rate_limits() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.VirtualHost.rate_limits)
  return &rate_limits_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::RateLimit >&
VirtualHost::rate_limits() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.VirtualHost.rate_limits)
  return rate_limits_;
}

// repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 7;
inline int VirtualHost::request_headers_to_add_size() const {
  return request_headers_to_add_.size();
}
inline void VirtualHost::clear_request_headers_to_add() {
  request_headers_to_add_.Clear();
}
inline const ::envoy::api::v2::HeaderValueOption& VirtualHost::request_headers_to_add(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.request_headers_to_add)
  return request_headers_to_add_.Get(index);
}
inline ::envoy::api::v2::HeaderValueOption* VirtualHost::mutable_request_headers_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.request_headers_to_add)
  return request_headers_to_add_.Mutable(index);
}
inline ::envoy::api::v2::HeaderValueOption* VirtualHost::add_request_headers_to_add() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.VirtualHost.request_headers_to_add)
  return request_headers_to_add_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
VirtualHost::mutable_request_headers_to_add() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.VirtualHost.request_headers_to_add)
  return &request_headers_to_add_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
VirtualHost::request_headers_to_add() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.VirtualHost.request_headers_to_add)
  return request_headers_to_add_;
}

// .envoy.api.v2.CorsPolicy cors = 8;
inline bool VirtualHost::has_cors() const {
  return this != internal_default_instance() && cors_ != NULL;
}
inline void VirtualHost::clear_cors() {
  if (GetArenaNoVirtual() == NULL && cors_ != NULL) delete cors_;
  cors_ = NULL;
}
inline const ::envoy::api::v2::CorsPolicy& VirtualHost::cors() const {
  const ::envoy::api::v2::CorsPolicy* p = cors_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.VirtualHost.cors)
  return p != NULL ? *p : *reinterpret_cast<const ::envoy::api::v2::CorsPolicy*>(
      &::envoy::api::v2::_CorsPolicy_default_instance_);
}
inline ::envoy::api::v2::CorsPolicy* VirtualHost::mutable_cors() {
  
  if (cors_ == NULL) {
    cors_ = new ::envoy::api::v2::CorsPolicy;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.VirtualHost.cors)
  return cors_;
}
inline ::envoy::api::v2::CorsPolicy* VirtualHost::release_cors() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.VirtualHost.cors)
  
  ::envoy::api::v2::CorsPolicy* temp = cors_;
  cors_ = NULL;
  return temp;
}
inline void VirtualHost::set_allocated_cors(::envoy::api::v2::CorsPolicy* cors) {
  delete cors_;
  cors_ = cors;
  if (cors) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.VirtualHost.cors)
}

// -------------------------------------------------------------------

// RouteConfiguration

// string name = 1;
inline void RouteConfiguration::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RouteConfiguration::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.name)
  return name_.GetNoArena();
}
inline void RouteConfiguration::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteConfiguration.name)
}
#if LANG_CXX11
inline void RouteConfiguration::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.RouteConfiguration.name)
}
#endif
inline void RouteConfiguration::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteConfiguration.name)
}
inline void RouteConfiguration::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteConfiguration.name)
}
inline ::std::string* RouteConfiguration::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RouteConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteConfiguration.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RouteConfiguration::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteConfiguration.name)
}

// repeated .envoy.api.v2.VirtualHost virtual_hosts = 2;
inline int RouteConfiguration::virtual_hosts_size() const {
  return virtual_hosts_.size();
}
inline void RouteConfiguration::clear_virtual_hosts() {
  virtual_hosts_.Clear();
}
inline const ::envoy::api::v2::VirtualHost& RouteConfiguration::virtual_hosts(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.virtual_hosts)
  return virtual_hosts_.Get(index);
}
inline ::envoy::api::v2::VirtualHost* RouteConfiguration::mutable_virtual_hosts(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.virtual_hosts)
  return virtual_hosts_.Mutable(index);
}
inline ::envoy::api::v2::VirtualHost* RouteConfiguration::add_virtual_hosts() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.virtual_hosts)
  return virtual_hosts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualHost >*
RouteConfiguration::mutable_virtual_hosts() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteConfiguration.virtual_hosts)
  return &virtual_hosts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::VirtualHost >&
RouteConfiguration::virtual_hosts() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteConfiguration.virtual_hosts)
  return virtual_hosts_;
}

// repeated string internal_only_headers = 3;
inline int RouteConfiguration::internal_only_headers_size() const {
  return internal_only_headers_.size();
}
inline void RouteConfiguration::clear_internal_only_headers() {
  internal_only_headers_.Clear();
}
inline const ::std::string& RouteConfiguration::internal_only_headers(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.internal_only_headers)
  return internal_only_headers_.Get(index);
}
inline ::std::string* RouteConfiguration::mutable_internal_only_headers(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.internal_only_headers)
  return internal_only_headers_.Mutable(index);
}
inline void RouteConfiguration::set_internal_only_headers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteConfiguration.internal_only_headers)
  internal_only_headers_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RouteConfiguration::set_internal_only_headers(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteConfiguration.internal_only_headers)
  internal_only_headers_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RouteConfiguration::set_internal_only_headers(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  internal_only_headers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
inline void RouteConfiguration::set_internal_only_headers(int index, const char* value, size_t size) {
  internal_only_headers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
inline ::std::string* RouteConfiguration::add_internal_only_headers() {
  // @@protoc_insertion_point(field_add_mutable:envoy.api.v2.RouteConfiguration.internal_only_headers)
  return internal_only_headers_.Add();
}
inline void RouteConfiguration::add_internal_only_headers(const ::std::string& value) {
  internal_only_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
#if LANG_CXX11
inline void RouteConfiguration::add_internal_only_headers(::std::string&& value) {
  internal_only_headers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
#endif
inline void RouteConfiguration::add_internal_only_headers(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  internal_only_headers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
inline void RouteConfiguration::add_internal_only_headers(const char* value, size_t size) {
  internal_only_headers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:envoy.api.v2.RouteConfiguration.internal_only_headers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RouteConfiguration::internal_only_headers() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteConfiguration.internal_only_headers)
  return internal_only_headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RouteConfiguration::mutable_internal_only_headers() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteConfiguration.internal_only_headers)
  return &internal_only_headers_;
}

// repeated .envoy.api.v2.HeaderValueOption response_headers_to_add = 4;
inline int RouteConfiguration::response_headers_to_add_size() const {
  return response_headers_to_add_.size();
}
inline void RouteConfiguration::clear_response_headers_to_add() {
  response_headers_to_add_.Clear();
}
inline const ::envoy::api::v2::HeaderValueOption& RouteConfiguration::response_headers_to_add(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.response_headers_to_add)
  return response_headers_to_add_.Get(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteConfiguration::mutable_response_headers_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.response_headers_to_add)
  return response_headers_to_add_.Mutable(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteConfiguration::add_response_headers_to_add() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.response_headers_to_add)
  return response_headers_to_add_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
RouteConfiguration::mutable_response_headers_to_add() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteConfiguration.response_headers_to_add)
  return &response_headers_to_add_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
RouteConfiguration::response_headers_to_add() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteConfiguration.response_headers_to_add)
  return response_headers_to_add_;
}

// repeated string response_headers_to_remove = 5;
inline int RouteConfiguration::response_headers_to_remove_size() const {
  return response_headers_to_remove_.size();
}
inline void RouteConfiguration::clear_response_headers_to_remove() {
  response_headers_to_remove_.Clear();
}
inline const ::std::string& RouteConfiguration::response_headers_to_remove(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  return response_headers_to_remove_.Get(index);
}
inline ::std::string* RouteConfiguration::mutable_response_headers_to_remove(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  return response_headers_to_remove_.Mutable(index);
}
inline void RouteConfiguration::set_response_headers_to_remove(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  response_headers_to_remove_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RouteConfiguration::set_response_headers_to_remove(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  response_headers_to_remove_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RouteConfiguration::set_response_headers_to_remove(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  response_headers_to_remove_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
inline void RouteConfiguration::set_response_headers_to_remove(int index, const char* value, size_t size) {
  response_headers_to_remove_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
inline ::std::string* RouteConfiguration::add_response_headers_to_remove() {
  // @@protoc_insertion_point(field_add_mutable:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  return response_headers_to_remove_.Add();
}
inline void RouteConfiguration::add_response_headers_to_remove(const ::std::string& value) {
  response_headers_to_remove_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
#if LANG_CXX11
inline void RouteConfiguration::add_response_headers_to_remove(::std::string&& value) {
  response_headers_to_remove_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
#endif
inline void RouteConfiguration::add_response_headers_to_remove(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  response_headers_to_remove_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
inline void RouteConfiguration::add_response_headers_to_remove(const char* value, size_t size) {
  response_headers_to_remove_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RouteConfiguration::response_headers_to_remove() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  return response_headers_to_remove_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RouteConfiguration::mutable_response_headers_to_remove() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteConfiguration.response_headers_to_remove)
  return &response_headers_to_remove_;
}

// repeated .envoy.api.v2.HeaderValueOption request_headers_to_add = 6;
inline int RouteConfiguration::request_headers_to_add_size() const {
  return request_headers_to_add_.size();
}
inline void RouteConfiguration::clear_request_headers_to_add() {
  request_headers_to_add_.Clear();
}
inline const ::envoy::api::v2::HeaderValueOption& RouteConfiguration::request_headers_to_add(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.request_headers_to_add)
  return request_headers_to_add_.Get(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteConfiguration::mutable_request_headers_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.request_headers_to_add)
  return request_headers_to_add_.Mutable(index);
}
inline ::envoy::api::v2::HeaderValueOption* RouteConfiguration::add_request_headers_to_add() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.RouteConfiguration.request_headers_to_add)
  return request_headers_to_add_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >*
RouteConfiguration::mutable_request_headers_to_add() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.RouteConfiguration.request_headers_to_add)
  return &request_headers_to_add_;
}
inline const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::HeaderValueOption >&
RouteConfiguration::request_headers_to_add() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.RouteConfiguration.request_headers_to_add)
  return request_headers_to_add_;
}

// .google.protobuf.BoolValue validate_clusters = 7;
inline bool RouteConfiguration::has_validate_clusters() const {
  return this != internal_default_instance() && validate_clusters_ != NULL;
}
inline void RouteConfiguration::clear_validate_clusters() {
  if (GetArenaNoVirtual() == NULL && validate_clusters_ != NULL) delete validate_clusters_;
  validate_clusters_ = NULL;
}
inline const ::google::protobuf::BoolValue& RouteConfiguration::validate_clusters() const {
  const ::google::protobuf::BoolValue* p = validate_clusters_;
  // @@protoc_insertion_point(field_get:envoy.api.v2.RouteConfiguration.validate_clusters)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::BoolValue*>(
      &::google::protobuf::_BoolValue_default_instance_);
}
inline ::google::protobuf::BoolValue* RouteConfiguration::mutable_validate_clusters() {
  
  if (validate_clusters_ == NULL) {
    validate_clusters_ = new ::google::protobuf::BoolValue;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.RouteConfiguration.validate_clusters)
  return validate_clusters_;
}
inline ::google::protobuf::BoolValue* RouteConfiguration::release_validate_clusters() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.RouteConfiguration.validate_clusters)
  
  ::google::protobuf::BoolValue* temp = validate_clusters_;
  validate_clusters_ = NULL;
  return temp;
}
inline void RouteConfiguration::set_allocated_validate_clusters(::google::protobuf::BoolValue* validate_clusters) {
  delete validate_clusters_;
  if (validate_clusters != NULL && validate_clusters->GetArena() != NULL) {
    ::google::protobuf::BoolValue* new_validate_clusters = new ::google::protobuf::BoolValue;
    new_validate_clusters->CopyFrom(*validate_clusters);
    validate_clusters = new_validate_clusters;
  }
  validate_clusters_ = validate_clusters;
  if (validate_clusters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.RouteConfiguration.validate_clusters)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace v2
}  // namespace api
}  // namespace envoy

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::envoy::api::v2::VirtualHost_TlsRequirementType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::envoy::api::v2::VirtualHost_TlsRequirementType>() {
  return ::envoy::api::v2::VirtualHost_TlsRequirementType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2frds_2eproto__INCLUDED
