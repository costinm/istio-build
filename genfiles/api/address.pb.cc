// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/address.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "api/address.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace envoy {
namespace api {
namespace v2 {
class PipeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Pipe> {
} _Pipe_default_instance_;
class UnresolvedAddress_NamedAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UnresolvedAddress_NamedAddress> {
  public:
  const ::google::protobuf::UInt32Value* port_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
} _UnresolvedAddress_NamedAddress_default_instance_;
class UnresolvedAddress_ResolverDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UnresolvedAddress_Resolver> {
} _UnresolvedAddress_Resolver_default_instance_;
class UnresolvedAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UnresolvedAddress> {
  public:
  const ::envoy::api::v2::UnresolvedAddress_NamedAddress* named_address_;
  const ::envoy::api::v2::Pipe* pipe_;
} _UnresolvedAddress_default_instance_;
class UnresolvedAddressesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<UnresolvedAddresses> {
} _UnresolvedAddresses_default_instance_;
class ResolvedAddress_SocketAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ResolvedAddress_SocketAddress> {
} _ResolvedAddress_SocketAddress_default_instance_;
class ResolvedAddressDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ResolvedAddress> {
  public:
  const ::envoy::api::v2::ResolvedAddress_SocketAddress* socket_address_;
  const ::envoy::api::v2::Pipe* pipe_;
} _ResolvedAddress_default_instance_;
class ResolvedAddressesDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ResolvedAddresses> {
} _ResolvedAddresses_default_instance_;

namespace protobuf_api_2faddress_2eproto {


namespace {

::google::protobuf::Metadata file_level_metadata[8];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[2];

}  // namespace

const ::google::protobuf::uint32 TableStruct::offsets[] = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pipe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pipe, path_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_NamedAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_NamedAddress, _oneof_case_[0]),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_NamedAddress, protocol_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_NamedAddress, address_),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_UnresolvedAddress_NamedAddress_default_instance_), port_),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_UnresolvedAddress_NamedAddress_default_instance_), service_name_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_NamedAddress, port_specifier_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_Resolver, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress_Resolver, name_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress, _oneof_case_[0]),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress, resolver_),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_UnresolvedAddress_default_instance_), named_address_),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_UnresolvedAddress_default_instance_), pipe_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddress, address_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddresses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UnresolvedAddresses, addresses_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress_SocketAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress_SocketAddress, protocol_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress_SocketAddress, ip_address_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress_SocketAddress, port_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress, _oneof_case_[0]),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ResolvedAddress_default_instance_), socket_address_),
  PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET((&_ResolvedAddress_default_instance_), pipe_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddress, address_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddresses, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResolvedAddresses, addresses_),
};

static const ::google::protobuf::internal::MigrationSchema schemas[] = {
  { 0, -1, sizeof(Pipe)},
  { 5, -1, sizeof(UnresolvedAddress_NamedAddress)},
  { 14, -1, sizeof(UnresolvedAddress_Resolver)},
  { 19, -1, sizeof(UnresolvedAddress)},
  { 27, -1, sizeof(UnresolvedAddresses)},
  { 32, -1, sizeof(ResolvedAddress_SocketAddress)},
  { 39, -1, sizeof(ResolvedAddress)},
  { 46, -1, sizeof(ResolvedAddresses)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&_Pipe_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UnresolvedAddress_NamedAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UnresolvedAddress_Resolver_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UnresolvedAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_UnresolvedAddresses_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ResolvedAddress_SocketAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ResolvedAddress_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&_ResolvedAddresses_default_instance_),
};

namespace {

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "api/address.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 8);
}

}  // namespace

void TableStruct::Shutdown() {
  _Pipe_default_instance_.Shutdown();
  delete file_level_metadata[0].reflection;
  _UnresolvedAddress_NamedAddress_default_instance_.Shutdown();
  delete file_level_metadata[1].reflection;
  _UnresolvedAddress_Resolver_default_instance_.Shutdown();
  delete file_level_metadata[2].reflection;
  _UnresolvedAddress_default_instance_.Shutdown();
  delete file_level_metadata[3].reflection;
  _UnresolvedAddresses_default_instance_.Shutdown();
  delete file_level_metadata[4].reflection;
  _ResolvedAddress_SocketAddress_default_instance_.Shutdown();
  delete file_level_metadata[5].reflection;
  _ResolvedAddress_default_instance_.Shutdown();
  delete file_level_metadata[6].reflection;
  _ResolvedAddresses_default_instance_.Shutdown();
  delete file_level_metadata[7].reflection;
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  ::google::protobuf::protobuf_google_2fprotobuf_2fwrappers_2eproto::InitDefaults();
  _Pipe_default_instance_.DefaultConstruct();
  _UnresolvedAddress_NamedAddress_default_instance_.DefaultConstruct();
  _UnresolvedAddress_Resolver_default_instance_.DefaultConstruct();
  _UnresolvedAddress_default_instance_.DefaultConstruct();
  _UnresolvedAddresses_default_instance_.DefaultConstruct();
  _ResolvedAddress_SocketAddress_default_instance_.DefaultConstruct();
  _ResolvedAddress_default_instance_.DefaultConstruct();
  _ResolvedAddresses_default_instance_.DefaultConstruct();
  _UnresolvedAddress_NamedAddress_default_instance_.port_ = const_cast< ::google::protobuf::UInt32Value*>(
      ::google::protobuf::UInt32Value::internal_default_instance());
  _UnresolvedAddress_NamedAddress_default_instance_.service_name_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _UnresolvedAddress_default_instance_.get_mutable()->resolver_ = const_cast< ::envoy::api::v2::UnresolvedAddress_Resolver*>(
      ::envoy::api::v2::UnresolvedAddress_Resolver::internal_default_instance());
  _UnresolvedAddress_default_instance_.named_address_ = const_cast< ::envoy::api::v2::UnresolvedAddress_NamedAddress*>(
      ::envoy::api::v2::UnresolvedAddress_NamedAddress::internal_default_instance());
  _UnresolvedAddress_default_instance_.pipe_ = const_cast< ::envoy::api::v2::Pipe*>(
      ::envoy::api::v2::Pipe::internal_default_instance());
  _ResolvedAddress_SocketAddress_default_instance_.get_mutable()->port_ = const_cast< ::google::protobuf::UInt32Value*>(
      ::google::protobuf::UInt32Value::internal_default_instance());
  _ResolvedAddress_default_instance_.socket_address_ = const_cast< ::envoy::api::v2::ResolvedAddress_SocketAddress*>(
      ::envoy::api::v2::ResolvedAddress_SocketAddress::internal_default_instance());
  _ResolvedAddress_default_instance_.pipe_ = const_cast< ::envoy::api::v2::Pipe*>(
      ::envoy::api::v2::Pipe::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] = {
      "\n\021api/address.proto\022\014envoy.api.v2\032\036googl"
      "e/protobuf/wrappers.proto\"\024\n\004Pipe\022\014\n\004pat"
      "h\030\001 \001(\t\"\267\003\n\021UnresolvedAddress\022:\n\010resolve"
      "r\030\001 \001(\0132(.envoy.api.v2.UnresolvedAddress"
      ".Resolver\022E\n\rnamed_address\030\002 \001(\0132,.envoy"
      ".api.v2.UnresolvedAddress.NamedAddressH\000"
      "\022\"\n\004pipe\030\003 \001(\0132\022.envoy.api.v2.PipeH\000\032\325\001\n"
      "\014NamedAddress\022G\n\010protocol\030\001 \001(\01625.envoy."
      "api.v2.UnresolvedAddress.NamedAddress.Pr"
      "otocol\022\017\n\007address\030\002 \001(\t\022,\n\004port\030\003 \001(\0132\034."
      "google.protobuf.UInt32ValueH\000\022\026\n\014service"
      "_name\030\004 \001(\tH\000\"\023\n\010Protocol\022\007\n\003TCP\020\000B\020\n\016po"
      "rt_specifier\032\030\n\010Resolver\022\014\n\004name\030\001 \001(\tB\t"
      "\n\007address\"I\n\023UnresolvedAddresses\0222\n\taddr"
      "esses\030\001 \003(\0132\037.envoy.api.v2.UnresolvedAdd"
      "ress\"\266\002\n\017ResolvedAddress\022E\n\016socket_addre"
      "ss\030\002 \001(\0132+.envoy.api.v2.ResolvedAddress."
      "SocketAddressH\000\022\"\n\004pipe\030\003 \001(\0132\022.envoy.ap"
      "i.v2.PipeH\000\032\254\001\n\rSocketAddress\022F\n\010protoco"
      "l\030\001 \001(\01624.envoy.api.v2.ResolvedAddress.S"
      "ocketAddress.Protocol\022\022\n\nip_address\030\002 \001("
      "\t\022*\n\004port\030\003 \001(\0132\034.google.protobuf.UInt32"
      "Value\"\023\n\010Protocol\022\007\n\003TCP\020\000B\t\n\007address\"E\n"
      "\021ResolvedAddresses\0220\n\taddresses\030\001 \003(\0132\035."
      "envoy.api.v2.ResolvedAddressb\006proto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 996);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "api/address.proto", &protobuf_RegisterTypes);
  ::google::protobuf::protobuf_google_2fprotobuf_2fwrappers_2eproto::AddDescriptors();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;

}  // namespace protobuf_api_2faddress_2eproto

const ::google::protobuf::EnumDescriptor* UnresolvedAddress_NamedAddress_Protocol_descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_enum_descriptors[0];
}
bool UnresolvedAddress_NamedAddress_Protocol_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const UnresolvedAddress_NamedAddress_Protocol UnresolvedAddress_NamedAddress::TCP;
const UnresolvedAddress_NamedAddress_Protocol UnresolvedAddress_NamedAddress::Protocol_MIN;
const UnresolvedAddress_NamedAddress_Protocol UnresolvedAddress_NamedAddress::Protocol_MAX;
const int UnresolvedAddress_NamedAddress::Protocol_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ResolvedAddress_SocketAddress_Protocol_descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_enum_descriptors[1];
}
bool ResolvedAddress_SocketAddress_Protocol_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ResolvedAddress_SocketAddress_Protocol ResolvedAddress_SocketAddress::TCP;
const ResolvedAddress_SocketAddress_Protocol ResolvedAddress_SocketAddress::Protocol_MIN;
const ResolvedAddress_SocketAddress_Protocol ResolvedAddress_SocketAddress::Protocol_MAX;
const int ResolvedAddress_SocketAddress::Protocol_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pipe::kPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pipe::Pipe()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.Pipe)
}
Pipe::Pipe(const Pipe& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.path().size() > 0) {
    path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
  }
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.Pipe)
}

void Pipe::SharedCtor() {
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

Pipe::~Pipe() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.Pipe)
  SharedDtor();
}

void Pipe::SharedDtor() {
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Pipe::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pipe::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[0].descriptor;
}

const Pipe& Pipe::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

Pipe* Pipe::New(::google::protobuf::Arena* arena) const {
  Pipe* n = new Pipe;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pipe::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.Pipe)
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Pipe::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.Pipe)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string path = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "envoy.api.v2.Pipe.path"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.Pipe)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.Pipe)
  return false;
#undef DO_
}

void Pipe::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.Pipe)
  // string path = 1;
  if (this->path().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.Pipe.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.Pipe)
}

::google::protobuf::uint8* Pipe::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.Pipe)
  // string path = 1;
  if (this->path().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.Pipe.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.Pipe)
  return target;
}

size_t Pipe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.Pipe)
  size_t total_size = 0;

  // string path = 1;
  if (this->path().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->path());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pipe::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.Pipe)
  GOOGLE_DCHECK_NE(&from, this);
  const Pipe* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Pipe>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.Pipe)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.Pipe)
    MergeFrom(*source);
  }
}

void Pipe::MergeFrom(const Pipe& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.Pipe)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.path().size() > 0) {

    path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
  }
}

void Pipe::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.Pipe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pipe::CopyFrom(const Pipe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.Pipe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pipe::IsInitialized() const {
  return true;
}

void Pipe::Swap(Pipe* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pipe::InternalSwap(Pipe* other) {
  path_.Swap(&other->path_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pipe::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[0];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pipe

// string path = 1;
void Pipe::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& Pipe::path() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.Pipe.path)
  return path_.GetNoArena();
}
void Pipe::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.Pipe.path)
}
#if LANG_CXX11
void Pipe::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.Pipe.path)
}
#endif
void Pipe::set_path(const char* value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.Pipe.path)
}
void Pipe::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.Pipe.path)
}
::std::string* Pipe::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.Pipe.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* Pipe::release_path() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.Pipe.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void Pipe::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.Pipe.path)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnresolvedAddress_NamedAddress::kProtocolFieldNumber;
const int UnresolvedAddress_NamedAddress::kAddressFieldNumber;
const int UnresolvedAddress_NamedAddress::kPortFieldNumber;
const int UnresolvedAddress_NamedAddress::kServiceNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnresolvedAddress_NamedAddress::UnresolvedAddress_NamedAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.UnresolvedAddress.NamedAddress)
}
UnresolvedAddress_NamedAddress::UnresolvedAddress_NamedAddress(const UnresolvedAddress_NamedAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.address().size() > 0) {
    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  protocol_ = from.protocol_;
  clear_has_port_specifier();
  switch (from.port_specifier_case()) {
    case kPort: {
      mutable_port()->::google::protobuf::UInt32Value::MergeFrom(from.port());
      break;
    }
    case kServiceName: {
      set_service_name(from.service_name());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.UnresolvedAddress.NamedAddress)
}

void UnresolvedAddress_NamedAddress::SharedCtor() {
  address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_ = 0;
  clear_has_port_specifier();
  _cached_size_ = 0;
}

UnresolvedAddress_NamedAddress::~UnresolvedAddress_NamedAddress() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.UnresolvedAddress.NamedAddress)
  SharedDtor();
}

void UnresolvedAddress_NamedAddress::SharedDtor() {
  address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_port_specifier()) {
    clear_port_specifier();
  }
}

void UnresolvedAddress_NamedAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnresolvedAddress_NamedAddress::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[1].descriptor;
}

const UnresolvedAddress_NamedAddress& UnresolvedAddress_NamedAddress::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnresolvedAddress_NamedAddress* UnresolvedAddress_NamedAddress::New(::google::protobuf::Arena* arena) const {
  UnresolvedAddress_NamedAddress* n = new UnresolvedAddress_NamedAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnresolvedAddress_NamedAddress::clear_port_specifier() {
// @@protoc_insertion_point(one_of_clear_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  switch (port_specifier_case()) {
    case kPort: {
      delete port_specifier_.port_;
      break;
    }
    case kServiceName: {
      port_specifier_.service_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = PORT_SPECIFIER_NOT_SET;
}


void UnresolvedAddress_NamedAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_ = 0;
  clear_port_specifier();
}

bool UnresolvedAddress_NamedAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .envoy.api.v2.UnresolvedAddress.NamedAddress.Protocol protocol = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_protocol(static_cast< ::envoy::api::v2::UnresolvedAddress_NamedAddress_Protocol >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string address = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "envoy.api.v2.UnresolvedAddress.NamedAddress.address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .google.protobuf.UInt32Value port = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string service_name = 4;
      case 4: {
        if (tag == 34u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->service_name().data(), this->service_name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "envoy.api.v2.UnresolvedAddress.NamedAddress.service_name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.UnresolvedAddress.NamedAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.UnresolvedAddress.NamedAddress)
  return false;
#undef DO_
}

void UnresolvedAddress_NamedAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  // .envoy.api.v2.UnresolvedAddress.NamedAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->protocol(), output);
  }

  // string address = 2;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.NamedAddress.address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->address(), output);
  }

  // .google.protobuf.UInt32Value port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *port_specifier_.port_, output);
  }

  // string service_name = 4;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->service_name().data(), this->service_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.NamedAddress.service_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->service_name(), output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.UnresolvedAddress.NamedAddress)
}

::google::protobuf::uint8* UnresolvedAddress_NamedAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  // .envoy.api.v2.UnresolvedAddress.NamedAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->protocol(), target);
  }

  // string address = 2;
  if (this->address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.NamedAddress.address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->address(), target);
  }

  // .google.protobuf.UInt32Value port = 3;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *port_specifier_.port_, false, target);
  }

  // string service_name = 4;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->service_name().data(), this->service_name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.NamedAddress.service_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->service_name(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.UnresolvedAddress.NamedAddress)
  return target;
}

size_t UnresolvedAddress_NamedAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  size_t total_size = 0;

  // string address = 2;
  if (this->address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->address());
  }

  // .envoy.api.v2.UnresolvedAddress.NamedAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol());
  }

  switch (port_specifier_case()) {
    // .google.protobuf.UInt32Value port = 3;
    case kPort: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *port_specifier_.port_);
      break;
    }
    // string service_name = 4;
    case kServiceName: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->service_name());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnresolvedAddress_NamedAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const UnresolvedAddress_NamedAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UnresolvedAddress_NamedAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.UnresolvedAddress.NamedAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.UnresolvedAddress.NamedAddress)
    MergeFrom(*source);
  }
}

void UnresolvedAddress_NamedAddress::MergeFrom(const UnresolvedAddress_NamedAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.address().size() > 0) {

    address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.address_);
  }
  if (from.protocol() != 0) {
    set_protocol(from.protocol());
  }
  switch (from.port_specifier_case()) {
    case kPort: {
      mutable_port()->::google::protobuf::UInt32Value::MergeFrom(from.port());
      break;
    }
    case kServiceName: {
      set_service_name(from.service_name());
      break;
    }
    case PORT_SPECIFIER_NOT_SET: {
      break;
    }
  }
}

void UnresolvedAddress_NamedAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnresolvedAddress_NamedAddress::CopyFrom(const UnresolvedAddress_NamedAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.UnresolvedAddress.NamedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnresolvedAddress_NamedAddress::IsInitialized() const {
  return true;
}

void UnresolvedAddress_NamedAddress::Swap(UnresolvedAddress_NamedAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnresolvedAddress_NamedAddress::InternalSwap(UnresolvedAddress_NamedAddress* other) {
  address_.Swap(&other->address_);
  std::swap(protocol_, other->protocol_);
  std::swap(port_specifier_, other->port_specifier_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnresolvedAddress_NamedAddress::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[1];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnresolvedAddress_NamedAddress

// .envoy.api.v2.UnresolvedAddress.NamedAddress.Protocol protocol = 1;
void UnresolvedAddress_NamedAddress::clear_protocol() {
  protocol_ = 0;
}
::envoy::api::v2::UnresolvedAddress_NamedAddress_Protocol UnresolvedAddress_NamedAddress::protocol() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.NamedAddress.protocol)
  return static_cast< ::envoy::api::v2::UnresolvedAddress_NamedAddress_Protocol >(protocol_);
}
void UnresolvedAddress_NamedAddress::set_protocol(::envoy::api::v2::UnresolvedAddress_NamedAddress_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.NamedAddress.protocol)
}

// string address = 2;
void UnresolvedAddress_NamedAddress::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& UnresolvedAddress_NamedAddress::address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
  return address_.GetNoArena();
}
void UnresolvedAddress_NamedAddress::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
}
#if LANG_CXX11
void UnresolvedAddress_NamedAddress::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
}
#endif
void UnresolvedAddress_NamedAddress::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
}
void UnresolvedAddress_NamedAddress::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
}
::std::string* UnresolvedAddress_NamedAddress::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UnresolvedAddress_NamedAddress::release_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void UnresolvedAddress_NamedAddress::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.NamedAddress.address)
}

// .google.protobuf.UInt32Value port = 3;
bool UnresolvedAddress_NamedAddress::has_port() const {
  return port_specifier_case() == kPort;
}
void UnresolvedAddress_NamedAddress::set_has_port() {
  _oneof_case_[0] = kPort;
}
void UnresolvedAddress_NamedAddress::clear_port() {
  if (has_port()) {
    delete port_specifier_.port_;
    clear_has_port_specifier();
  }
}
 const ::google::protobuf::UInt32Value& UnresolvedAddress_NamedAddress::port() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.NamedAddress.port)
  return has_port()
      ? *port_specifier_.port_
      : ::google::protobuf::UInt32Value::default_instance();
}
::google::protobuf::UInt32Value* UnresolvedAddress_NamedAddress::mutable_port() {
  if (!has_port()) {
    clear_port_specifier();
    set_has_port();
    port_specifier_.port_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.NamedAddress.port)
  return port_specifier_.port_;
}
::google::protobuf::UInt32Value* UnresolvedAddress_NamedAddress::release_port() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.NamedAddress.port)
  if (has_port()) {
    clear_has_port_specifier();
    ::google::protobuf::UInt32Value* temp = port_specifier_.port_;
    port_specifier_.port_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void UnresolvedAddress_NamedAddress::set_allocated_port(::google::protobuf::UInt32Value* port) {
  clear_port_specifier();
  if (port) {
    if (static_cast< ::google::protobuf::UInt32Value*>(port)->GetArena() != NULL) {
      ::google::protobuf::UInt32Value* new_port = new ::google::protobuf::UInt32Value;
      new_port->CopyFrom(*port);
      port = new_port;
    }
    set_has_port();
    port_specifier_.port_ = port;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.NamedAddress.port)
}

// string service_name = 4;
bool UnresolvedAddress_NamedAddress::has_service_name() const {
  return port_specifier_case() == kServiceName;
}
void UnresolvedAddress_NamedAddress::set_has_service_name() {
  _oneof_case_[0] = kServiceName;
}
void UnresolvedAddress_NamedAddress::clear_service_name() {
  if (has_service_name()) {
    port_specifier_.service_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_port_specifier();
  }
}
const ::std::string& UnresolvedAddress_NamedAddress::service_name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
  if (has_service_name()) {
    return port_specifier_.service_name_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
void UnresolvedAddress_NamedAddress::set_service_name(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
  if (!has_service_name()) {
    clear_port_specifier();
    set_has_service_name();
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  port_specifier_.service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
}
#if LANG_CXX11
void UnresolvedAddress_NamedAddress::set_service_name(::std::string&& value) {
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
  if (!has_service_name()) {
    clear_port_specifier();
    set_has_service_name();
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  port_specifier_.service_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
}
#endif
void UnresolvedAddress_NamedAddress::set_service_name(const char* value) {
  if (!has_service_name()) {
    clear_port_specifier();
    set_has_service_name();
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  port_specifier_.service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
}
void UnresolvedAddress_NamedAddress::set_service_name(const char* value, size_t size) {
  if (!has_service_name()) {
    clear_port_specifier();
    set_has_service_name();
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  port_specifier_.service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
}
::std::string* UnresolvedAddress_NamedAddress::mutable_service_name() {
  if (!has_service_name()) {
    clear_port_specifier();
    set_has_service_name();
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
  return port_specifier_.service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UnresolvedAddress_NamedAddress::release_service_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
  if (has_service_name()) {
    clear_has_port_specifier();
    return port_specifier_.service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
void UnresolvedAddress_NamedAddress::set_allocated_service_name(::std::string* service_name) {
  if (!has_service_name()) {
    port_specifier_.service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_port_specifier();
  if (service_name != NULL) {
    set_has_service_name();
    port_specifier_.service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        service_name);
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.NamedAddress.service_name)
}

bool UnresolvedAddress_NamedAddress::has_port_specifier() const {
  return port_specifier_case() != PORT_SPECIFIER_NOT_SET;
}
void UnresolvedAddress_NamedAddress::clear_has_port_specifier() {
  _oneof_case_[0] = PORT_SPECIFIER_NOT_SET;
}
UnresolvedAddress_NamedAddress::PortSpecifierCase UnresolvedAddress_NamedAddress::port_specifier_case() const {
  return UnresolvedAddress_NamedAddress::PortSpecifierCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnresolvedAddress_Resolver::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnresolvedAddress_Resolver::UnresolvedAddress_Resolver()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.UnresolvedAddress.Resolver)
}
UnresolvedAddress_Resolver::UnresolvedAddress_Resolver(const UnresolvedAddress_Resolver& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.UnresolvedAddress.Resolver)
}

void UnresolvedAddress_Resolver::SharedCtor() {
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

UnresolvedAddress_Resolver::~UnresolvedAddress_Resolver() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.UnresolvedAddress.Resolver)
  SharedDtor();
}

void UnresolvedAddress_Resolver::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void UnresolvedAddress_Resolver::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnresolvedAddress_Resolver::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[2].descriptor;
}

const UnresolvedAddress_Resolver& UnresolvedAddress_Resolver::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnresolvedAddress_Resolver* UnresolvedAddress_Resolver::New(::google::protobuf::Arena* arena) const {
  UnresolvedAddress_Resolver* n = new UnresolvedAddress_Resolver;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnresolvedAddress_Resolver::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.UnresolvedAddress.Resolver)
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UnresolvedAddress_Resolver::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.UnresolvedAddress.Resolver)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "envoy.api.v2.UnresolvedAddress.Resolver.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.UnresolvedAddress.Resolver)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.UnresolvedAddress.Resolver)
  return false;
#undef DO_
}

void UnresolvedAddress_Resolver::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.UnresolvedAddress.Resolver)
  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.Resolver.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.UnresolvedAddress.Resolver)
}

::google::protobuf::uint8* UnresolvedAddress_Resolver::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.UnresolvedAddress.Resolver)
  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.UnresolvedAddress.Resolver.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.UnresolvedAddress.Resolver)
  return target;
}

size_t UnresolvedAddress_Resolver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.UnresolvedAddress.Resolver)
  size_t total_size = 0;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnresolvedAddress_Resolver::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.UnresolvedAddress.Resolver)
  GOOGLE_DCHECK_NE(&from, this);
  const UnresolvedAddress_Resolver* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UnresolvedAddress_Resolver>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.UnresolvedAddress.Resolver)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.UnresolvedAddress.Resolver)
    MergeFrom(*source);
  }
}

void UnresolvedAddress_Resolver::MergeFrom(const UnresolvedAddress_Resolver& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.UnresolvedAddress.Resolver)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void UnresolvedAddress_Resolver::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.UnresolvedAddress.Resolver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnresolvedAddress_Resolver::CopyFrom(const UnresolvedAddress_Resolver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.UnresolvedAddress.Resolver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnresolvedAddress_Resolver::IsInitialized() const {
  return true;
}

void UnresolvedAddress_Resolver::Swap(UnresolvedAddress_Resolver* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnresolvedAddress_Resolver::InternalSwap(UnresolvedAddress_Resolver* other) {
  name_.Swap(&other->name_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnresolvedAddress_Resolver::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[2];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnresolvedAddress_Resolver

// string name = 1;
void UnresolvedAddress_Resolver::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& UnresolvedAddress_Resolver::name() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.Resolver.name)
  return name_.GetNoArena();
}
void UnresolvedAddress_Resolver::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.UnresolvedAddress.Resolver.name)
}
#if LANG_CXX11
void UnresolvedAddress_Resolver::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.UnresolvedAddress.Resolver.name)
}
#endif
void UnresolvedAddress_Resolver::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.UnresolvedAddress.Resolver.name)
}
void UnresolvedAddress_Resolver::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.UnresolvedAddress.Resolver.name)
}
::std::string* UnresolvedAddress_Resolver::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.Resolver.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* UnresolvedAddress_Resolver::release_name() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.Resolver.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void UnresolvedAddress_Resolver::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.Resolver.name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnresolvedAddress::kResolverFieldNumber;
const int UnresolvedAddress::kNamedAddressFieldNumber;
const int UnresolvedAddress::kPipeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnresolvedAddress::UnresolvedAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.UnresolvedAddress)
}
UnresolvedAddress::UnresolvedAddress(const UnresolvedAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_resolver()) {
    resolver_ = new ::envoy::api::v2::UnresolvedAddress_Resolver(*from.resolver_);
  } else {
    resolver_ = NULL;
  }
  clear_has_address();
  switch (from.address_case()) {
    case kNamedAddress: {
      mutable_named_address()->::envoy::api::v2::UnresolvedAddress_NamedAddress::MergeFrom(from.named_address());
      break;
    }
    case kPipe: {
      mutable_pipe()->::envoy::api::v2::Pipe::MergeFrom(from.pipe());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.UnresolvedAddress)
}

void UnresolvedAddress::SharedCtor() {
  resolver_ = NULL;
  clear_has_address();
  _cached_size_ = 0;
}

UnresolvedAddress::~UnresolvedAddress() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.UnresolvedAddress)
  SharedDtor();
}

void UnresolvedAddress::SharedDtor() {
  if (this != internal_default_instance()) {
    delete resolver_;
  }
  if (has_address()) {
    clear_address();
  }
}

void UnresolvedAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnresolvedAddress::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[3].descriptor;
}

const UnresolvedAddress& UnresolvedAddress::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnresolvedAddress* UnresolvedAddress::New(::google::protobuf::Arena* arena) const {
  UnresolvedAddress* n = new UnresolvedAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnresolvedAddress::clear_address() {
// @@protoc_insertion_point(one_of_clear_start:envoy.api.v2.UnresolvedAddress)
  switch (address_case()) {
    case kNamedAddress: {
      delete address_.named_address_;
      break;
    }
    case kPipe: {
      delete address_.pipe_;
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ADDRESS_NOT_SET;
}


void UnresolvedAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.UnresolvedAddress)
  if (GetArenaNoVirtual() == NULL && resolver_ != NULL) {
    delete resolver_;
  }
  resolver_ = NULL;
  clear_address();
}

bool UnresolvedAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.UnresolvedAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .envoy.api.v2.UnresolvedAddress.Resolver resolver = 1;
      case 1: {
        if (tag == 10u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_resolver()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .envoy.api.v2.UnresolvedAddress.NamedAddress named_address = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_named_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .envoy.api.v2.Pipe pipe = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipe()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.UnresolvedAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.UnresolvedAddress)
  return false;
#undef DO_
}

void UnresolvedAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.UnresolvedAddress)
  // .envoy.api.v2.UnresolvedAddress.Resolver resolver = 1;
  if (this->has_resolver()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->resolver_, output);
  }

  // .envoy.api.v2.UnresolvedAddress.NamedAddress named_address = 2;
  if (has_named_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *address_.named_address_, output);
  }

  // .envoy.api.v2.Pipe pipe = 3;
  if (has_pipe()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *address_.pipe_, output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.UnresolvedAddress)
}

::google::protobuf::uint8* UnresolvedAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.UnresolvedAddress)
  // .envoy.api.v2.UnresolvedAddress.Resolver resolver = 1;
  if (this->has_resolver()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->resolver_, false, target);
  }

  // .envoy.api.v2.UnresolvedAddress.NamedAddress named_address = 2;
  if (has_named_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *address_.named_address_, false, target);
  }

  // .envoy.api.v2.Pipe pipe = 3;
  if (has_pipe()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *address_.pipe_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.UnresolvedAddress)
  return target;
}

size_t UnresolvedAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.UnresolvedAddress)
  size_t total_size = 0;

  // .envoy.api.v2.UnresolvedAddress.Resolver resolver = 1;
  if (this->has_resolver()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->resolver_);
  }

  switch (address_case()) {
    // .envoy.api.v2.UnresolvedAddress.NamedAddress named_address = 2;
    case kNamedAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *address_.named_address_);
      break;
    }
    // .envoy.api.v2.Pipe pipe = 3;
    case kPipe: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *address_.pipe_);
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnresolvedAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.UnresolvedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const UnresolvedAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UnresolvedAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.UnresolvedAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.UnresolvedAddress)
    MergeFrom(*source);
  }
}

void UnresolvedAddress::MergeFrom(const UnresolvedAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.UnresolvedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_resolver()) {
    mutable_resolver()->::envoy::api::v2::UnresolvedAddress_Resolver::MergeFrom(from.resolver());
  }
  switch (from.address_case()) {
    case kNamedAddress: {
      mutable_named_address()->::envoy::api::v2::UnresolvedAddress_NamedAddress::MergeFrom(from.named_address());
      break;
    }
    case kPipe: {
      mutable_pipe()->::envoy::api::v2::Pipe::MergeFrom(from.pipe());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
}

void UnresolvedAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.UnresolvedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnresolvedAddress::CopyFrom(const UnresolvedAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.UnresolvedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnresolvedAddress::IsInitialized() const {
  return true;
}

void UnresolvedAddress::Swap(UnresolvedAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnresolvedAddress::InternalSwap(UnresolvedAddress* other) {
  std::swap(resolver_, other->resolver_);
  std::swap(address_, other->address_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnresolvedAddress::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[3];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnresolvedAddress

// .envoy.api.v2.UnresolvedAddress.Resolver resolver = 1;
bool UnresolvedAddress::has_resolver() const {
  return this != internal_default_instance() && resolver_ != NULL;
}
void UnresolvedAddress::clear_resolver() {
  if (GetArenaNoVirtual() == NULL && resolver_ != NULL) delete resolver_;
  resolver_ = NULL;
}
const ::envoy::api::v2::UnresolvedAddress_Resolver& UnresolvedAddress::resolver() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.resolver)
  return resolver_ != NULL ? *resolver_
                         : *::envoy::api::v2::UnresolvedAddress_Resolver::internal_default_instance();
}
::envoy::api::v2::UnresolvedAddress_Resolver* UnresolvedAddress::mutable_resolver() {
  
  if (resolver_ == NULL) {
    resolver_ = new ::envoy::api::v2::UnresolvedAddress_Resolver;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.resolver)
  return resolver_;
}
::envoy::api::v2::UnresolvedAddress_Resolver* UnresolvedAddress::release_resolver() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.resolver)
  
  ::envoy::api::v2::UnresolvedAddress_Resolver* temp = resolver_;
  resolver_ = NULL;
  return temp;
}
void UnresolvedAddress::set_allocated_resolver(::envoy::api::v2::UnresolvedAddress_Resolver* resolver) {
  delete resolver_;
  resolver_ = resolver;
  if (resolver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.resolver)
}

// .envoy.api.v2.UnresolvedAddress.NamedAddress named_address = 2;
bool UnresolvedAddress::has_named_address() const {
  return address_case() == kNamedAddress;
}
void UnresolvedAddress::set_has_named_address() {
  _oneof_case_[0] = kNamedAddress;
}
void UnresolvedAddress::clear_named_address() {
  if (has_named_address()) {
    delete address_.named_address_;
    clear_has_address();
  }
}
 const ::envoy::api::v2::UnresolvedAddress_NamedAddress& UnresolvedAddress::named_address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.named_address)
  return has_named_address()
      ? *address_.named_address_
      : ::envoy::api::v2::UnresolvedAddress_NamedAddress::default_instance();
}
::envoy::api::v2::UnresolvedAddress_NamedAddress* UnresolvedAddress::mutable_named_address() {
  if (!has_named_address()) {
    clear_address();
    set_has_named_address();
    address_.named_address_ = new ::envoy::api::v2::UnresolvedAddress_NamedAddress;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.named_address)
  return address_.named_address_;
}
::envoy::api::v2::UnresolvedAddress_NamedAddress* UnresolvedAddress::release_named_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.named_address)
  if (has_named_address()) {
    clear_has_address();
    ::envoy::api::v2::UnresolvedAddress_NamedAddress* temp = address_.named_address_;
    address_.named_address_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void UnresolvedAddress::set_allocated_named_address(::envoy::api::v2::UnresolvedAddress_NamedAddress* named_address) {
  clear_address();
  if (named_address) {
    set_has_named_address();
    address_.named_address_ = named_address;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.named_address)
}

// .envoy.api.v2.Pipe pipe = 3;
bool UnresolvedAddress::has_pipe() const {
  return address_case() == kPipe;
}
void UnresolvedAddress::set_has_pipe() {
  _oneof_case_[0] = kPipe;
}
void UnresolvedAddress::clear_pipe() {
  if (has_pipe()) {
    delete address_.pipe_;
    clear_has_address();
  }
}
 const ::envoy::api::v2::Pipe& UnresolvedAddress::pipe() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddress.pipe)
  return has_pipe()
      ? *address_.pipe_
      : ::envoy::api::v2::Pipe::default_instance();
}
::envoy::api::v2::Pipe* UnresolvedAddress::mutable_pipe() {
  if (!has_pipe()) {
    clear_address();
    set_has_pipe();
    address_.pipe_ = new ::envoy::api::v2::Pipe;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddress.pipe)
  return address_.pipe_;
}
::envoy::api::v2::Pipe* UnresolvedAddress::release_pipe() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.UnresolvedAddress.pipe)
  if (has_pipe()) {
    clear_has_address();
    ::envoy::api::v2::Pipe* temp = address_.pipe_;
    address_.pipe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void UnresolvedAddress::set_allocated_pipe(::envoy::api::v2::Pipe* pipe) {
  clear_address();
  if (pipe) {
    set_has_pipe();
    address_.pipe_ = pipe;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.UnresolvedAddress.pipe)
}

bool UnresolvedAddress::has_address() const {
  return address_case() != ADDRESS_NOT_SET;
}
void UnresolvedAddress::clear_has_address() {
  _oneof_case_[0] = ADDRESS_NOT_SET;
}
UnresolvedAddress::AddressCase UnresolvedAddress::address_case() const {
  return UnresolvedAddress::AddressCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnresolvedAddresses::kAddressesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnresolvedAddresses::UnresolvedAddresses()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.UnresolvedAddresses)
}
UnresolvedAddresses::UnresolvedAddresses(const UnresolvedAddresses& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      addresses_(from.addresses_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.UnresolvedAddresses)
}

void UnresolvedAddresses::SharedCtor() {
  _cached_size_ = 0;
}

UnresolvedAddresses::~UnresolvedAddresses() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.UnresolvedAddresses)
  SharedDtor();
}

void UnresolvedAddresses::SharedDtor() {
}

void UnresolvedAddresses::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UnresolvedAddresses::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[4].descriptor;
}

const UnresolvedAddresses& UnresolvedAddresses::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

UnresolvedAddresses* UnresolvedAddresses::New(::google::protobuf::Arena* arena) const {
  UnresolvedAddresses* n = new UnresolvedAddresses;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnresolvedAddresses::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.UnresolvedAddresses)
  addresses_.Clear();
}

bool UnresolvedAddresses::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.UnresolvedAddresses)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .envoy.api.v2.UnresolvedAddress addresses = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_addresses()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.UnresolvedAddresses)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.UnresolvedAddresses)
  return false;
#undef DO_
}

void UnresolvedAddresses::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.UnresolvedAddresses)
  // repeated .envoy.api.v2.UnresolvedAddress addresses = 1;
  for (unsigned int i = 0, n = this->addresses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->addresses(i), output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.UnresolvedAddresses)
}

::google::protobuf::uint8* UnresolvedAddresses::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.UnresolvedAddresses)
  // repeated .envoy.api.v2.UnresolvedAddress addresses = 1;
  for (unsigned int i = 0, n = this->addresses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->addresses(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.UnresolvedAddresses)
  return target;
}

size_t UnresolvedAddresses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.UnresolvedAddresses)
  size_t total_size = 0;

  // repeated .envoy.api.v2.UnresolvedAddress addresses = 1;
  {
    unsigned int count = this->addresses_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->addresses(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnresolvedAddresses::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.UnresolvedAddresses)
  GOOGLE_DCHECK_NE(&from, this);
  const UnresolvedAddresses* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const UnresolvedAddresses>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.UnresolvedAddresses)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.UnresolvedAddresses)
    MergeFrom(*source);
  }
}

void UnresolvedAddresses::MergeFrom(const UnresolvedAddresses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.UnresolvedAddresses)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  addresses_.MergeFrom(from.addresses_);
}

void UnresolvedAddresses::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.UnresolvedAddresses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UnresolvedAddresses::CopyFrom(const UnresolvedAddresses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.UnresolvedAddresses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnresolvedAddresses::IsInitialized() const {
  return true;
}

void UnresolvedAddresses::Swap(UnresolvedAddresses* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnresolvedAddresses::InternalSwap(UnresolvedAddresses* other) {
  addresses_.UnsafeArenaSwap(&other->addresses_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UnresolvedAddresses::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[4];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnresolvedAddresses

// repeated .envoy.api.v2.UnresolvedAddress addresses = 1;
int UnresolvedAddresses::addresses_size() const {
  return addresses_.size();
}
void UnresolvedAddresses::clear_addresses() {
  addresses_.Clear();
}
const ::envoy::api::v2::UnresolvedAddress& UnresolvedAddresses::addresses(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.UnresolvedAddresses.addresses)
  return addresses_.Get(index);
}
::envoy::api::v2::UnresolvedAddress* UnresolvedAddresses::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.UnresolvedAddresses.addresses)
  return addresses_.Mutable(index);
}
::envoy::api::v2::UnresolvedAddress* UnresolvedAddresses::add_addresses() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.UnresolvedAddresses.addresses)
  return addresses_.Add();
}
::google::protobuf::RepeatedPtrField< ::envoy::api::v2::UnresolvedAddress >*
UnresolvedAddresses::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.UnresolvedAddresses.addresses)
  return &addresses_;
}
const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::UnresolvedAddress >&
UnresolvedAddresses::addresses() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.UnresolvedAddresses.addresses)
  return addresses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolvedAddress_SocketAddress::kProtocolFieldNumber;
const int ResolvedAddress_SocketAddress::kIpAddressFieldNumber;
const int ResolvedAddress_SocketAddress::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolvedAddress_SocketAddress::ResolvedAddress_SocketAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.ResolvedAddress.SocketAddress)
}
ResolvedAddress_SocketAddress::ResolvedAddress_SocketAddress(const ResolvedAddress_SocketAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ip_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.ip_address().size() > 0) {
    ip_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_address_);
  }
  if (from.has_port()) {
    port_ = new ::google::protobuf::UInt32Value(*from.port_);
  } else {
    port_ = NULL;
  }
  protocol_ = from.protocol_;
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.ResolvedAddress.SocketAddress)
}

void ResolvedAddress_SocketAddress::SharedCtor() {
  ip_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&port_, 0, reinterpret_cast<char*>(&protocol_) -
    reinterpret_cast<char*>(&port_) + sizeof(protocol_));
  _cached_size_ = 0;
}

ResolvedAddress_SocketAddress::~ResolvedAddress_SocketAddress() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.ResolvedAddress.SocketAddress)
  SharedDtor();
}

void ResolvedAddress_SocketAddress::SharedDtor() {
  ip_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete port_;
  }
}

void ResolvedAddress_SocketAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolvedAddress_SocketAddress::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[5].descriptor;
}

const ResolvedAddress_SocketAddress& ResolvedAddress_SocketAddress::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

ResolvedAddress_SocketAddress* ResolvedAddress_SocketAddress::New(::google::protobuf::Arena* arena) const {
  ResolvedAddress_SocketAddress* n = new ResolvedAddress_SocketAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolvedAddress_SocketAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && port_ != NULL) {
    delete port_;
  }
  port_ = NULL;
  protocol_ = 0;
}

bool ResolvedAddress_SocketAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .envoy.api.v2.ResolvedAddress.SocketAddress.Protocol protocol = 1;
      case 1: {
        if (tag == 8u) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_protocol(static_cast< ::envoy::api::v2::ResolvedAddress_SocketAddress_Protocol >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string ip_address = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_address()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->ip_address().data(), this->ip_address().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "envoy.api.v2.ResolvedAddress.SocketAddress.ip_address"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .google.protobuf.UInt32Value port = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_port()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.ResolvedAddress.SocketAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.ResolvedAddress.SocketAddress)
  return false;
#undef DO_
}

void ResolvedAddress_SocketAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  // .envoy.api.v2.ResolvedAddress.SocketAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->protocol(), output);
  }

  // string ip_address = 2;
  if (this->ip_address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.ResolvedAddress.SocketAddress.ip_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip_address(), output);
  }

  // .google.protobuf.UInt32Value port = 3;
  if (this->has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->port_, output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.ResolvedAddress.SocketAddress)
}

::google::protobuf::uint8* ResolvedAddress_SocketAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  // .envoy.api.v2.ResolvedAddress.SocketAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->protocol(), target);
  }

  // string ip_address = 2;
  if (this->ip_address().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "envoy.api.v2.ResolvedAddress.SocketAddress.ip_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip_address(), target);
  }

  // .google.protobuf.UInt32Value port = 3;
  if (this->has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->port_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.ResolvedAddress.SocketAddress)
  return target;
}

size_t ResolvedAddress_SocketAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  size_t total_size = 0;

  // string ip_address = 2;
  if (this->ip_address().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip_address());
  }

  // .google.protobuf.UInt32Value port = 3;
  if (this->has_port()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->port_);
  }

  // .envoy.api.v2.ResolvedAddress.SocketAddress.Protocol protocol = 1;
  if (this->protocol() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolvedAddress_SocketAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const ResolvedAddress_SocketAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolvedAddress_SocketAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.ResolvedAddress.SocketAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.ResolvedAddress.SocketAddress)
    MergeFrom(*source);
  }
}

void ResolvedAddress_SocketAddress::MergeFrom(const ResolvedAddress_SocketAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.ip_address().size() > 0) {

    ip_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_address_);
  }
  if (from.has_port()) {
    mutable_port()->::google::protobuf::UInt32Value::MergeFrom(from.port());
  }
  if (from.protocol() != 0) {
    set_protocol(from.protocol());
  }
}

void ResolvedAddress_SocketAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolvedAddress_SocketAddress::CopyFrom(const ResolvedAddress_SocketAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.ResolvedAddress.SocketAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolvedAddress_SocketAddress::IsInitialized() const {
  return true;
}

void ResolvedAddress_SocketAddress::Swap(ResolvedAddress_SocketAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolvedAddress_SocketAddress::InternalSwap(ResolvedAddress_SocketAddress* other) {
  ip_address_.Swap(&other->ip_address_);
  std::swap(port_, other->port_);
  std::swap(protocol_, other->protocol_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolvedAddress_SocketAddress::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[5];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolvedAddress_SocketAddress

// .envoy.api.v2.ResolvedAddress.SocketAddress.Protocol protocol = 1;
void ResolvedAddress_SocketAddress::clear_protocol() {
  protocol_ = 0;
}
::envoy::api::v2::ResolvedAddress_SocketAddress_Protocol ResolvedAddress_SocketAddress::protocol() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddress.SocketAddress.protocol)
  return static_cast< ::envoy::api::v2::ResolvedAddress_SocketAddress_Protocol >(protocol_);
}
void ResolvedAddress_SocketAddress::set_protocol(::envoy::api::v2::ResolvedAddress_SocketAddress_Protocol value) {
  
  protocol_ = value;
  // @@protoc_insertion_point(field_set:envoy.api.v2.ResolvedAddress.SocketAddress.protocol)
}

// string ip_address = 2;
void ResolvedAddress_SocketAddress::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& ResolvedAddress_SocketAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
  return ip_address_.GetNoArena();
}
void ResolvedAddress_SocketAddress::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
}
#if LANG_CXX11
void ResolvedAddress_SocketAddress::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
}
#endif
void ResolvedAddress_SocketAddress::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
}
void ResolvedAddress_SocketAddress::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
}
::std::string* ResolvedAddress_SocketAddress::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ResolvedAddress_SocketAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ResolvedAddress_SocketAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ResolvedAddress.SocketAddress.ip_address)
}

// .google.protobuf.UInt32Value port = 3;
bool ResolvedAddress_SocketAddress::has_port() const {
  return this != internal_default_instance() && port_ != NULL;
}
void ResolvedAddress_SocketAddress::clear_port() {
  if (GetArenaNoVirtual() == NULL && port_ != NULL) delete port_;
  port_ = NULL;
}
const ::google::protobuf::UInt32Value& ResolvedAddress_SocketAddress::port() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddress.SocketAddress.port)
  return port_ != NULL ? *port_
                         : *::google::protobuf::UInt32Value::internal_default_instance();
}
::google::protobuf::UInt32Value* ResolvedAddress_SocketAddress::mutable_port() {
  
  if (port_ == NULL) {
    port_ = new ::google::protobuf::UInt32Value;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ResolvedAddress.SocketAddress.port)
  return port_;
}
::google::protobuf::UInt32Value* ResolvedAddress_SocketAddress::release_port() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ResolvedAddress.SocketAddress.port)
  
  ::google::protobuf::UInt32Value* temp = port_;
  port_ = NULL;
  return temp;
}
void ResolvedAddress_SocketAddress::set_allocated_port(::google::protobuf::UInt32Value* port) {
  delete port_;
  if (port != NULL && port->GetArena() != NULL) {
    ::google::protobuf::UInt32Value* new_port = new ::google::protobuf::UInt32Value;
    new_port->CopyFrom(*port);
    port = new_port;
  }
  port_ = port;
  if (port) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ResolvedAddress.SocketAddress.port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolvedAddress::kSocketAddressFieldNumber;
const int ResolvedAddress::kPipeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolvedAddress::ResolvedAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.ResolvedAddress)
}
ResolvedAddress::ResolvedAddress(const ResolvedAddress& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  clear_has_address();
  switch (from.address_case()) {
    case kSocketAddress: {
      mutable_socket_address()->::envoy::api::v2::ResolvedAddress_SocketAddress::MergeFrom(from.socket_address());
      break;
    }
    case kPipe: {
      mutable_pipe()->::envoy::api::v2::Pipe::MergeFrom(from.pipe());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.ResolvedAddress)
}

void ResolvedAddress::SharedCtor() {
  clear_has_address();
  _cached_size_ = 0;
}

ResolvedAddress::~ResolvedAddress() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.ResolvedAddress)
  SharedDtor();
}

void ResolvedAddress::SharedDtor() {
  if (has_address()) {
    clear_address();
  }
}

void ResolvedAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolvedAddress::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[6].descriptor;
}

const ResolvedAddress& ResolvedAddress::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

ResolvedAddress* ResolvedAddress::New(::google::protobuf::Arena* arena) const {
  ResolvedAddress* n = new ResolvedAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolvedAddress::clear_address() {
// @@protoc_insertion_point(one_of_clear_start:envoy.api.v2.ResolvedAddress)
  switch (address_case()) {
    case kSocketAddress: {
      delete address_.socket_address_;
      break;
    }
    case kPipe: {
      delete address_.pipe_;
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = ADDRESS_NOT_SET;
}


void ResolvedAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.ResolvedAddress)
  clear_address();
}

bool ResolvedAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.ResolvedAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .envoy.api.v2.ResolvedAddress.SocketAddress socket_address = 2;
      case 2: {
        if (tag == 18u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_socket_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .envoy.api.v2.Pipe pipe = 3;
      case 3: {
        if (tag == 26u) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pipe()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.ResolvedAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.ResolvedAddress)
  return false;
#undef DO_
}

void ResolvedAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.ResolvedAddress)
  // .envoy.api.v2.ResolvedAddress.SocketAddress socket_address = 2;
  if (has_socket_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *address_.socket_address_, output);
  }

  // .envoy.api.v2.Pipe pipe = 3;
  if (has_pipe()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *address_.pipe_, output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.ResolvedAddress)
}

::google::protobuf::uint8* ResolvedAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.ResolvedAddress)
  // .envoy.api.v2.ResolvedAddress.SocketAddress socket_address = 2;
  if (has_socket_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *address_.socket_address_, false, target);
  }

  // .envoy.api.v2.Pipe pipe = 3;
  if (has_pipe()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *address_.pipe_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.ResolvedAddress)
  return target;
}

size_t ResolvedAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.ResolvedAddress)
  size_t total_size = 0;

  switch (address_case()) {
    // .envoy.api.v2.ResolvedAddress.SocketAddress socket_address = 2;
    case kSocketAddress: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *address_.socket_address_);
      break;
    }
    // .envoy.api.v2.Pipe pipe = 3;
    case kPipe: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *address_.pipe_);
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolvedAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.ResolvedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  const ResolvedAddress* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolvedAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.ResolvedAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.ResolvedAddress)
    MergeFrom(*source);
  }
}

void ResolvedAddress::MergeFrom(const ResolvedAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.ResolvedAddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  switch (from.address_case()) {
    case kSocketAddress: {
      mutable_socket_address()->::envoy::api::v2::ResolvedAddress_SocketAddress::MergeFrom(from.socket_address());
      break;
    }
    case kPipe: {
      mutable_pipe()->::envoy::api::v2::Pipe::MergeFrom(from.pipe());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
}

void ResolvedAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.ResolvedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolvedAddress::CopyFrom(const ResolvedAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.ResolvedAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolvedAddress::IsInitialized() const {
  return true;
}

void ResolvedAddress::Swap(ResolvedAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolvedAddress::InternalSwap(ResolvedAddress* other) {
  std::swap(address_, other->address_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolvedAddress::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[6];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolvedAddress

// .envoy.api.v2.ResolvedAddress.SocketAddress socket_address = 2;
bool ResolvedAddress::has_socket_address() const {
  return address_case() == kSocketAddress;
}
void ResolvedAddress::set_has_socket_address() {
  _oneof_case_[0] = kSocketAddress;
}
void ResolvedAddress::clear_socket_address() {
  if (has_socket_address()) {
    delete address_.socket_address_;
    clear_has_address();
  }
}
 const ::envoy::api::v2::ResolvedAddress_SocketAddress& ResolvedAddress::socket_address() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddress.socket_address)
  return has_socket_address()
      ? *address_.socket_address_
      : ::envoy::api::v2::ResolvedAddress_SocketAddress::default_instance();
}
::envoy::api::v2::ResolvedAddress_SocketAddress* ResolvedAddress::mutable_socket_address() {
  if (!has_socket_address()) {
    clear_address();
    set_has_socket_address();
    address_.socket_address_ = new ::envoy::api::v2::ResolvedAddress_SocketAddress;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ResolvedAddress.socket_address)
  return address_.socket_address_;
}
::envoy::api::v2::ResolvedAddress_SocketAddress* ResolvedAddress::release_socket_address() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ResolvedAddress.socket_address)
  if (has_socket_address()) {
    clear_has_address();
    ::envoy::api::v2::ResolvedAddress_SocketAddress* temp = address_.socket_address_;
    address_.socket_address_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ResolvedAddress::set_allocated_socket_address(::envoy::api::v2::ResolvedAddress_SocketAddress* socket_address) {
  clear_address();
  if (socket_address) {
    set_has_socket_address();
    address_.socket_address_ = socket_address;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ResolvedAddress.socket_address)
}

// .envoy.api.v2.Pipe pipe = 3;
bool ResolvedAddress::has_pipe() const {
  return address_case() == kPipe;
}
void ResolvedAddress::set_has_pipe() {
  _oneof_case_[0] = kPipe;
}
void ResolvedAddress::clear_pipe() {
  if (has_pipe()) {
    delete address_.pipe_;
    clear_has_address();
  }
}
 const ::envoy::api::v2::Pipe& ResolvedAddress::pipe() const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddress.pipe)
  return has_pipe()
      ? *address_.pipe_
      : ::envoy::api::v2::Pipe::default_instance();
}
::envoy::api::v2::Pipe* ResolvedAddress::mutable_pipe() {
  if (!has_pipe()) {
    clear_address();
    set_has_pipe();
    address_.pipe_ = new ::envoy::api::v2::Pipe;
  }
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ResolvedAddress.pipe)
  return address_.pipe_;
}
::envoy::api::v2::Pipe* ResolvedAddress::release_pipe() {
  // @@protoc_insertion_point(field_release:envoy.api.v2.ResolvedAddress.pipe)
  if (has_pipe()) {
    clear_has_address();
    ::envoy::api::v2::Pipe* temp = address_.pipe_;
    address_.pipe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void ResolvedAddress::set_allocated_pipe(::envoy::api::v2::Pipe* pipe) {
  clear_address();
  if (pipe) {
    set_has_pipe();
    address_.pipe_ = pipe;
  }
  // @@protoc_insertion_point(field_set_allocated:envoy.api.v2.ResolvedAddress.pipe)
}

bool ResolvedAddress::has_address() const {
  return address_case() != ADDRESS_NOT_SET;
}
void ResolvedAddress::clear_has_address() {
  _oneof_case_[0] = ADDRESS_NOT_SET;
}
ResolvedAddress::AddressCase ResolvedAddress::address_case() const {
  return ResolvedAddress::AddressCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResolvedAddresses::kAddressesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResolvedAddresses::ResolvedAddresses()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_api_2faddress_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:envoy.api.v2.ResolvedAddresses)
}
ResolvedAddresses::ResolvedAddresses(const ResolvedAddresses& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      addresses_(from.addresses_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:envoy.api.v2.ResolvedAddresses)
}

void ResolvedAddresses::SharedCtor() {
  _cached_size_ = 0;
}

ResolvedAddresses::~ResolvedAddresses() {
  // @@protoc_insertion_point(destructor:envoy.api.v2.ResolvedAddresses)
  SharedDtor();
}

void ResolvedAddresses::SharedDtor() {
}

void ResolvedAddresses::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResolvedAddresses::descriptor() {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[7].descriptor;
}

const ResolvedAddresses& ResolvedAddresses::default_instance() {
  protobuf_api_2faddress_2eproto::InitDefaults();
  return *internal_default_instance();
}

ResolvedAddresses* ResolvedAddresses::New(::google::protobuf::Arena* arena) const {
  ResolvedAddresses* n = new ResolvedAddresses;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResolvedAddresses::Clear() {
// @@protoc_insertion_point(message_clear_start:envoy.api.v2.ResolvedAddresses)
  addresses_.Clear();
}

bool ResolvedAddresses::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:envoy.api.v2.ResolvedAddresses)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .envoy.api.v2.ResolvedAddress addresses = 1;
      case 1: {
        if (tag == 10u) {
          DO_(input->IncrementRecursionDepth());
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_addresses()));
        } else {
          goto handle_unusual;
        }
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:envoy.api.v2.ResolvedAddresses)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:envoy.api.v2.ResolvedAddresses)
  return false;
#undef DO_
}

void ResolvedAddresses::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:envoy.api.v2.ResolvedAddresses)
  // repeated .envoy.api.v2.ResolvedAddress addresses = 1;
  for (unsigned int i = 0, n = this->addresses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->addresses(i), output);
  }

  // @@protoc_insertion_point(serialize_end:envoy.api.v2.ResolvedAddresses)
}

::google::protobuf::uint8* ResolvedAddresses::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic;  // Unused
  // @@protoc_insertion_point(serialize_to_array_start:envoy.api.v2.ResolvedAddresses)
  // repeated .envoy.api.v2.ResolvedAddress addresses = 1;
  for (unsigned int i = 0, n = this->addresses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->addresses(i), false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:envoy.api.v2.ResolvedAddresses)
  return target;
}

size_t ResolvedAddresses::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:envoy.api.v2.ResolvedAddresses)
  size_t total_size = 0;

  // repeated .envoy.api.v2.ResolvedAddress addresses = 1;
  {
    unsigned int count = this->addresses_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->addresses(i));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResolvedAddresses::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:envoy.api.v2.ResolvedAddresses)
  GOOGLE_DCHECK_NE(&from, this);
  const ResolvedAddresses* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ResolvedAddresses>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:envoy.api.v2.ResolvedAddresses)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:envoy.api.v2.ResolvedAddresses)
    MergeFrom(*source);
  }
}

void ResolvedAddresses::MergeFrom(const ResolvedAddresses& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:envoy.api.v2.ResolvedAddresses)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  addresses_.MergeFrom(from.addresses_);
}

void ResolvedAddresses::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:envoy.api.v2.ResolvedAddresses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResolvedAddresses::CopyFrom(const ResolvedAddresses& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:envoy.api.v2.ResolvedAddresses)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResolvedAddresses::IsInitialized() const {
  return true;
}

void ResolvedAddresses::Swap(ResolvedAddresses* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResolvedAddresses::InternalSwap(ResolvedAddresses* other) {
  addresses_.UnsafeArenaSwap(&other->addresses_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResolvedAddresses::GetMetadata() const {
  protobuf_api_2faddress_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_api_2faddress_2eproto::file_level_metadata[7];
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResolvedAddresses

// repeated .envoy.api.v2.ResolvedAddress addresses = 1;
int ResolvedAddresses::addresses_size() const {
  return addresses_.size();
}
void ResolvedAddresses::clear_addresses() {
  addresses_.Clear();
}
const ::envoy::api::v2::ResolvedAddress& ResolvedAddresses::addresses(int index) const {
  // @@protoc_insertion_point(field_get:envoy.api.v2.ResolvedAddresses.addresses)
  return addresses_.Get(index);
}
::envoy::api::v2::ResolvedAddress* ResolvedAddresses::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:envoy.api.v2.ResolvedAddresses.addresses)
  return addresses_.Mutable(index);
}
::envoy::api::v2::ResolvedAddress* ResolvedAddresses::add_addresses() {
  // @@protoc_insertion_point(field_add:envoy.api.v2.ResolvedAddresses.addresses)
  return addresses_.Add();
}
::google::protobuf::RepeatedPtrField< ::envoy::api::v2::ResolvedAddress >*
ResolvedAddresses::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:envoy.api.v2.ResolvedAddresses.addresses)
  return &addresses_;
}
const ::google::protobuf::RepeatedPtrField< ::envoy::api::v2::ResolvedAddress >&
ResolvedAddresses::addresses() const {
  // @@protoc_insertion_point(field_list:envoy.api.v2.ResolvedAddresses.addresses)
  return addresses_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace v2
}  // namespace api
}  // namespace envoy

// @@protoc_insertion_point(global_scope)
