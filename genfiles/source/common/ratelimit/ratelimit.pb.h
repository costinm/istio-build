// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: source/common/ratelimit/ratelimit.proto

#ifndef PROTOBUF_source_2fcommon_2fratelimit_2fratelimit_2eproto__INCLUDED
#define PROTOBUF_source_2fcommon_2fratelimit_2fratelimit_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace pb {
namespace lyft {
namespace ratelimit {
class RateLimit;
class RateLimitDefaultTypeInternal;
extern RateLimitDefaultTypeInternal _RateLimit_default_instance_;
class RateLimitDescriptor;
class RateLimitDescriptorDefaultTypeInternal;
extern RateLimitDescriptorDefaultTypeInternal _RateLimitDescriptor_default_instance_;
class RateLimitDescriptor_Entry;
class RateLimitDescriptor_EntryDefaultTypeInternal;
extern RateLimitDescriptor_EntryDefaultTypeInternal _RateLimitDescriptor_Entry_default_instance_;
class RateLimitRequest;
class RateLimitRequestDefaultTypeInternal;
extern RateLimitRequestDefaultTypeInternal _RateLimitRequest_default_instance_;
class RateLimitResponse;
class RateLimitResponseDefaultTypeInternal;
extern RateLimitResponseDefaultTypeInternal _RateLimitResponse_default_instance_;
class RateLimitResponse_DescriptorStatus;
class RateLimitResponse_DescriptorStatusDefaultTypeInternal;
extern RateLimitResponse_DescriptorStatusDefaultTypeInternal _RateLimitResponse_DescriptorStatus_default_instance_;
}  // namespace ratelimit
}  // namespace lyft
}  // namespace pb

namespace pb {
namespace lyft {
namespace ratelimit {

namespace protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto

enum RateLimit_Unit {
  RateLimit_Unit_UNKNOWN = 0,
  RateLimit_Unit_SECOND = 1,
  RateLimit_Unit_MINUTE = 2,
  RateLimit_Unit_HOUR = 3,
  RateLimit_Unit_DAY = 4,
  RateLimit_Unit_RateLimit_Unit_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RateLimit_Unit_RateLimit_Unit_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RateLimit_Unit_IsValid(int value);
const RateLimit_Unit RateLimit_Unit_Unit_MIN = RateLimit_Unit_UNKNOWN;
const RateLimit_Unit RateLimit_Unit_Unit_MAX = RateLimit_Unit_DAY;
const int RateLimit_Unit_Unit_ARRAYSIZE = RateLimit_Unit_Unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* RateLimit_Unit_descriptor();
inline const ::std::string& RateLimit_Unit_Name(RateLimit_Unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    RateLimit_Unit_descriptor(), value);
}
inline bool RateLimit_Unit_Parse(
    const ::std::string& name, RateLimit_Unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RateLimit_Unit>(
    RateLimit_Unit_descriptor(), name, value);
}
enum RateLimitResponse_Code {
  RateLimitResponse_Code_UNKNOWN = 0,
  RateLimitResponse_Code_OK = 1,
  RateLimitResponse_Code_OVER_LIMIT = 2,
  RateLimitResponse_Code_RateLimitResponse_Code_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RateLimitResponse_Code_RateLimitResponse_Code_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RateLimitResponse_Code_IsValid(int value);
const RateLimitResponse_Code RateLimitResponse_Code_Code_MIN = RateLimitResponse_Code_UNKNOWN;
const RateLimitResponse_Code RateLimitResponse_Code_Code_MAX = RateLimitResponse_Code_OVER_LIMIT;
const int RateLimitResponse_Code_Code_ARRAYSIZE = RateLimitResponse_Code_Code_MAX + 1;

const ::google::protobuf::EnumDescriptor* RateLimitResponse_Code_descriptor();
inline const ::std::string& RateLimitResponse_Code_Name(RateLimitResponse_Code value) {
  return ::google::protobuf::internal::NameOfEnum(
    RateLimitResponse_Code_descriptor(), value);
}
inline bool RateLimitResponse_Code_Parse(
    const ::std::string& name, RateLimitResponse_Code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RateLimitResponse_Code>(
    RateLimitResponse_Code_descriptor(), name, value);
}
// ===================================================================

class RateLimitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimitRequest) */ {
 public:
  RateLimitRequest();
  virtual ~RateLimitRequest();

  RateLimitRequest(const RateLimitRequest& from);

  inline RateLimitRequest& operator=(const RateLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitRequest(RateLimitRequest&& from) noexcept
    : RateLimitRequest() {
    *this = ::std::move(from);
  }

  inline RateLimitRequest& operator=(RateLimitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitRequest& default_instance();

  static inline const RateLimitRequest* internal_default_instance() {
    return reinterpret_cast<const RateLimitRequest*>(
               &_RateLimitRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(RateLimitRequest* other);
  friend void swap(RateLimitRequest& a, RateLimitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitRequest& from);
  void MergeFrom(const RateLimitRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.lyft.ratelimit.RateLimitDescriptor descriptors = 2;
  int descriptors_size() const;
  void clear_descriptors();
  static const int kDescriptorsFieldNumber = 2;
  const ::pb::lyft::ratelimit::RateLimitDescriptor& descriptors(int index) const;
  ::pb::lyft::ratelimit::RateLimitDescriptor* mutable_descriptors(int index);
  ::pb::lyft::ratelimit::RateLimitDescriptor* add_descriptors();
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor >*
      mutable_descriptors();
  const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor >&
      descriptors() const;

  // string domain = 1;
  void clear_domain();
  static const int kDomainFieldNumber = 1;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor > descriptors_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimitDescriptor_Entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimitDescriptor.Entry) */ {
 public:
  RateLimitDescriptor_Entry();
  virtual ~RateLimitDescriptor_Entry();

  RateLimitDescriptor_Entry(const RateLimitDescriptor_Entry& from);

  inline RateLimitDescriptor_Entry& operator=(const RateLimitDescriptor_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitDescriptor_Entry(RateLimitDescriptor_Entry&& from) noexcept
    : RateLimitDescriptor_Entry() {
    *this = ::std::move(from);
  }

  inline RateLimitDescriptor_Entry& operator=(RateLimitDescriptor_Entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitDescriptor_Entry& default_instance();

  static inline const RateLimitDescriptor_Entry* internal_default_instance() {
    return reinterpret_cast<const RateLimitDescriptor_Entry*>(
               &_RateLimitDescriptor_Entry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(RateLimitDescriptor_Entry* other);
  friend void swap(RateLimitDescriptor_Entry& a, RateLimitDescriptor_Entry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitDescriptor_Entry* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitDescriptor_Entry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitDescriptor_Entry& from);
  void MergeFrom(const RateLimitDescriptor_Entry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitDescriptor_Entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimitDescriptor.Entry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimitDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimitDescriptor) */ {
 public:
  RateLimitDescriptor();
  virtual ~RateLimitDescriptor();

  RateLimitDescriptor(const RateLimitDescriptor& from);

  inline RateLimitDescriptor& operator=(const RateLimitDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitDescriptor(RateLimitDescriptor&& from) noexcept
    : RateLimitDescriptor() {
    *this = ::std::move(from);
  }

  inline RateLimitDescriptor& operator=(RateLimitDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitDescriptor& default_instance();

  static inline const RateLimitDescriptor* internal_default_instance() {
    return reinterpret_cast<const RateLimitDescriptor*>(
               &_RateLimitDescriptor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RateLimitDescriptor* other);
  friend void swap(RateLimitDescriptor& a, RateLimitDescriptor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitDescriptor* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitDescriptor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitDescriptor& from);
  void MergeFrom(const RateLimitDescriptor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RateLimitDescriptor_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .pb.lyft.ratelimit.RateLimitDescriptor.Entry entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  const ::pb::lyft::ratelimit::RateLimitDescriptor_Entry& entries(int index) const;
  ::pb::lyft::ratelimit::RateLimitDescriptor_Entry* mutable_entries(int index);
  ::pb::lyft::ratelimit::RateLimitDescriptor_Entry* add_entries();
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor_Entry >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor_Entry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimitDescriptor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor_Entry > entries_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimit) */ {
 public:
  RateLimit();
  virtual ~RateLimit();

  RateLimit(const RateLimit& from);

  inline RateLimit& operator=(const RateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimit(RateLimit&& from) noexcept
    : RateLimit() {
    *this = ::std::move(from);
  }

  inline RateLimit& operator=(RateLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimit& default_instance();

  static inline const RateLimit* internal_default_instance() {
    return reinterpret_cast<const RateLimit*>(
               &_RateLimit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RateLimit* other);
  friend void swap(RateLimit& a, RateLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimit* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimit& from);
  void MergeFrom(const RateLimit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RateLimit_Unit Unit;
  static const Unit UNKNOWN =
    RateLimit_Unit_UNKNOWN;
  static const Unit SECOND =
    RateLimit_Unit_SECOND;
  static const Unit MINUTE =
    RateLimit_Unit_MINUTE;
  static const Unit HOUR =
    RateLimit_Unit_HOUR;
  static const Unit DAY =
    RateLimit_Unit_DAY;
  static inline bool Unit_IsValid(int value) {
    return RateLimit_Unit_IsValid(value);
  }
  static const Unit Unit_MIN =
    RateLimit_Unit_Unit_MIN;
  static const Unit Unit_MAX =
    RateLimit_Unit_Unit_MAX;
  static const int Unit_ARRAYSIZE =
    RateLimit_Unit_Unit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Unit_descriptor() {
    return RateLimit_Unit_descriptor();
  }
  static inline const ::std::string& Unit_Name(Unit value) {
    return RateLimit_Unit_Name(value);
  }
  static inline bool Unit_Parse(const ::std::string& name,
      Unit* value) {
    return RateLimit_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // uint32 requests_per_unit = 1;
  void clear_requests_per_unit();
  static const int kRequestsPerUnitFieldNumber = 1;
  ::google::protobuf::uint32 requests_per_unit() const;
  void set_requests_per_unit(::google::protobuf::uint32 value);

  // .pb.lyft.ratelimit.RateLimit.Unit unit = 2;
  void clear_unit();
  static const int kUnitFieldNumber = 2;
  ::pb::lyft::ratelimit::RateLimit_Unit unit() const;
  void set_unit(::pb::lyft::ratelimit::RateLimit_Unit value);

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 requests_per_unit_;
  int unit_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimitResponse_DescriptorStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus) */ {
 public:
  RateLimitResponse_DescriptorStatus();
  virtual ~RateLimitResponse_DescriptorStatus();

  RateLimitResponse_DescriptorStatus(const RateLimitResponse_DescriptorStatus& from);

  inline RateLimitResponse_DescriptorStatus& operator=(const RateLimitResponse_DescriptorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitResponse_DescriptorStatus(RateLimitResponse_DescriptorStatus&& from) noexcept
    : RateLimitResponse_DescriptorStatus() {
    *this = ::std::move(from);
  }

  inline RateLimitResponse_DescriptorStatus& operator=(RateLimitResponse_DescriptorStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitResponse_DescriptorStatus& default_instance();

  static inline const RateLimitResponse_DescriptorStatus* internal_default_instance() {
    return reinterpret_cast<const RateLimitResponse_DescriptorStatus*>(
               &_RateLimitResponse_DescriptorStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RateLimitResponse_DescriptorStatus* other);
  friend void swap(RateLimitResponse_DescriptorStatus& a, RateLimitResponse_DescriptorStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitResponse_DescriptorStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitResponse_DescriptorStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitResponse_DescriptorStatus& from);
  void MergeFrom(const RateLimitResponse_DescriptorStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitResponse_DescriptorStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pb.lyft.ratelimit.RateLimit current_limit = 2;
  bool has_current_limit() const;
  void clear_current_limit();
  static const int kCurrentLimitFieldNumber = 2;
  const ::pb::lyft::ratelimit::RateLimit& current_limit() const;
  ::pb::lyft::ratelimit::RateLimit* mutable_current_limit();
  ::pb::lyft::ratelimit::RateLimit* release_current_limit();
  void set_allocated_current_limit(::pb::lyft::ratelimit::RateLimit* current_limit);

  // .pb.lyft.ratelimit.RateLimitResponse.Code code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::pb::lyft::ratelimit::RateLimitResponse_Code code() const;
  void set_code(::pb::lyft::ratelimit::RateLimitResponse_Code value);

  // uint32 limit_remaining = 3;
  void clear_limit_remaining();
  static const int kLimitRemainingFieldNumber = 3;
  ::google::protobuf::uint32 limit_remaining() const;
  void set_limit_remaining(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::pb::lyft::ratelimit::RateLimit* current_limit_;
  int code_;
  ::google::protobuf::uint32 limit_remaining_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RateLimitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.lyft.ratelimit.RateLimitResponse) */ {
 public:
  RateLimitResponse();
  virtual ~RateLimitResponse();

  RateLimitResponse(const RateLimitResponse& from);

  inline RateLimitResponse& operator=(const RateLimitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RateLimitResponse(RateLimitResponse&& from) noexcept
    : RateLimitResponse() {
    *this = ::std::move(from);
  }

  inline RateLimitResponse& operator=(RateLimitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RateLimitResponse& default_instance();

  static inline const RateLimitResponse* internal_default_instance() {
    return reinterpret_cast<const RateLimitResponse*>(
               &_RateLimitResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RateLimitResponse* other);
  friend void swap(RateLimitResponse& a, RateLimitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RateLimitResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RateLimitResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RateLimitResponse& from);
  void MergeFrom(const RateLimitResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RateLimitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RateLimitResponse_DescriptorStatus DescriptorStatus;

  typedef RateLimitResponse_Code Code;
  static const Code UNKNOWN =
    RateLimitResponse_Code_UNKNOWN;
  static const Code OK =
    RateLimitResponse_Code_OK;
  static const Code OVER_LIMIT =
    RateLimitResponse_Code_OVER_LIMIT;
  static inline bool Code_IsValid(int value) {
    return RateLimitResponse_Code_IsValid(value);
  }
  static const Code Code_MIN =
    RateLimitResponse_Code_Code_MIN;
  static const Code Code_MAX =
    RateLimitResponse_Code_Code_MAX;
  static const int Code_ARRAYSIZE =
    RateLimitResponse_Code_Code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Code_descriptor() {
    return RateLimitResponse_Code_descriptor();
  }
  static inline const ::std::string& Code_Name(Code value) {
    return RateLimitResponse_Code_Name(value);
  }
  static inline bool Code_Parse(const ::std::string& name,
      Code* value) {
    return RateLimitResponse_Code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus statuses = 2;
  int statuses_size() const;
  void clear_statuses();
  static const int kStatusesFieldNumber = 2;
  const ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus& statuses(int index) const;
  ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus* mutable_statuses(int index);
  ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus* add_statuses();
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus >*
      mutable_statuses();
  const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus >&
      statuses() const;

  // .pb.lyft.ratelimit.RateLimitResponse.Code overall_code = 1;
  void clear_overall_code();
  static const int kOverallCodeFieldNumber = 1;
  ::pb::lyft::ratelimit::RateLimitResponse_Code overall_code() const;
  void set_overall_code(::pb::lyft::ratelimit::RateLimitResponse_Code value);

  // @@protoc_insertion_point(class_scope:pb.lyft.ratelimit.RateLimitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus > statuses_;
  int overall_code_;
  mutable int _cached_size_;
  friend struct protobuf_source_2fcommon_2fratelimit_2fratelimit_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RateLimitRequest

// string domain = 1;
inline void RateLimitRequest::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimitRequest::domain() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitRequest.domain)
  return domain_.GetNoArena();
}
inline void RateLimitRequest::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitRequest.domain)
}
#if LANG_CXX11
inline void RateLimitRequest::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.lyft.ratelimit.RateLimitRequest.domain)
}
#endif
inline void RateLimitRequest::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.lyft.ratelimit.RateLimitRequest.domain)
}
inline void RateLimitRequest::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.lyft.ratelimit.RateLimitRequest.domain)
}
inline ::std::string* RateLimitRequest::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitRequest.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimitRequest::release_domain() {
  // @@protoc_insertion_point(field_release:pb.lyft.ratelimit.RateLimitRequest.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimitRequest::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:pb.lyft.ratelimit.RateLimitRequest.domain)
}

// repeated .pb.lyft.ratelimit.RateLimitDescriptor descriptors = 2;
inline int RateLimitRequest::descriptors_size() const {
  return descriptors_.size();
}
inline void RateLimitRequest::clear_descriptors() {
  descriptors_.Clear();
}
inline const ::pb::lyft::ratelimit::RateLimitDescriptor& RateLimitRequest::descriptors(int index) const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitRequest.descriptors)
  return descriptors_.Get(index);
}
inline ::pb::lyft::ratelimit::RateLimitDescriptor* RateLimitRequest::mutable_descriptors(int index) {
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitRequest.descriptors)
  return descriptors_.Mutable(index);
}
inline ::pb::lyft::ratelimit::RateLimitDescriptor* RateLimitRequest::add_descriptors() {
  // @@protoc_insertion_point(field_add:pb.lyft.ratelimit.RateLimitRequest.descriptors)
  return descriptors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor >*
RateLimitRequest::mutable_descriptors() {
  // @@protoc_insertion_point(field_mutable_list:pb.lyft.ratelimit.RateLimitRequest.descriptors)
  return &descriptors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor >&
RateLimitRequest::descriptors() const {
  // @@protoc_insertion_point(field_list:pb.lyft.ratelimit.RateLimitRequest.descriptors)
  return descriptors_;
}

// -------------------------------------------------------------------

// RateLimitDescriptor_Entry

// string key = 1;
inline void RateLimitDescriptor_Entry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimitDescriptor_Entry::key() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
  return key_.GetNoArena();
}
inline void RateLimitDescriptor_Entry::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
}
#if LANG_CXX11
inline void RateLimitDescriptor_Entry::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
}
#endif
inline void RateLimitDescriptor_Entry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
}
inline void RateLimitDescriptor_Entry::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
}
inline ::std::string* RateLimitDescriptor_Entry::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimitDescriptor_Entry::release_key() {
  // @@protoc_insertion_point(field_release:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimitDescriptor_Entry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:pb.lyft.ratelimit.RateLimitDescriptor.Entry.key)
}

// string value = 2;
inline void RateLimitDescriptor_Entry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RateLimitDescriptor_Entry::value() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
  return value_.GetNoArena();
}
inline void RateLimitDescriptor_Entry::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
}
#if LANG_CXX11
inline void RateLimitDescriptor_Entry::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
}
#endif
inline void RateLimitDescriptor_Entry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
}
inline void RateLimitDescriptor_Entry::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
}
inline ::std::string* RateLimitDescriptor_Entry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RateLimitDescriptor_Entry::release_value() {
  // @@protoc_insertion_point(field_release:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RateLimitDescriptor_Entry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:pb.lyft.ratelimit.RateLimitDescriptor.Entry.value)
}

// -------------------------------------------------------------------

// RateLimitDescriptor

// repeated .pb.lyft.ratelimit.RateLimitDescriptor.Entry entries = 1;
inline int RateLimitDescriptor::entries_size() const {
  return entries_.size();
}
inline void RateLimitDescriptor::clear_entries() {
  entries_.Clear();
}
inline const ::pb::lyft::ratelimit::RateLimitDescriptor_Entry& RateLimitDescriptor::entries(int index) const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitDescriptor.entries)
  return entries_.Get(index);
}
inline ::pb::lyft::ratelimit::RateLimitDescriptor_Entry* RateLimitDescriptor::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitDescriptor.entries)
  return entries_.Mutable(index);
}
inline ::pb::lyft::ratelimit::RateLimitDescriptor_Entry* RateLimitDescriptor::add_entries() {
  // @@protoc_insertion_point(field_add:pb.lyft.ratelimit.RateLimitDescriptor.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor_Entry >*
RateLimitDescriptor::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:pb.lyft.ratelimit.RateLimitDescriptor.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitDescriptor_Entry >&
RateLimitDescriptor::entries() const {
  // @@protoc_insertion_point(field_list:pb.lyft.ratelimit.RateLimitDescriptor.entries)
  return entries_;
}

// -------------------------------------------------------------------

// RateLimit

// uint32 requests_per_unit = 1;
inline void RateLimit::clear_requests_per_unit() {
  requests_per_unit_ = 0u;
}
inline ::google::protobuf::uint32 RateLimit::requests_per_unit() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimit.requests_per_unit)
  return requests_per_unit_;
}
inline void RateLimit::set_requests_per_unit(::google::protobuf::uint32 value) {
  
  requests_per_unit_ = value;
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimit.requests_per_unit)
}

// .pb.lyft.ratelimit.RateLimit.Unit unit = 2;
inline void RateLimit::clear_unit() {
  unit_ = 0;
}
inline ::pb::lyft::ratelimit::RateLimit_Unit RateLimit::unit() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimit.unit)
  return static_cast< ::pb::lyft::ratelimit::RateLimit_Unit >(unit_);
}
inline void RateLimit::set_unit(::pb::lyft::ratelimit::RateLimit_Unit value) {
  
  unit_ = value;
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimit.unit)
}

// -------------------------------------------------------------------

// RateLimitResponse_DescriptorStatus

// .pb.lyft.ratelimit.RateLimitResponse.Code code = 1;
inline void RateLimitResponse_DescriptorStatus::clear_code() {
  code_ = 0;
}
inline ::pb::lyft::ratelimit::RateLimitResponse_Code RateLimitResponse_DescriptorStatus::code() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.code)
  return static_cast< ::pb::lyft::ratelimit::RateLimitResponse_Code >(code_);
}
inline void RateLimitResponse_DescriptorStatus::set_code(::pb::lyft::ratelimit::RateLimitResponse_Code value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.code)
}

// .pb.lyft.ratelimit.RateLimit current_limit = 2;
inline bool RateLimitResponse_DescriptorStatus::has_current_limit() const {
  return this != internal_default_instance() && current_limit_ != NULL;
}
inline void RateLimitResponse_DescriptorStatus::clear_current_limit() {
  if (GetArenaNoVirtual() == NULL && current_limit_ != NULL) delete current_limit_;
  current_limit_ = NULL;
}
inline const ::pb::lyft::ratelimit::RateLimit& RateLimitResponse_DescriptorStatus::current_limit() const {
  const ::pb::lyft::ratelimit::RateLimit* p = current_limit_;
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.current_limit)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::lyft::ratelimit::RateLimit*>(
      &::pb::lyft::ratelimit::_RateLimit_default_instance_);
}
inline ::pb::lyft::ratelimit::RateLimit* RateLimitResponse_DescriptorStatus::mutable_current_limit() {
  
  if (current_limit_ == NULL) {
    current_limit_ = new ::pb::lyft::ratelimit::RateLimit;
  }
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.current_limit)
  return current_limit_;
}
inline ::pb::lyft::ratelimit::RateLimit* RateLimitResponse_DescriptorStatus::release_current_limit() {
  // @@protoc_insertion_point(field_release:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.current_limit)
  
  ::pb::lyft::ratelimit::RateLimit* temp = current_limit_;
  current_limit_ = NULL;
  return temp;
}
inline void RateLimitResponse_DescriptorStatus::set_allocated_current_limit(::pb::lyft::ratelimit::RateLimit* current_limit) {
  delete current_limit_;
  current_limit_ = current_limit;
  if (current_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.current_limit)
}

// uint32 limit_remaining = 3;
inline void RateLimitResponse_DescriptorStatus::clear_limit_remaining() {
  limit_remaining_ = 0u;
}
inline ::google::protobuf::uint32 RateLimitResponse_DescriptorStatus::limit_remaining() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.limit_remaining)
  return limit_remaining_;
}
inline void RateLimitResponse_DescriptorStatus::set_limit_remaining(::google::protobuf::uint32 value) {
  
  limit_remaining_ = value;
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus.limit_remaining)
}

// -------------------------------------------------------------------

// RateLimitResponse

// .pb.lyft.ratelimit.RateLimitResponse.Code overall_code = 1;
inline void RateLimitResponse::clear_overall_code() {
  overall_code_ = 0;
}
inline ::pb::lyft::ratelimit::RateLimitResponse_Code RateLimitResponse::overall_code() const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitResponse.overall_code)
  return static_cast< ::pb::lyft::ratelimit::RateLimitResponse_Code >(overall_code_);
}
inline void RateLimitResponse::set_overall_code(::pb::lyft::ratelimit::RateLimitResponse_Code value) {
  
  overall_code_ = value;
  // @@protoc_insertion_point(field_set:pb.lyft.ratelimit.RateLimitResponse.overall_code)
}

// repeated .pb.lyft.ratelimit.RateLimitResponse.DescriptorStatus statuses = 2;
inline int RateLimitResponse::statuses_size() const {
  return statuses_.size();
}
inline void RateLimitResponse::clear_statuses() {
  statuses_.Clear();
}
inline const ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus& RateLimitResponse::statuses(int index) const {
  // @@protoc_insertion_point(field_get:pb.lyft.ratelimit.RateLimitResponse.statuses)
  return statuses_.Get(index);
}
inline ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus* RateLimitResponse::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:pb.lyft.ratelimit.RateLimitResponse.statuses)
  return statuses_.Mutable(index);
}
inline ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus* RateLimitResponse::add_statuses() {
  // @@protoc_insertion_point(field_add:pb.lyft.ratelimit.RateLimitResponse.statuses)
  return statuses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus >*
RateLimitResponse::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:pb.lyft.ratelimit.RateLimitResponse.statuses)
  return &statuses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::lyft::ratelimit::RateLimitResponse_DescriptorStatus >&
RateLimitResponse::statuses() const {
  // @@protoc_insertion_point(field_list:pb.lyft.ratelimit.RateLimitResponse.statuses)
  return statuses_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace ratelimit
}  // namespace lyft
}  // namespace pb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::lyft::ratelimit::RateLimit_Unit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::lyft::ratelimit::RateLimit_Unit>() {
  return ::pb::lyft::ratelimit::RateLimit_Unit_descriptor();
}
template <> struct is_proto_enum< ::pb::lyft::ratelimit::RateLimitResponse_Code> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::lyft::ratelimit::RateLimitResponse_Code>() {
  return ::pb::lyft::ratelimit::RateLimitResponse_Code_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_source_2fcommon_2fratelimit_2fratelimit_2eproto__INCLUDED
